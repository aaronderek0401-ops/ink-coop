// é¦–å…ˆï¼Œåœ¨CSSä¸­æ·»åŠ ç©ºå¿ƒçŸ©å½¢çš„æ ·å¼
const char* WEB_LAYOUT_HTML = R"rawliteral(
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢¨æ°´å±å¸ƒå±€ç¼–è¾‘å™¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }

        .preview-section {
            flex: 1;
            min-width: 400px;
        }

        .controls-section {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .screen-container {
            width: 416px;
            height: 240px;
            border: 3px solid #333;
            background: #fff;
            position: relative;
            margin: 20px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            user-select: none;
            /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }

        .rect {
            position: absolute;
            border: 2px solid #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            cursor: move;
            transition: all 0.3s;
            z-index: 10;
        }

        .rect:hover {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.2);
            z-index: 15;
        }

        .rect.selected {
            border-color: #FF9800;
            border-width: 3px;
            background: rgba(255, 152, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.6);
            z-index: 20;
        }

        /* æ‹–æ‹½ç›®æ ‡çŸ©å½¢é«˜äº®æ ·å¼ */
        .rect.drop-target {
            border-color: #9C27B0;
            border-width: 3px;
            border-style: dashed;
            background: rgba(156, 39, 176, 0.2);
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.4) inset;
            z-index: 18;
        }

        /* è°ƒæ•´å¤§å°çš„æ‰‹æŸ„æ ·å¼ */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #fff;
            border: 2px solid #2196F3;
            border-radius: 50%;
            z-index: 101;
            display: none;
            /* é»˜è®¤éšè— */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .rect:hover .resize-handle,
        .rect.selected .resize-handle {
            display: block;
        }

        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        .resize-handle.e {
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .resize-handle.s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .resize-handle:hover {
            background-color: #2196F3;
            transform: scale(1.2);
        }

        .resize-handle.e:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .resize-handle.s:hover {
            transform: translateX(-50%) scale(1.2);
        }


        /* æ–°çš„ç©ºå¿ƒçŸ©å½¢æ ·å¼ */
        .icon-hollow-rect {
            position: absolute;
            border: 2px solid #FF5722;
            background: rgba(255, 255, 255, 0.01);
            /* å¢åŠ ç‚¹å‡»åŒºåŸŸ */
            box-sizing: border-box;
            cursor: grab;
            transition: transform 0.1s, box-shadow 0.1s, border-color 0.1s;
            z-index: 50;
            border-radius: 4px;
        }

        .icon-hollow-rect:active {
            cursor: grabbing;
        }

        .icon-hollow-rect:hover {
            border-color: #E91E63;
            background: rgba(233, 30, 99, 0.1);
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 60;
        }

        .icon-hollow-rect.selected {
            border-color: #2196F3;
            border-width: 3px;
            background: rgba(33, 150, 243, 0.2);
            box-shadow: 0 0 0 2px white, 0 0 10px #2196F3;
            z-index: 55;
        }

        .icon-hollow-rect.dragging {
            border-color: #9C27B0;
            background: rgba(156, 39, 176, 0.3);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
            transform: scale(1.1);
            opacity: 0.9;
            z-index: 100;
            /* æ‹–æ‹½æ—¶æœ€é«˜ */
        }

        /* åˆ é™¤æŒ‰é’®æ ·å¼ */
        .delete-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: background 0.3s;
        }

        .delete-btn:hover {
            background-color: #d32f2f;
        }

        /* å›¾æ ‡æ ‡ç­¾æ ·å¼ */
        .icon-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: #FF5722;
            text-align: center;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .icon-hollow-rect:hover .icon-label {
            color: #E91E63;
        }

        .icon-hollow-rect.selected .icon-label {
            color: #2196F3;
        }

        .icon-hollow-rect.dragging .icon-label {
            color: #9C27B0;
        }

        /* æ–‡æœ¬å…ƒç´ æ ·å¼ */
        .text-element {
            font-family: Arial, sans-serif;
            line-height: 1.2;
            z-index: 45;
            transition: all 0.2s ease;
        }

        .text-element.selected {
            border-color: #2196F3 !important;
            border-width: 2px !important;
            border-style: solid !important;
            background-color: rgba(33, 150, 243, 0.2) !important;
            box-shadow: 0 0 0 1px white, 0 0 8px #2196F3;
            z-index: 55;
        }

        .text-element.dragging {
            border-style: solid !important;
            border-width: 2px !important;
            background-color: rgba(156, 39, 176, 0.3) !important;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
            opacity: 0.9;
            z-index: 100;
        }

        .text-element:hover {
            z-index: 50;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 600;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .rect-info {
            background: white;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
        }

        .rect-id {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }

        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(0, 0, 0, 0.05);
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
        }

        .grid-line.horizontal {
            height: 1px;
            width: 100%;
        }

        /* å¯¹é½è¾…åŠ©çº¿ */
        .alignment-guide {
            position: absolute;
            z-index: 200;
            pointer-events: none;
        }

        .alignment-guide.vertical {
            width: 2px;
            background: #2196F3;
            height: 100%;
        }

        .alignment-guide.horizontal {
            height: 2px;
            background: #2196F3;
            width: 100%;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .screen-container {
                width: 100%;
                max-width: 416px;
                height: 240px;
            }
        }
    </style>
</head>

<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div id="loadingText">å¤„ç†ä¸­...</div>
    </div>

    <div class="container">
        <header>
            <h1>å¢¨æ°´å±å¸ƒå±€ç¼–è¾‘å™¨</h1>
            <p class="subtitle">å¯è§†åŒ–ç¼–è¾‘å¢¨æ°´å±çŸ©å½¢å’Œå›¾æ ‡å¸ƒå±€</p>
            <div style="margin-top: 20px;">
                <label style="font-size: 1.1em; margin-right: 10px;">ç¼–è¾‘ç•Œé¢:</label>
                <select id="screenMode" onchange="switchScreenMode()"
                    style="font-size: 1em; padding: 8px 15px; border-radius: 5px; border: 2px solid white; background: rgba(255,255,255,0.2); color: white; cursor: pointer;">
                    <option value="main">ä¸»ç•Œé¢ (Main Screen)</option>
                    <option value="vocab">å•è¯ç•Œé¢ (Vocabulary Screen)</option>
                </select>
            </div>
        </header>

        <div class="main-content">
            <div class="preview-section">
                <div class="screen-container" id="screenContainer">
                    <!-- ç½‘æ ¼çº¿ -->
                    <div class="grid-lines" id="gridLines"></div>
                    <!-- å¯¹é½è¾…åŠ©çº¿ -->
                    <div id="alignmentGuides"></div>
                    <!-- çŸ©å½¢å’Œå›¾æ ‡ä¼šåŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <p>å±å¹•å°ºå¯¸: <span id="screenSize">416Ã—240</span></p>
                    <p>å½“å‰çŸ©å½¢æ•°: <span id="rectCount">0</span></p>
                    <p>å½“å‰å›¾æ ‡æ•°: <span id="iconCount">0</span></p>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <h3>ğŸ“± å±å¹•è®¾ç½®</h3>
                    <div class="form-group">
                        <label>å±å¹•å®½åº¦ (px)</label>
                        <input type="number" id="screenWidth" value="416" min="100" max="800">
                    </div>
                    <div class="form-group">
                        <label>å±å¹•é«˜åº¦ (px)</label>
                        <input type="number" id="screenHeight" value="240" min="100" max="600">
                    </div>
                    <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="showGrid" checked onchange="toggleGrid()" style="width: auto;">
                        <label for="showGrid" style="margin: 0; cursor: pointer;">æ˜¾ç¤ºç½‘æ ¼</label>
                    </div>
                    <button class="btn" onclick="updateScreenSize()">æ›´æ–°å±å¹•å°ºå¯¸</button>
                </div>

                <div class="control-group">
                    <h3>ğŸ“ çŸ©å½¢æ“ä½œ</h3>
                    <div class="rect-info" id="selectedRectInfo">
                        æœªé€‰ä¸­ä»»ä½•çŸ©å½¢
                    </div>
                    <div class="form-group">
                        <label>çŸ©å½¢å®½åº¦ (px)</label>
                        <input type="number" id="rectWidth" value="138" min="10" max="416">
                    </div>
                    <div class="form-group">
                        <label>çŸ©å½¢é«˜åº¦ (px)</label>
                        <input type="number" id="rectHeight" value="100" min="10" max="240">
                    </div>
                    <button class="btn" onclick="addRectangle()">æ·»åŠ æ–°çŸ©å½¢</button>
                    <button class="btn btn-warning" onclick="removeSelectedRect()">åˆ é™¤é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn btn-danger" onclick="clearAllRectangles()">æ¸…ç©ºæ‰€æœ‰çŸ©å½¢</button>
                </div>

                <div class="control-group">
                    <h3>ğŸ¯ å›¾æ ‡æ“ä½œ</h3>
                    <div class="form-group">
                        <label>å›¾æ ‡ç´¢å¼• (0-20)</label>
                        <select id="iconIndex"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="0">0 - ICON_1 (62x64)</option>
                            <option value="1">1 - ICON_2 (64x64)</option>
                            <option value="2">2 - ICON_3 (86x64)</option>
                            <option value="3">3 - ICON_4 (71x56)</option>
                            <option value="4">4 - ICON_5 (76x56)</option>
                            <option value="5">5 - ICON_6 (94x64)</option>
                            <option value="6">6 - ï¼ˆæœªä½¿ç”¨ï¼‰</option>
                            <option value="7">7 - é’‰å­ (15x16)</option>
                            <option value="8">8 - é” (32x32)</option>
                            <option value="9">9 - å–‡å­ (16x16)</option>
                            <option value="10">10 - ç”µæ±  (36x24)</option>
                            <option value="11">11 - WiFiæ–­å¼€ (32x32)</option>
                            <option value="12">12 - WiFiè¿æ¥ (32x32)</option>
                            <option value="13">13 - ä¸‹åˆ’çº¿ (60x16)</option>
                            <option value="14">14 - æç¤ºæ¡† (320x36)</option>
                            <option value="15">15 - WiFi/ç”µæ±  (80x36)</option>
                            <option value="16">16 - å•è¯æ¡† (336x48)</option>
                            <option value="17">17 - ç¿»è¯‘æ ‡é¢˜ (416x24)</option>
                            <option value="18">18 - åˆ†éš”çº¿ (416x16)</option>
                            <option value="19">19 - å–‡å­ (80x16)</option>
                            <option value="20">20 - éŸ³æ ‡æ¡† (80x32)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹Xä½ç½® (0.0-1.0)</label>
                        <input type="number" id="iconRelX" value="0.5" min="0" max="1" step="0.01">
                        <small style="color: #666;">0.5 = ä¸­å¿ƒï¼Œ0.0 = å·¦ä¸Š</small>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹Yä½ç½® (0.0-1.0)</label>
                        <input type="number" id="iconRelY" value="0.5" min="0" max="1" step="0.01">
                        <small style="color: #666;">0.5 = ä¸­å¿ƒï¼Œ0.0 = å·¦ä¸Š</small>
                    </div>
                    <button class="btn" onclick="addIconToSelectedRect()">æ·»åŠ å›¾æ ‡åˆ°é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn" onclick="updateSelectedIconPosition()">æ›´æ–°é€‰ä¸­å›¾æ ‡ä½ç½®</button>
                    <button class="btn btn-warning" onclick="removeSelectedIcon()">åˆ é™¤é€‰ä¸­å›¾æ ‡</button>
                    <button class="btn" onclick="autoArrangeIcons()">è‡ªåŠ¨æ’åˆ—å›¾æ ‡</button>
                    <div
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px;">
                        <strong>æç¤ºï¼š</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>ç›¸å¯¹ä½ç½®åŸºäºå›¾æ ‡<strong>ä¸­å¿ƒç‚¹</strong>ï¼š(0.5, 0.5)è¡¨ç¤ºå›¾æ ‡ä¸­å¿ƒåœ¨çŸ©å½¢ä¸­å¿ƒ</li>
                            <li>ç‚¹å‡»å›¾æ ‡å¯æŸ¥çœ‹å½“å‰ä½ç½®å¹¶æ‰‹åŠ¨è°ƒæ•´</li>
                            <li>æ‹–åŠ¨å›¾æ ‡å¯å®æ—¶è°ƒæ•´ä½ç½®ï¼Œç›¸å¯¹åæ ‡è‡ªåŠ¨æ›´æ–°</li>
                            <li>å…±21ä¸ªå›¾æ ‡å¯ç”¨ï¼š0-20</li>
                        </ul>
                    </div>
                </div>

                <div class="control-group" id="textManagementGroup">
                    <h3>ğŸ“ æ–‡æœ¬ç®¡ç†</h3>
                    <div class="form-group">
                        <label>æ–‡æœ¬ç±»å‹</label>
                        <select id="textType"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="3">å•è¯ (WORD)</option>
                            <option value="4">éŸ³æ ‡ (PHONETIC)</option>
                            <option value="5">é‡Šä¹‰ (DEFINITION)</option>
                            <option value="6">ç¿»è¯‘ (TRANSLATION)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>æ–‡æœ¬å†…å®¹</label>
                        <input type="text" id="textContent" placeholder="è¾“å…¥è¦æ˜¾ç¤ºçš„å†…å®¹"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹ä½ç½® X (0.0-1.0)</label>
                        <input type="number" id="textRelX" min="0" max="1" step="0.01" value="0.5"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                        <small style="color: #666;">0.0 = å·¦è¾¹ï¼Œ0.5 = ä¸­å¿ƒï¼Œ1.0 = å³è¾¹</small>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹ä½ç½® Y (0.0-1.0)</label>
                        <input type="number" id="textRelY" min="0" max="1" step="0.01" value="0.5"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                        <small style="color: #666;">0.0 = é¡¶éƒ¨ï¼Œ0.5 = ä¸­å¿ƒï¼Œ1.0 = åº•éƒ¨</small>
                    </div>
                    <div class="form-group">
                        <label>å­—ä½“å¤§å°</label>
                        <input type="number" id="textFontSize" min="12" max="48" value="16"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                    </div>
                    <div class="form-group">
                        <label>æ°´å¹³å¯¹é½</label>
                        <select id="textHAlign"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="0">å·¦å¯¹é½ (LEFT)</option>
                            <option value="1">å±…ä¸­ (CENTER)</option>
                            <option value="2">å³å¯¹é½ (RIGHT)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>å‚ç›´å¯¹é½</label>
                        <select id="textVAlign"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="0">é¡¶éƒ¨ (TOP)</option>
                            <option value="1">ä¸­é—´ (MIDDLE)</option>
                            <option value="2">åº•éƒ¨ (BOTTOM)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="addTextToSelectedRect()">æ·»åŠ æ–‡æœ¬åˆ°é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn" onclick="updateSelectedTextPosition()">æ›´æ–°é€‰ä¸­æ–‡æœ¬ä½ç½®</button>
                    <button class="btn btn-warning" onclick="removeSelectedText()">åˆ é™¤é€‰ä¸­æ–‡æœ¬</button>
                    <button class="btn" onclick="autoArrangeTexts()">è‡ªåŠ¨æ’åˆ—æ–‡æœ¬</button>

                    <div
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px;">
                        <strong>æç¤ºï¼š</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li><strong>å•è¯æ¨¡å¼</strong>ï¼šä¸»è¦ç”¨äºä¸»ç•Œé¢å¸ƒå±€çš„æ–‡æœ¬æ ‡è®°</li>
                            <li><strong>è¯æ±‡æ¨¡å¼</strong>ï¼šç”¨äºå®é™…å•è¯/éŸ³æ ‡/é‡Šä¹‰/ç¿»è¯‘å†…å®¹</li>
                            <li>æ–‡æœ¬å†…å®¹ç”¨äºé¢„è§ˆæ•ˆæœï¼Œå®é™…æ˜¾ç¤ºå†…å®¹ç”±è®¾å¤‡æ•°æ®å†³å®š</li>
                            <li>æ”¯æŒä¸­è‹±æ–‡æ··åˆæ–‡æœ¬æ˜¾ç¤º</li>
                        </ul>
                    </div>
                </div>
                <div class="control-group" id="focusConfigGroup" style="display: none;">
                    <h3>ğŸ¯ æ¯æ•°ç»„çŸ©å½¢é…ç½®</h3>
                    <div
                        style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 13px;">
                        <strong>âš ï¸ é‡è¦è¯´æ˜ï¼š</strong><br>
                        è¿™é‡Œåªé…ç½®<strong>æ¯æ•°ç»„çŸ©å½¢</strong>ï¼ˆç¬¬ä¸€å±‚å¯¼èˆªï¼‰ã€‚<br>
                        â–ª åœ¨æ¯æ•°ç»„æ¨¡å¼ä¸‹ï¼ŒæŒ‰é”®1/3åªåœ¨è¿™äº›çŸ©å½¢é—´å¾ªç¯<br>
                        â–ª æŒ‰é”®2ç¡®è®¤åè¿›å…¥è¯¥çŸ©å½¢çš„å­æ•°ç»„ï¼ˆéœ€åœ¨ä¸‹æ–¹é…ç½®å­æ•°ç»„ï¼‰<br>
                        â–ª <strong style="color: red;">è¯·å‹¿å‹¾é€‰å­æ•°ç»„çŸ©å½¢ï¼Œå¦åˆ™ä¼šæ··ä¹±ï¼</strong>
                    </div>

                    <div id="focusableRectsCheckboxes"
                        style="max-height: 200px; overflow-y: auto; padding: 10px; background: white; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;">
                        <!-- å¤é€‰æ¡†å°†åŠ¨æ€ç”Ÿæˆ -->
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn" onclick="selectAllFocusableRects()" style="flex: 1;">å…¨é€‰</button>
                        <button class="btn" onclick="deselectAllFocusableRects()" style="flex: 1;">å…¨ä¸é€‰</button>
                    </div>

                    <button class="btn btn-success" onclick="saveFocusConfig()">ä¿å­˜ç„¦ç‚¹é…ç½®åˆ°è®¾å¤‡</button>
                    <button class="btn" onclick="loadFocusConfig()">ä»è®¾å¤‡åŠ è½½ç„¦ç‚¹é…ç½®</button>

                    <div id="focusConfigStatus"
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px; display: none;">
                        <strong>å½“å‰ç„¦ç‚¹é…ç½®ï¼š</strong>
                        <div id="focusConfigInfo"></div>
                    </div>

                    <!-- å­æ•°ç»„é…ç½®åŒºåŸŸ -->
                    <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 5px; border: 2px solid #2196F3;">
                        <h4 style="margin: 0 0 10px 0; color: #1976D2;">ï¿½ å­æ•°ç»„çŸ©å½¢é…ç½®ï¼ˆç¬¬äºŒå±‚å¯¼èˆªï¼‰</h4>
                        <div style="margin-bottom: 10px; padding: 8px; background: #fff3cd; border-radius: 3px; font-size: 12px;">
                            <strong>å¯¼èˆªé€»è¾‘ï¼š</strong><br>
                            1. åœ¨æ¯æ•°ç»„æ¨¡å¼ä¸‹ï¼Œé€‰æ‹©ä¸€ä¸ªæ¯çŸ©å½¢ï¼ˆå¦‚çŸ©å½¢0ï¼‰<br>
                            2. æŒ‰<strong>ç¡®è®¤é”®</strong>è¿›å…¥è¯¥çŸ©å½¢çš„å­æ•°ç»„ï¼ˆå¦‚çŸ©å½¢1,3,5ï¼‰<br>
                            3. åœ¨å­æ•°ç»„ä¸­ï¼ŒæŒ‰é”®1/3<strong>åªåœ¨å­çŸ©å½¢é—´å¾ªç¯</strong><br>
                            4. å†æŒ‰<strong>ç¡®è®¤é”®</strong>é€€å›æ¯æ•°ç»„ï¼Œç»§ç»­åœ¨æ¯çŸ©å½¢é—´å¾ªç¯<br>
                            <strong style="color: #d32f2f;">âš ï¸ å­çŸ©å½¢ä¸è¦åœ¨ä¸Šæ–¹æ¯æ•°ç»„ä¸­å‹¾é€‰ï¼</strong>
                        </div>

                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 14px; font-weight: bold; color: #333;">é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ï¼š</label>
                            <select id="subArrayParentSelect" onchange="updateSubArrayConfig()" 
                                style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 14px;">
                                <option value="">-- è¯·é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ --</option>
                            </select>
                        </div>

                        <div id="subArrayCheckboxes"
                            style="max-height: 150px; overflow-y: auto; padding: 10px; background: white; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; display: none;">
                            <!-- å­æ•°ç»„å¤é€‰æ¡†å°†åŠ¨æ€ç”Ÿæˆ -->
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="clearSubArray()" style="flex: 1; background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);">æ¸…ç©ºå½“å‰å­æ•°ç»„</button>
                        </div>

                        <button class="btn btn-success" onclick="saveSubArrayConfig()" style="margin-top: 10px;">ä¿å­˜å­æ•°ç»„é…ç½®åˆ°è®¾å¤‡</button>

                        <div id="subArrayConfigStatus"
                            style="margin-top: 10px; padding: 10px; background: #fff9c4; border-radius: 5px; font-size: 12px; display: none;">
                            <strong>å½“å‰å­æ•°ç»„é…ç½®ï¼š</strong>
                            <div id="subArrayConfigInfo"></div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <h3>ğŸ’¾ å¸ƒå±€ç®¡ç†</h3>
                    <div class="status-message" id="statusMessage"></div>
                    <button class="btn" onclick="testLayoutData()">æµ‹è¯•æ•°æ®æ ¼å¼</button>
                    <button class="btn btn-success" onclick="getCurrentLayout()">è·å–å½“å‰å¸ƒå±€</button>
                    <button class="btn btn-success" onclick="applyToDevice()">åº”ç”¨åˆ°è®¾å¤‡</button>
                    <button class="btn" onclick="saveLayoutToFile()">ä¿å­˜åˆ°æ–‡ä»¶</button>
                    <button class="btn" onclick="loadLayoutFromFile()">ä»æ–‡ä»¶åŠ è½½</button>
                    <button class="btn btn-warning" onclick="resetToDefault()">é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentScreenMode = 'main'; // 'main' æˆ– 'vocab'
        let currentLayout = {
            screen: { width: 416, height: 240 },
            rectangles: [],
            status_rect_index: 0
        };

        // è·å–å½“å‰APIç«¯ç‚¹
        function getApiEndpoints() {
            if (currentScreenMode === 'vocab') {
                return {
                    get: '/getvocablayout',
                    set: '/setvocablayout'
                };
            } else {
                return {
                    get: '/getlayout',
                    set: '/setlayout'
                };
            }
        }

        // åˆ‡æ¢ç•Œé¢æ¨¡å¼
        function switchScreenMode() {
            const select = document.getElementById('screenMode');
            currentScreenMode = select.value;
            console.log('åˆ‡æ¢åˆ°' + (currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢') + 'ç¼–è¾‘æ¨¡å¼');

            // æ§åˆ¶æ–‡æœ¬ç®¡ç†é¢æ¿çš„æ˜¾ç¤º
            const textManagementGroup = document.getElementById('textManagementGroup');
            if (textManagementGroup) {
                if (currentScreenMode === 'vocab') {
                    textManagementGroup.style.display = 'block';
                } else {
                    textManagementGroup.style.display = 'none';
                }
            }

            // æ§åˆ¶ç„¦ç‚¹é…ç½®é¢æ¿çš„æ˜¾ç¤ºï¼ˆä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºï¼‰
            const focusConfigGroup = document.getElementById('focusConfigGroup');
            if (focusConfigGroup) {
                // ä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºç„¦ç‚¹é…ç½®
                focusConfigGroup.style.display = 'block';
            }

            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            document.getElementById('loadingOverlay').style.display = 'flex';

            // é‡æ–°åŠ è½½å¸ƒå±€å’Œç„¦ç‚¹é…ç½®
            setTimeout(() => {
                getCurrentLayoutFromDevice();
                // åŠ è½½å¯¹åº”ç•Œé¢çš„ç„¦ç‚¹é…ç½®
                loadFocusConfig();
                // åŠ è½½å¯¹åº”ç•Œé¢çš„å­æ•°ç»„é…ç½®
                loadSubArrayConfig();
            }, 300);
        }

        let selectedRectIndex = -1;
        let selectedIconIndex = -1;
        let draggedIconElement = null;
        let currentDropTargetIndex = -1; // å½“å‰æ‹–æ‹½ç›®æ ‡çŸ©å½¢ç´¢å¼•


        // åˆå§‹åŒ–
        function init() {
            // åˆå§‹åŒ–æ–‡æœ¬ç®¡ç†é¢æ¿å¯è§æ€§
            const textManagementGroup = document.getElementById('textManagementGroup');
            if (textManagementGroup) {
                textManagementGroup.style.display = currentScreenMode === 'vocab' ? 'block' : 'none';
            }

            // åˆå§‹åŒ–ç„¦ç‚¹é…ç½®é¢æ¿å¯è§æ€§ï¼ˆä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºï¼‰
            const focusConfigGroup = document.getElementById('focusConfigGroup');
            if (focusConfigGroup) {
                // ä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºç„¦ç‚¹é…ç½®
                focusConfigGroup.style.display = 'block';
            }

            drawGridLines();
            // è®¾ç½®é»˜è®¤å¸ƒå±€ä½†ä¸ç«‹å³æ¸²æŸ“
            //setDefaultLayout();
            // ç„¶åå°è¯•ä»è®¾å¤‡è·å–å¸ƒå±€å’Œç„¦ç‚¹é…ç½®
            getCurrentLayoutFromDevice();
            // åˆå§‹åŒ–æ—¶åŠ è½½ç„¦ç‚¹é…ç½®å’Œå­æ•°ç»„é…ç½®
            setTimeout(() => {
                loadFocusConfig();
                loadSubArrayConfig();
            }, 500);
        }

        // æ·»åŠ ä¸€ä¸ªè®¾ç½®é»˜è®¤å¸ƒå±€ä½†ä¸æ¸²æŸ“çš„å‡½æ•°
        function setDefaultLayout() {
            currentLayout = {
                screen: { width: 416, height: 240 },
                rectangles: [],
                status_rect_index: 0
            };

            // æ·»åŠ ä¸»ç•Œé¢é»˜è®¤çŸ©å½¢ï¼ˆ7ä¸ªæ¡†æ¶ï¼‰
            const defaultRects = [
                // çŸ©å½¢0ï¼šçŠ¶æ€æ 
                { x: 0, y: 0, width: 416, height: 36, icon_count: 0, icons: [] },

                // çŸ©å½¢1ï¼šå·¦ä¸ŠåŒºåŸŸ - 3ä¸ªå›¾æ ‡
                {
                    x: 0, y: 40, width: 138, height: 100, icon_count: 3, icons: [
                        { icon_index: 0, rel_x: 0.2, rel_y: 0.2, original_width: 62, original_height: 64 },
                        { icon_index: 1, rel_x: 0.6, rel_y: 0.2, original_width: 64, original_height: 64 },
                        { icon_index: 2, rel_x: 0.4, rel_y: 0.6, original_width: 86, original_height: 64 }
                    ]
                },

                // çŸ©å½¢2ï¼šä¸­ä¸ŠåŒºåŸŸ - 2ä¸ªå›¾æ ‡
                {
                    x: 142, y: 40, width: 132, height: 100, icon_count: 2, icons: [
                        { icon_index: 3, rel_x: 0.3, rel_y: 0.3, original_width: 71, original_height: 56 },
                        { icon_index: 4, rel_x: 0.6, rel_y: 0.5, original_width: 76, original_height: 56 }
                    ]
                },

                // çŸ©å½¢3ï¼šå³ä¸ŠåŒºåŸŸ - 2ä¸ªå›¾æ ‡
                {
                    x: 278, y: 40, width: 138, height: 100, icon_count: 2, icons: [
                        { icon_index: 5, rel_x: 0.2, rel_y: 0.4, original_width: 94, original_height: 64 },
                        { icon_index: 0, rel_x: 0.6, rel_y: 0.4, original_width: 62, original_height: 64 }
                    ]
                },

                // çŸ©å½¢4ï¼šå·¦ä¸‹åŒºåŸŸ - 4ä¸ªå›¾æ ‡
                {
                    x: 0, y: 144, width: 138, height: 96, icon_count: 4, icons: [
                        { icon_index: 1, rel_x: 0.15, rel_y: 0.2, original_width: 64, original_height: 64 },
                        { icon_index: 2, rel_x: 0.35, rel_y: 0.2, original_width: 86, original_height: 64 },
                        { icon_index: 3, rel_x: 0.6, rel_y: 0.2, original_width: 71, original_height: 56 },
                        { icon_index: 4, rel_x: 0.4, rel_y: 0.6, original_width: 76, original_height: 56 }
                    ]
                },

                // çŸ©å½¢5ï¼šä¸­ä¸‹åŒºåŸŸ - 3ä¸ªå›¾æ ‡
                {
                    x: 142, y: 144, width: 132, height: 96, icon_count: 3, icons: [
                        { icon_index: 5, rel_x: 0.2, rel_y: 0.2, original_width: 94, original_height: 64 },
                        { icon_index: 0, rel_x: 0.3, rel_y: 0.6, original_width: 62, original_height: 64 },
                        { icon_index: 1, rel_x: 0.6, rel_y: 0.6, original_width: 64, original_height: 64 }
                    ]
                },

                // çŸ©å½¢6ï¼šå³ä¸‹åŒºåŸŸ - 1ä¸ªå›¾æ ‡
                {
                    x: 278, y: 144, width: 138, height: 96, icon_count: 1, icons: [
                        { icon_index: 2, rel_x: 0.5, rel_y: 0.5, original_width: 86, original_height: 64 }
                    ]
                }
            ];

            defaultRects.forEach((rect, index) => {
                currentLayout.rectangles.push({
                    ...rect,
                    original_x: rect.x,
                    original_y: rect.y,
                    original_width: rect.width,
                    original_height: rect.height,
                    is_status_bar: index === 0
                });
            });
        }

        // ç»˜åˆ¶ç½‘æ ¼çº¿
        function drawGridLines() {
            const gridLines = document.getElementById('gridLines');
            if (!gridLines) {
                console.warn('gridLines å…ƒç´ ä¸å­˜åœ¨');
                return;
            }

            // æ¸…ç©ºä¹‹å‰çš„ç½‘æ ¼çº¿
            gridLines.innerHTML = '';

            const gridSize = 20;
            const screenWidth = currentLayout.screen.width || 416;
            const screenHeight = currentLayout.screen.height || 240;

            // å‚ç›´çº¿
            for (let x = gridSize; x < screenWidth; x += gridSize) {
                const line = document.createElement('div');
                line.className = 'grid-line vertical';
                line.style.position = 'absolute';
                line.style.left = x + 'px';
                line.style.top = '0';
                line.style.width = '1px';
                line.style.height = '100%';
                line.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                line.style.pointerEvents = 'none';
                gridLines.appendChild(line);
            }

            // æ°´å¹³çº¿
            for (let y = gridSize; y < screenHeight; y += gridSize) {
                const line = document.createElement('div');
                line.className = 'grid-line horizontal';
                line.style.position = 'absolute';
                line.style.left = '0';
                line.style.top = y + 'px';
                line.style.width = '100%';
                line.style.height = '1px';
                line.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                line.style.pointerEvents = 'none';
                gridLines.appendChild(line);
            }
        }

        // ä»è®¾å¤‡è·å–å½“å‰å¸ƒå±€
        async function getCurrentLayoutFromDevice() {
            console.log('å¼€å§‹è·å–å¸ƒå±€æ•°æ®...');
            const endpoints = getApiEndpoints();
            const screenName = currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢';
            showLoading('æ­£åœ¨è·å–' + screenName + 'å¸ƒå±€...');

            try {
                const response = await fetch(endpoints.get);
                console.log('HTTPå“åº”çŠ¶æ€:', response.status, response.statusText);

                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                console.log('è·å–åˆ°JSONæ•°æ®:', data);

                // æ•°æ®éªŒè¯
                if (!data) {
                    throw new Error('æœåŠ¡å™¨è¿”å›ç©ºæ•°æ®');
                }

                // ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
                if (!data.rectangles || !Array.isArray(data.rectangles)) {
                    console.warn('rectangles ä¸æ˜¯æ•°ç»„æˆ–ä¸å­˜åœ¨ï¼Œå°è¯•ä¿®å¤...');
                    data.rectangles = [];
                }

                // å­˜å‚¨ä»è®¾å¤‡è·å–çš„å›¾æ ‡å°ºå¯¸
                if (data.rectangles && Array.isArray(data.rectangles)) {
                    data.rectangles.forEach((rect, rectIndex) => {
                        if (rect.icons && Array.isArray(rect.icons)) {
                            rect.icons.forEach((icon, iconIndex) => {
                                // è®°å½•å›¾æ ‡å°ºå¯¸
                                console.log(`çŸ©å½¢ ${rectIndex} å›¾æ ‡ ${iconIndex}: å°ºå¯¸=${icon.display_width || 30}x${icon.display_height || 30}`);
                            });
                        }
                        // æ·»åŠ æ–‡æœ¬æ•°æ®è°ƒè¯•
                        if (rect.texts && Array.isArray(rect.texts)) {
                            console.log(`çŸ©å½¢ ${rectIndex} æ–‡æœ¬æ•°æ®:`, rect.texts);
                        } else {
                            console.log(`çŸ©å½¢ ${rectIndex} æ²¡æœ‰æ–‡æœ¬æ•°æ®`);
                        }
                    });
                }

                // ä¿å­˜å¯ç”¨åŠ¨ä½œåˆ°å…¨å±€ï¼Œä¾›UIä½¿ç”¨
                window.availableActions = data.available_actions || [];
                // è°ƒç”¨ renderLayout å¹¶ä¼ é€’æ•°æ®
                renderLayout(data);
                return data;

            } catch (error) {
                console.error('è·å–å¸ƒå±€å¤±è´¥:', error);
                showStatus('è·å–å¸ƒå±€å¤±è´¥: ' + error.message, 'error');
                return null;
            } finally {
                hideLoading();
            }
        }

        function renderLayout(layout) {
            console.log('renderLayout æ¥æ”¶åˆ°æ•°æ®:', layout);

            try {
                if (!layout) {
                    throw new Error('å¸ƒå±€æ•°æ®ä¸ºç©º');
                }

                const container = document.getElementById('screenContainer');
                if (!container) {
                    throw new Error('screenContainer å…ƒç´ ä¸å­˜åœ¨');
                }

                // æ¸…ç©ºå®¹å™¨å†…å®¹ï¼ˆé™¤äº†ç½‘æ ¼çº¿å’Œå¯¹é½è¾…åŠ©çº¿ï¼‰
                const children = Array.from(container.children);
                children.forEach(child => {
                    if (child.id !== 'gridLines' && child.id !== 'alignmentGuides') {
                        container.removeChild(child);
                    }
                });

                // éªŒè¯å±å¹•å°ºå¯¸
                const screenWidth = layout.screen_width || 416;
                const screenHeight = layout.screen_height || 240;

                console.log(`å±å¹•å°ºå¯¸: ${screenWidth}x${screenHeight}`);

                // æ›´æ–°å±å¹•å®¹å™¨çš„å°ºå¯¸
                container.style.width = screenWidth + 'px';
                container.style.height = screenHeight + 'px';

                // æ›´æ–°æ˜¾ç¤ºçš„å±å¹•å°ºå¯¸
                const screenSizeSpan = document.getElementById('screenSize');
                if (screenSizeSpan) {
                    screenSizeSpan.textContent = `${screenWidth}Ã—${screenHeight}`;
                }

                // æ›´æ–°å±å¹•è®¾ç½®è¾“å…¥æ¡†çš„å€¼
                const screenWidthInput = document.getElementById('screenWidth');
                const screenHeightInput = document.getElementById('screenHeight');
                if (screenWidthInput) screenWidthInput.value = screenWidth;
                if (screenHeightInput) screenHeightInput.value = screenHeight;

                // æ›´æ–° currentLayout çš„å±å¹•å°ºå¯¸
                currentLayout.screen.width = screenWidth;
                currentLayout.screen.height = screenHeight;

                // æ›´æ–° currentLayout çš„çŸ©å½¢æ•°æ®
                if (layout.rectangles && Array.isArray(layout.rectangles)) {
                    currentLayout.rectangles = layout.rectangles.map((rect, index) => {
                        if (!rect) return null;

                        const newRect = {
                            x: rect.x || 0,
                            y: rect.y || 0,
                            width: rect.width || 0,
                            height: rect.height || 0,
                            original_x: rect.original_x || rect.x || 0,
                            original_y: rect.original_y || rect.y || 0,
                            original_width: rect.original_width || rect.width || 0,
                            original_height: rect.original_height || rect.height || 0,
                            icon_count: rect.icon_count || (rect.icons ? rect.icons.length : 0),
                            text_count: rect.text_count || (rect.texts ? rect.texts.length : 0),
                            icons: rect.icons || [],
                            texts: rect.texts || [], // æ·»åŠ æ–‡æœ¬æ•°ç»„æ”¯æŒ
                            is_status_bar: rect.is_status_bar || index === 0
                            ,
                            // ä¿ç•™ç„¦ç‚¹æ¨¡å¼ï¼ˆå¦‚æœæœåŠ¡å™¨è¿”å›ï¼‰
                            focus_mode: (rect.focus_mode !== undefined) ? rect.focus_mode : 0,
                            // ä¿ç•™å½“å‰ç»‘å®šçš„åŠ¨ä½œIDï¼ˆå¦‚æœæœ‰ï¼‰
                            on_confirm_action: rect.on_confirm_action || ''
                        };

                        // ç¡®ä¿æ¯ä¸ªå›¾æ ‡éƒ½æœ‰å®Œæ•´çš„æ•°æ®
                        if (newRect.icons && Array.isArray(newRect.icons)) {
                            newRect.icons.forEach((icon, iconIndex) => {
                                if (icon) {
                                    // ç¡®ä¿æœ‰æ˜¾ç¤ºä½ç½®å’Œå°ºå¯¸
                                    icon.display_x = icon.display_x || newRect.x + (newRect.width - (icon.display_width || 30)) * (icon.rel_x || 0.5);
                                    icon.display_y = icon.display_y || newRect.y + (newRect.height - (icon.display_height || 30)) * (icon.rel_y || 0.5);
                                    icon.display_width = icon.display_width || 30;
                                    icon.display_height = icon.display_height || 30;

                                    console.log(`çŸ©å½¢ ${index} å›¾æ ‡ ${iconIndex}: ä½ç½®(${icon.display_x},${icon.display_y}), å°ºå¯¸(${icon.display_width}x${icon.display_height})`);
                                }
                            });
                        }

                        return newRect;
                    }).filter(rect => rect !== null);
                } else {
                    currentLayout.rectangles = [];
                }

                // æ›´æ–°çŸ©å½¢å’Œå›¾æ ‡è®¡æ•°
                const rectCountSpan = document.getElementById('rectCount');
                const iconCountSpan = document.getElementById('iconCount');
                if (rectCountSpan) {
                    rectCountSpan.textContent = currentLayout.rectangles.length;
                }
                if (iconCountSpan) {
                    const totalIcons = currentLayout.rectangles.reduce((sum, rect) => sum + (rect.icons ? rect.icons.length : 0), 0);
                    iconCountSpan.textContent = totalIcons;
                }

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                drawGridLines();

                // æ¸²æŸ“çŸ©å½¢
                if (currentLayout.rectangles && Array.isArray(currentLayout.rectangles)) {
                    console.log(`æ‰¾åˆ° ${currentLayout.rectangles.length} ä¸ªçŸ©å½¢`);

                    currentLayout.rectangles.forEach((rect, index) => {
                        try {
                            // éªŒè¯çŸ©å½¢æ•°æ®
                            if (!rect) {
                                console.warn(`çŸ©å½¢ ${index} æ•°æ®ä¸ºç©º`);
                                return;
                            }

                            // æ£€æŸ¥å¿…éœ€çš„å±æ€§
                            if (rect.x === undefined || rect.y === undefined || rect.width === undefined || rect.height === undefined) {
                                console.error(`çŸ©å½¢ ${index} ç¼ºå°‘å¿…éœ€å±æ€§:`, rect);
                                return;
                            }

                            console.log(`æ¸²æŸ“çŸ©å½¢ ${index}:`, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: rect.height,
                                icon_count: rect.icon_count
                            });

                            // åˆ›å»ºçŸ©å½¢å…ƒç´ 
                            const rectDiv = document.createElement('div');
                            rectDiv.className = 'rect';
                            rectDiv.dataset.index = index;
                            rectDiv.style.position = 'absolute';
                            rectDiv.style.left = rect.x + 'px';
                            rectDiv.style.top = rect.y + 'px';
                            rectDiv.style.width = rect.width + 'px';
                            rectDiv.style.height = rect.height + 'px';
                            rectDiv.style.border = '2px solid #4CAF50';
                            rectDiv.style.backgroundColor = rect.is_status_bar ?
                                'rgba(0, 100, 200, 0.2)' : 'rgba(76, 175, 80, 0.1)';
                            rectDiv.style.boxSizing = 'border-box';
                            rectDiv.style.cursor = 'move';

                            // ç‚¹å‡»äº‹ä»¶å°†ç”± makeDraggable å¤„ç†

                            // ä½¿çŸ©å½¢å¯æ‹–æ‹½
                            makeDraggable(rectDiv, index, 'rect');

                            // æ·»åŠ çŸ©å½¢ç¼–å·æ ‡ç­¾
                            const label = document.createElement('div');
                            label.textContent = `${index}`;
                            label.style.position = 'absolute';
                            label.style.top = '2px';
                            label.style.left = '2px';
                            label.style.fontSize = '10px';
                            label.style.fontWeight = 'bold';
                            label.style.color = rect.is_status_bar ? '#0066cc' : '#4CAF50';
                            rectDiv.appendChild(label);

                            // æ·»åŠ è°ƒæ•´å¤§å°çš„æ‰‹æŸ„
                            const handleSE = document.createElement('div');
                            handleSE.className = 'resize-handle se';
                            rectDiv.appendChild(handleSE);
                            makeResizable(rectDiv, handleSE, index, 'se');

                            const handleE = document.createElement('div');
                            handleE.className = 'resize-handle e';
                            rectDiv.appendChild(handleE);
                            makeResizable(rectDiv, handleE, index, 'e');

                            const handleS = document.createElement('div');
                            handleS.className = 'resize-handle s';
                            rectDiv.appendChild(handleS);
                            makeResizable(rectDiv, handleS, index, 's');

                            container.appendChild(rectDiv);

                            // æ¸²æŸ“å›¾æ ‡ - æ”¹ä¸ºä½¿ç”¨ç©ºå¿ƒçŸ©å½¢
                            if (rect.icons && Array.isArray(rect.icons)) {
                                rect.icons.forEach((icon, iconIndex) => {
                                    try {
                                        if (!icon) {
                                            console.warn(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} æ•°æ®ä¸ºç©º`);
                                            return;
                                        }

                                        // ä½¿ç”¨åŸå§‹å°ºå¯¸ï¼ˆæ¥è‡ªå›¾æ ‡å®šä¹‰ï¼‰
                                        const iconWidth = icon.original_width || 30;
                                        const iconHeight = icon.original_height || 30;

                                        // ä½¿ç”¨ç›¸å¯¹åæ ‡è®¡ç®—æ˜¾ç¤ºä½ç½®
                                        const relX = icon.rel_x !== undefined ? icon.rel_x : 0.5;
                                        const relY = icon.rel_y !== undefined ? icon.rel_y : 0.5;

                                        // è®¡ç®—ç»å¯¹ä½ç½®ï¼šçŸ©å½¢å·¦ä¸Šè§’ + ç›¸å¯¹ä½ç½® * çŸ©å½¢å°ºå¯¸ï¼ˆå›¾æ ‡å·¦ä¸Šè§’ä½ç½®ï¼‰
                                        const iconX = rect.x + relX * rect.width;
                                        const iconY = rect.y + relY * rect.height;

                                        console.log(`æ¸²æŸ“å›¾æ ‡ ${iconIndex} (ç´¢å¼•=${icon.icon_index}): ç›¸å¯¹(${relX.toFixed(2)},${relY.toFixed(2)}), ç»å¯¹ä½ç½®(${iconX.toFixed(1)},${iconY.toFixed(1)}), å°ºå¯¸(${iconWidth}x${iconHeight})`);

                                        // åˆ›å»ºç©ºå¿ƒçŸ©å½¢å›¾æ ‡
                                        const iconDiv = document.createElement('div');
                                        iconDiv.className = 'icon-hollow-rect';
                                        iconDiv.dataset.rectIndex = index;
                                        iconDiv.dataset.iconIndex = iconIndex;
                                        iconDiv.style.position = 'absolute';
                                        iconDiv.style.left = iconX + 'px';
                                        iconDiv.style.top = iconY + 'px';
                                        iconDiv.style.width = iconWidth + 'px';
                                        iconDiv.style.height = iconHeight + 'px';
                                        iconDiv.style.border = '2px solid #FF5722';
                                        iconDiv.style.borderRadius = '3px';
                                        iconDiv.style.backgroundColor = 'transparent';
                                        iconDiv.style.boxSizing = 'border-box';
                                        iconDiv.style.cursor = 'move';

                                        // ç‚¹å‡»äº‹ä»¶å°†ç”± makeDraggable å¤„ç†

                                        // æ·»åŠ å›¾æ ‡åºå·å’Œç›¸å¯¹ä½ç½®æ ‡ç­¾
                                        const iconLabel = document.createElement('div');
                                        iconLabel.className = 'icon-label';
                                        iconLabel.innerHTML = `${icon.icon_index !== undefined ? icon.icon_index : iconIndex}<br><span style="font-size:8px;">(${relX.toFixed(2)},${relY.toFixed(2)})</span>`;
                                        iconDiv.appendChild(iconLabel);

                                        // æ·»åŠ å°ºå¯¸æ ‡ç­¾
                                        const sizeLabel = document.createElement('div');
                                        sizeLabel.style.position = 'absolute';
                                        sizeLabel.style.bottom = '-15px';
                                        sizeLabel.style.left = '50%';
                                        sizeLabel.style.transform = 'translateX(-50%)';
                                        sizeLabel.style.fontSize = '8px';
                                        sizeLabel.style.color = '#666';
                                        sizeLabel.style.backgroundColor = 'rgba(255,255,255,0.8)';
                                        sizeLabel.style.padding = '1px 3px';
                                        sizeLabel.style.borderRadius = '2px';
                                        sizeLabel.style.display = 'none';
                                        sizeLabel.textContent = `${iconWidth}Ã—${iconHeight}`;
                                        iconDiv.appendChild(sizeLabel);

                                        // é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºå°ºå¯¸
                                        iconDiv.onmouseenter = () => {
                                            if (!iconDiv.classList.contains('dragging')) {
                                                iconDiv.style.borderColor = '#E91E63';
                                                iconDiv.style.backgroundColor = 'rgba(233, 30, 99, 0.1)';
                                                sizeLabel.style.display = 'block';
                                            }
                                        };
                                        iconDiv.onmouseleave = () => {
                                            if (!iconDiv.classList.contains('dragging')) {
                                                iconDiv.style.borderColor = '#FF5722';
                                                iconDiv.style.backgroundColor = 'transparent';
                                                sizeLabel.style.display = 'none';
                                            }
                                        };

                                        // ä½¿å›¾æ ‡å¯æ‹–æ‹½
                                        makeDraggable(iconDiv, iconIndex, 'icon', index);

                                        container.appendChild(iconDiv);

                                    } catch (iconError) {
                                        console.error(`æ¸²æŸ“å›¾æ ‡ ${iconIndex} å¤±è´¥:`, iconError);
                                    }
                                });
                            }

                            // æ¸²æŸ“æ–‡æœ¬å…ƒç´  - æ–°å¢åŠŸèƒ½
                            console.log(`çŸ©å½¢ ${index} çš„æ–‡æœ¬æ•°æ®:`, rect.texts, `æ–‡æœ¬æ•°é‡: ${rect.texts ? rect.texts.length : 0}`);

                            if (rect.texts && Array.isArray(rect.texts) && rect.texts.length > 0) {
                                console.log(`çŸ©å½¢ ${index} å¼€å§‹æ¸²æŸ“ ${rect.texts.length} ä¸ªæ–‡æœ¬`);
                                rect.texts.forEach((text, textIndex) => {
                                    try {
                                        if (!text) {
                                            console.warn(`çŸ©å½¢ ${index} çš„æ–‡æœ¬ ${textIndex} æ•°æ®ä¸ºç©º`);
                                            return;
                                        }

                                        // è·å–æ–‡æœ¬å‚æ•°
                                        const relX = text.rel_x !== undefined ? text.rel_x : 0.5;
                                        const relY = text.rel_y !== undefined ? text.rel_y : 0.5;
                                        const fontSize = text.font_size || 16;
                                        const content = text.content || '';
                                        const contentType = text.content_type || 0;
                                        const hAlign = text.h_align || 1; // 0=left, 1=center, 2=right
                                        const vAlign = text.v_align || 1; // 0=top, 1=middle, 2=bottom

                                        // è®¡ç®—æ–‡æœ¬ä½ç½®ï¼ˆåŸºäºå¯¹é½æ–¹å¼ï¼‰
                                        const textX = rect.x + relX * rect.width;
                                        const textY = rect.y + relY * rect.height;

                                        console.log(`æ¸²æŸ“æ–‡æœ¬ ${textIndex} (ç±»å‹=${contentType}): ç›¸å¯¹(${relX.toFixed(2)},${relY.toFixed(2)}), ç»å¯¹ä½ç½®(${textX.toFixed(1)},${textY.toFixed(1)}), å†…å®¹="${content}"`);

                                        // åˆ›å»ºæ–‡æœ¬å…ƒç´ 
                                        const textDiv = document.createElement('div');
                                        textDiv.className = 'text-element';
                                        textDiv.dataset.rectIndex = index;
                                        textDiv.dataset.textIndex = textIndex;
                                        textDiv.style.position = 'absolute';
                                        textDiv.style.left = textX + 'px';
                                        textDiv.style.top = textY + 'px';
                                        textDiv.style.fontSize = fontSize + 'px';
                                        textDiv.style.color = '#333';
                                        textDiv.style.cursor = 'move';
                                        textDiv.style.userSelect = 'none';
                                        textDiv.style.whiteSpace = 'nowrap';
                                        textDiv.style.border = '1px dashed #9C27B0';
                                        textDiv.style.padding = '2px 4px';
                                        textDiv.style.backgroundColor = 'rgba(156, 39, 176, 0.1)';
                                        textDiv.style.borderRadius = '3px';

                                        // è®¾ç½®æ–‡æœ¬å¯¹é½
                                        const alignMap = ['left', 'center', 'right'];
                                        textDiv.style.textAlign = alignMap[hAlign] || 'center';

                                        // è®¾ç½®transform based on alignment
                                        let transformX = '0%';
                                        let transformY = '0%';

                                        switch (hAlign) {
                                            case 0: transformX = '0%'; break;    // left
                                            case 1: transformX = '-50%'; break;  // center
                                            case 2: transformX = '-100%'; break; // right
                                        }

                                        switch (vAlign) {
                                            case 0: transformY = '0%'; break;    // top
                                            case 1: transformY = '-50%'; break;  // middle
                                            case 2: transformY = '-100%'; break; // bottom
                                        }

                                        textDiv.style.transform = `translate(${transformX}, ${transformY})`;

                                        // è®¾ç½®æ–‡æœ¬å†…å®¹å’Œç±»å‹æ ‡è¯†
                                        // æ˜ å°„C++ç«¯çš„æšä¸¾å€¼
                                        const typeNamesMap = {
                                            0: 'æ— å†…å®¹',
                                            1: 'çŠ¶æ€æ ',
                                            2: 'ä»…å›¾æ ‡',
                                            3: 'å•è¯',      // CONTENT_WORD = 3
                                            4: 'éŸ³æ ‡',      // CONTENT_PHONETIC = 4
                                            5: 'é‡Šä¹‰',      // CONTENT_DEFINITION = 5
                                            6: 'ç¿»è¯‘',      // CONTENT_TRANSLATION = 6
                                            7: 'åˆ†éš”çº¿',
                                            8: 'è‡ªå®šä¹‰'
                                        };
                                        const typeColorsMap = {
                                            0: '#999999',
                                            1: '#999999',
                                            2: '#999999',
                                            3: '#2196F3',   // å•è¯ - è“è‰²
                                            4: '#FF9800',   // éŸ³æ ‡ - æ©™è‰²
                                            5: '#4CAF50',   // é‡Šä¹‰ - ç»¿è‰²
                                            6: '#9C27B0',   // ç¿»è¯‘ - ç´«è‰²
                                            7: '#999999',
                                            8: '#999999'
                                        };

                                        const currentName = typeNamesMap[contentType] || 'æœªçŸ¥';
                                        const currentColor = typeColorsMap[contentType] || '#999999';

                                        textDiv.innerHTML = `
                                            <div style="font-size: 10px; color: ${currentColor}; margin-bottom: 2px;">
                                                ${currentName}[${textIndex}]
                                            </div>
                                            <div>${content || '(ç©ºæ–‡æœ¬)'}</div>
                                        `;
                                        textDiv.style.borderColor = currentColor;
                                        textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.1)`;

                                        // é¼ æ ‡æ‚¬åœæ•ˆæœ
                                        textDiv.onmouseenter = () => {
                                            if (!textDiv.classList.contains('dragging')) {
                                                textDiv.style.borderStyle = 'solid';
                                                textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.2)`;
                                            }
                                        };
                                        textDiv.onmouseleave = () => {
                                            if (!textDiv.classList.contains('dragging')) {
                                                textDiv.style.borderStyle = 'dashed';
                                                textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.1)`;
                                            }
                                        };

                                        // ç‚¹å‡»é€‰ä¸­
                                        textDiv.onclick = function (e) {
                                            e.stopPropagation();
                                            selectText(index, textIndex);
                                        };

                                        // ä½¿æ–‡æœ¬å¯æ‹–æ‹½
                                        makeDraggable(textDiv, textIndex, 'text', index);

                                        container.appendChild(textDiv);

                                    } catch (textError) {
                                        console.error(`æ¸²æŸ“æ–‡æœ¬ ${textIndex} å¤±è´¥:`, textError);
                                    }
                                });
                            }

                        } catch (rectError) {
                            console.error(`æ¸²æŸ“çŸ©å½¢ ${index} å¤±è´¥:`, rectError);
                        }
                    });
                } else {
                    console.warn('æ²¡æœ‰æ‰¾åˆ°çŸ©å½¢æ•°æ®');
                }

                // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                selectedTextIndex = -1;
                updateSelectedRectInfo();

                // æ›´æ–°ç„¦ç‚¹é…ç½®å¤é€‰æ¡†åˆ—è¡¨ï¼ˆå•è¯ç•Œé¢æ‰éœ€è¦ï¼‰
                if (currentScreenMode === 'vocab') {
                    updateFocusConfigCheckboxes();
                    updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„é€‰æ‹©å™¨
                    // å¦‚æœè¿˜æ²¡æœ‰ç„¦ç‚¹é…ç½®ï¼Œå°è¯•åŠ è½½
                    if (focusableRects.length === 0) {
                        loadFocusConfig();
                    }
                    // å¦‚æœè¿˜æ²¡æœ‰å­æ•°ç»„é…ç½®ï¼Œå°è¯•åŠ è½½
                    if (Object.keys(subArrayConfig).length === 0) {
                        loadSubArrayConfig();
                    }
                }

                console.log('å¸ƒå±€æ¸²æŸ“å®Œæˆ');

            } catch (error) {
                console.error('æ¸²æŸ“å¸ƒå±€æ—¶å‘ç”Ÿé”™è¯¯:', error);
                showStatus('æ¸²æŸ“å¸ƒå±€æ—¶å‡ºé”™: ' + error.message, 'error');
            }
        }

        // æ£€æŸ¥çŸ©å½¢ç¢°æ’
        function checkRectCollision(targetRect, ignoreIndex) {
            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                if (i === ignoreIndex) continue;
                const other = currentLayout.rectangles[i];

                // ç®€å•çš„AABBç¢°æ’æ£€æµ‹
                if (targetRect.x < other.x + other.width &&
                    targetRect.x + targetRect.width > other.x &&
                    targetRect.y < other.y + other.height &&
                    targetRect.y + targetRect.height > other.y) {
                    return true;
                }
            }
            return false;
        }

        // ä½¿å…ƒç´ å¯è°ƒæ•´å¤§å°
        function makeResizable(rectDiv, handle, index, direction) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            handle.onmousedown = function (e) {
                e.stopPropagation(); // é˜²æ­¢è§¦å‘æ‹–åŠ¨
                e.preventDefault();

                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(rectDiv.style.width);
                startHeight = parseInt(rectDiv.style.height);

                // é€‰ä¸­å½“å‰çŸ©å½¢
                selectRectangle(index);

                document.onmousemove = function (e) {
                    if (!isResizing) return;

                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;

                    let newWidth = startWidth;
                    let newHeight = startHeight;

                    if (direction === 'se' || direction === 'e') {
                        newWidth = Math.max(10, startWidth + dx);
                    }
                    if (direction === 'se' || direction === 's') {
                        newHeight = Math.max(10, startHeight + dy);
                    }

                    // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                    const screenWidth = currentLayout.screen.width;
                    const screenHeight = currentLayout.screen.height;
                    const currentX = parseInt(rectDiv.style.left);
                    const currentY = parseInt(rectDiv.style.top);

                    newWidth = Math.min(newWidth, screenWidth - currentX);
                    newHeight = Math.min(newHeight, screenHeight - currentY);

                    // ç¢°æ’æ£€æµ‹
                    const tempRect = {
                        x: currentX,
                        y: currentY,
                        width: newWidth,
                        height: newHeight
                    };

                    if (!checkRectCollision(tempRect, index)) {
                        // å¦‚æœæ²¡æœ‰ç¢°æ’ï¼Œåº”ç”¨æ–°å°ºå¯¸
                        rectDiv.style.width = newWidth + 'px';
                        rectDiv.style.height = newHeight + 'px';

                        // æ›´æ–°æ•°æ®
                        if (currentLayout.rectangles[index]) {
                            currentLayout.rectangles[index].width = newWidth;
                            currentLayout.rectangles[index].height = newHeight;
                            currentLayout.rectangles[index].original_width = newWidth;
                            currentLayout.rectangles[index].original_height = newHeight;

                            // æ›´æ–°è¾“å…¥æ¡†
                            document.getElementById('rectWidth').value = newWidth;
                            document.getElementById('rectHeight').value = newHeight;

                            // æ›´æ–°å›¾æ ‡ä½ç½®ï¼ˆä¿æŒç›¸å¯¹ä½ç½®ï¼‰
                            const rect = currentLayout.rectangles[index];
                            if (rect.icons && Array.isArray(rect.icons)) {
                                rect.icons.forEach((icon, iconIndex) => {
                                    // é‡æ–°è®¡ç®—ç»å¯¹ä½ç½®
                                    icon.display_x = rect.x + (newWidth - (icon.display_width || 30)) * (icon.rel_x || 0.5);
                                    icon.display_y = rect.y + (newHeight - (icon.display_height || 30)) * (icon.rel_y || 0.5);

                                    // æ›´æ–°DOM
                                    const iconDiv = document.querySelector(
                                        `.icon-hollow-rect[data-rect-index="${index}"][data-icon-index="${iconIndex}"]`
                                    );
                                    if (iconDiv) {
                                        iconDiv.style.left = icon.display_x + 'px';
                                        iconDiv.style.top = icon.display_y + 'px';
                                    }
                                });
                            }
                        }

                        updateSelectedRectInfo();
                    }
                };

                document.onmouseup = function () {
                    isResizing = false;
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        }

        // ä½¿å…ƒç´ å¯æ‹–æ‹½
        function makeDraggable(element, index, type, rectIndex = -1) {
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;
            let originalIconPositions = []; // Store original icon positions for rect dragging

            element.onmousedown = function (e) {
                if (e.button !== 0) return; // åªå“åº”å·¦é”®
                // å¦‚æœç‚¹å‡»çš„æ˜¯resize handleï¼Œä¸è§¦å‘æ‹–åŠ¨
                if (e.target.classList.contains('resize-handle')) return;

                e.stopPropagation(); // é˜²æ­¢äº‹ä»¶å†’æ³¡

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                const rect = element.getBoundingClientRect();
                initialLeft = parseInt(element.style.left) || 0;
                initialTop = parseInt(element.style.top) || 0;

                // è®¾ç½®æ‹–åŠ¨çŠ¶æ€
                if (type === 'icon') {
                    draggedIconElement = element;
                    element.classList.add('dragging');
                } else if (type === 'rect') {
                    // Store original icon positions
                    const rectData = currentLayout.rectangles[index];
                    if (rectData && rectData.icons && Array.isArray(rectData.icons)) {
                        originalIconPositions = rectData.icons.map(icon => ({
                            x: icon.display_x || 0,
                            y: icon.display_y || 0
                        }));
                    }
                }

                e.preventDefault();

                // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
                clearAlignmentGuides();

                document.onmousemove = function (e) {
                    if (!isDragging) return;

                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;

                    let newX = initialLeft + dx;
                    let newY = initialTop + dy;

                    // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                    const screenWidth = currentLayout.screen.width;
                    const screenHeight = currentLayout.screen.height;
                    const elementWidth = parseInt(element.style.width) || 0;
                    const elementHeight = parseInt(element.style.height) || 0;

                    newX = Math.max(0, Math.min(newX, screenWidth - elementWidth));
                    newY = Math.max(0, Math.min(newY, screenHeight - elementHeight));

                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯å›¾æ ‡ï¼Œæ£€æŸ¥æ˜¯å¦ç§»åŠ¨åˆ°å…¶ä»–çŸ©å½¢ä¸­
                    if (type === 'icon') {
                        // æ£€æŸ¥å¯¹é½åˆ°å…¶ä»–å…ƒç´ 
                        const aligned = checkAlignment(newX, newY, elementWidth, elementHeight, type, rectIndex);
                        newX = aligned.x;
                        newY = aligned.y;

                        // è®¡ç®—å›¾æ ‡ä¸­å¿ƒç‚¹
                        const iconCenterX = newX + elementWidth / 2;
                        const iconCenterY = newY + elementHeight / 2;

                        // æŸ¥æ‰¾å›¾æ ‡ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let hoveredRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (iconCenterX >= rect.x && iconCenterX <= rect.x + rect.width &&
                                iconCenterY >= rect.y && iconCenterY <= rect.y + rect.height) {
                                hoveredRectIndex = i;
                                break;
                            }
                        }

                        // å¦‚æœä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢å¹¶é«˜äº®
                        if (hoveredRectIndex === -1 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(iconCenterX - rectCenterX, 2) +
                                    Math.pow(iconCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    hoveredRectIndex = i;
                                }
                            }
                        }

                        // æ›´æ–°çŸ©å½¢é«˜äº®çŠ¶æ€
                        updateRectangleHighlight(hoveredRectIndex);

                        // æ›´æ–°å›¾æ ‡åœ¨çŸ©å½¢ä¸­çš„ç›¸å¯¹ä½ç½®
                        if (rectIndex >= 0 && currentLayout.rectangles[rectIndex]) {
                            const parentRect = currentLayout.rectangles[rectIndex];
                            const icon = parentRect.icons[index];

                            if (icon) {
                                // è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºå›¾æ ‡å·¦ä¸Šè§’ï¼‰
                                icon.display_x = newX;
                                icon.display_y = newY;
                                icon.rel_x = (newX - parentRect.x) / parentRect.width;
                                icon.rel_y = (newY - parentRect.y) / parentRect.height;
                            }
                        }
                    } else if (type === 'rect') {
                        // æ£€æŸ¥çŸ©å½¢å¯¹é½
                        const aligned = checkAlignment(newX, newY, elementWidth, elementHeight, type, index);

                        // ç¢°æ’æ£€æµ‹ï¼šå¦‚æœæ–°ä½ç½®ä¼šå¯¼è‡´é‡å ï¼Œåˆ™ä¸å…è®¸ç§»åŠ¨
                        const tempRect = {
                            x: aligned.x,
                            y: aligned.y,
                            width: elementWidth,
                            height: elementHeight
                        };

                        if (!checkRectCollision(tempRect, index)) {
                            newX = aligned.x;
                            newY = aligned.y;

                            // æ›´æ–°çŸ©å½¢æ•°æ®
                            if (currentLayout.rectangles[index]) {
                                currentLayout.rectangles[index].x = newX;
                                currentLayout.rectangles[index].y = newY;
                                currentLayout.rectangles[index].original_x = newX;
                                currentLayout.rectangles[index].original_y = newY;

                                // åŒæ—¶æ›´æ–°çŸ©å½¢å†…æ‰€æœ‰å›¾æ ‡çš„ä½ç½®
                                const rect = currentLayout.rectangles[index];
                                if (rect.icons && Array.isArray(rect.icons)) {
                                    const deltaX = newX - initialLeft;
                                    const deltaY = newY - initialTop;

                                    rect.icons.forEach((icon, iconIndex) => {
                                        if (originalIconPositions[iconIndex]) {
                                            icon.display_x = originalIconPositions[iconIndex].x + deltaX;
                                            icon.display_y = originalIconPositions[iconIndex].y + deltaY;
                                        }

                                        // æ›´æ–°å¯¹åº”çš„DOMå…ƒç´ 
                                        const iconDiv = document.querySelector(
                                            `.icon-hollow-rect[data-rect-index="${index}"][data-icon-index="${iconIndex}"]`
                                        );
                                        if (iconDiv) {
                                            iconDiv.style.left = icon.display_x + 'px';
                                            iconDiv.style.top = icon.display_y + 'px';
                                        }
                                    });
                                }
                            }
                        } else {
                            // å‘ç”Ÿç¢°æ’ï¼Œä¿æŒåŸä½ï¼ˆæˆ–è€…å¯ä»¥åšæ›´ç²¾ç»†çš„è´´è¾¹å¤„ç†ï¼Œè¿™é‡Œç®€å•å¤„ç†ä¸ºä¸ç§»åŠ¨ï¼‰
                            newX = parseInt(element.style.left);
                            newY = parseInt(element.style.top);
                        }
                    }

                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';

                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯æ–‡æœ¬ï¼Œæ›´æ–°ç›¸å¯¹ä½ç½®
                    if (type === 'text' && rectIndex >= 0 && currentLayout.rectangles[rectIndex]) {
                        const parentRect = currentLayout.rectangles[rectIndex];
                        if (parentRect.texts && parentRect.texts[index]) {
                            const text = parentRect.texts[index];

                            // è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºæ–‡æœ¬å¯¹é½ç‚¹ï¼‰
                            text.rel_x = Math.max(0, Math.min(1, (newX - parentRect.x) / parentRect.width));
                            text.rel_y = Math.max(0, Math.min(1, (newY - parentRect.y) / parentRect.height));
                        }
                    }

                    // æ›´æ–°é€‰ä¸­ä¿¡æ¯
                    updateSelectedRectInfo();
                };

                document.onmouseup = function (e) {
                    if (!isDragging) return;

                    // æ£€æµ‹ç‚¹å‡» (è·ç¦» < 5)
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    if (Math.sqrt(dx * dx + dy * dy) < 5) {
                        if (type === 'icon') selectIcon(rectIndex, index);
                        else if (type === 'rect') selectRectangle(index);
                        else if (type === 'text') selectText(rectIndex, index);
                    }

                    isDragging = false;

                    // æ¸…é™¤æ‹–åŠ¨çŠ¶æ€
                    if (type === 'icon' && draggedIconElement) {
                        // è·å–å›¾æ ‡çš„æœ€ç»ˆä½ç½®
                        let iconX = parseInt(element.style.left);
                        let iconY = parseInt(element.style.top);
                        const iconWidth = parseInt(element.style.width);
                        const iconHeight = parseInt(element.style.height);
                        let iconCenterX = iconX + iconWidth / 2;
                        let iconCenterY = iconY + iconHeight / 2;

                        // 1. æŸ¥æ‰¾å›¾æ ‡ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let targetRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (iconCenterX >= rect.x && iconCenterX <= rect.x + rect.width &&
                                iconCenterY >= rect.y && iconCenterY <= rect.y + rect.height) {
                                targetRectIndex = i;
                                break;
                            }
                        }

                        // 2. å¦‚æœå›¾æ ‡ä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢
                        if (targetRectIndex < 0 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;
                            let nearestRectIndex = -1;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];

                                // è®¡ç®—å›¾æ ‡ä¸­å¿ƒç‚¹åˆ°çŸ©å½¢ä¸­å¿ƒçš„è·ç¦»
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(iconCenterX - rectCenterX, 2) +
                                    Math.pow(iconCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestRectIndex = i;
                                }
                            }

                            if (nearestRectIndex >= 0) {
                                targetRectIndex = nearestRectIndex;
                                console.log(`å›¾æ ‡ä¸åœ¨çŸ©å½¢å†…ï¼Œå¸é™„åˆ°æœ€è¿‘çš„çŸ©å½¢${targetRectIndex}`);
                            }
                        }

                        // 3. å¼ºåˆ¶é™åˆ¶å›¾æ ‡åœ¨ç›®æ ‡çŸ©å½¢èŒƒå›´å†…ï¼ˆé˜²æ­¢è·¨è¶Šè¾¹ç•Œï¼‰
                        if (targetRectIndex >= 0) {
                            const targetRect = currentLayout.rectangles[targetRectIndex];

                            // ä¸¥æ ¼é™åˆ¶åæ ‡åœ¨çŸ©å½¢å†…éƒ¨
                            const clampedX = Math.max(targetRect.x, Math.min(iconX, targetRect.x + targetRect.width - iconWidth));
                            const clampedY = Math.max(targetRect.y, Math.min(iconY, targetRect.y + targetRect.height - iconHeight));

                            // æ£€æŸ¥ä½ç½®æ˜¯å¦å‘ç”Ÿäº†ä¿®æ­£
                            if (clampedX !== iconX || clampedY !== iconY) {
                                iconX = clampedX;
                                iconY = clampedY;

                                // ç«‹å³æ›´æ–°DOMä½ç½®
                                element.style.left = iconX + 'px';
                                element.style.top = iconY + 'px';
                                console.log('å›¾æ ‡ä½ç½®å·²è‡ªåŠ¨ä¿®æ­£åˆ°çŸ©å½¢èŒƒå›´å†…');
                            }

                            // 4. æ›´æ–°æ•°æ®ç»“æ„
                            if (targetRectIndex !== rectIndex) {
                                // æƒ…å†µAï¼šç§»åŠ¨åˆ°äº†ä¸åŒçš„çŸ©å½¢
                                const sourceRect = currentLayout.rectangles[rectIndex];

                                // ä»åŸçŸ©å½¢ä¸­ç§»é™¤å›¾æ ‡
                                const iconData = sourceRect.icons.splice(index, 1)[0];
                                sourceRect.icon_count = sourceRect.icons.length;

                                // é‡æ–°è®¡ç®—å›¾æ ‡åœ¨æ–°çŸ©å½¢ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºå›¾æ ‡å·¦ä¸Šè§’ï¼‰
                                iconData.rel_x = (iconX - targetRect.x) / targetRect.width;
                                iconData.rel_y = (iconY - targetRect.y) / targetRect.height;
                                iconData.display_x = iconX;
                                iconData.display_y = iconY;
                                // è®°å½•ç›®æ ‡çŸ©å½¢ç´¢å¼•
                                iconData.rect_index = targetRectIndex;

                                // æ·»åŠ åˆ°æ–°çŸ©å½¢
                                targetRect.icons.push(iconData);
                                targetRect.icon_count = targetRect.icons.length;

                                // æ›´æ–°DOMå…ƒç´ çš„data-rect-indexå±æ€§
                                element.dataset.rectIndex = targetRectIndex;

                                // æ›´æ–°é€‰ä¸­çŠ¶æ€
                                selectedRectIndex = targetRectIndex;
                                selectedIconIndex = targetRect.icons.length - 1;

                                console.log(`å›¾æ ‡ä»çŸ©å½¢${rectIndex}ç§»åŠ¨åˆ°çŸ©å½¢${targetRectIndex}ï¼Œå·²è®¾ç½®rect_index=${targetRectIndex}`);
                            } else {
                                // æƒ…å†µBï¼šè¿˜åœ¨åŒä¸€ä¸ªçŸ©å½¢ï¼Œä½†ä½ç½®å¯èƒ½è¢«ä¿®æ­£äº†ï¼ˆå¸é™„è¾¹ç¼˜ï¼‰
                                // éœ€è¦æ›´æ–°å½“å‰å›¾æ ‡çš„æ•°æ®ï¼Œå› ä¸ºmousemoveåªæ›´æ–°äº†åŸå§‹çš„æ‹–æ‹½ä½ç½®
                                const iconData = currentLayout.rectangles[rectIndex].icons[index];
                                if (iconData) {
                                    iconData.display_x = iconX;
                                    iconData.display_y = iconY;
                                    iconData.rel_x = (iconX - targetRect.x) / targetRect.width;
                                    iconData.rel_y = (iconY - targetRect.y) / targetRect.height;
                                    // ä»åœ¨åŸçŸ©å½¢ï¼Œä¿ç•™æˆ–è®¾ç½®rect_index
                                    iconData.rect_index = targetRectIndex;
                                }
                            }

                            // æ›´æ–°é€‰ä¸­å›¾æ ‡ä¿¡æ¯æ˜¾ç¤º
                            updateSelectedRectInfo();
                        }

                        draggedIconElement.classList.remove('dragging');
                        draggedIconElement = null;

                        // æ¸…é™¤çŸ©å½¢é«˜äº®
                        updateRectangleHighlight(-1);
                    } else if (type === 'text') {
                        // æ–‡æœ¬æ‹–æ‹½å®Œæˆå¤„ç† - æ”¯æŒè·¨çŸ©å½¢ç§»åŠ¨
                        const textWidth = parseInt(element.style.width) || 100;
                        const textHeight = parseInt(element.style.height) || 20;
                        let textX = parseInt(element.style.left);
                        let textY = parseInt(element.style.top);
                        let textCenterX = textX + textWidth / 2;
                        let textCenterY = textY + textHeight / 2;

                        // æŸ¥æ‰¾æ–‡æœ¬ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let targetRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (textCenterX >= rect.x && textCenterX <= rect.x + rect.width &&
                                textCenterY >= rect.y && textCenterY <= rect.y + rect.height) {
                                targetRectIndex = i;
                                break;
                            }
                        }

                        // å¦‚æœæ–‡æœ¬ä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢
                        if (targetRectIndex < 0 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(textCenterX - rectCenterX, 2) +
                                    Math.pow(textCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    targetRectIndex = i;
                                }
                            }

                            if (targetRectIndex >= 0) {
                                console.log(`æ–‡æœ¬ä¸åœ¨çŸ©å½¢å†…ï¼Œå¸é™„åˆ°æœ€è¿‘çš„çŸ©å½¢${targetRectIndex}`);
                            }
                        }

                        // æ›´æ–°æ–‡æœ¬æ•°æ®
                        if (targetRectIndex >= 0) {
                            const targetRect = currentLayout.rectangles[targetRectIndex];

                            // é™åˆ¶åœ¨çŸ©å½¢å†…
                            textX = Math.max(targetRect.x, Math.min(textX, targetRect.x + targetRect.width - textWidth));
                            textY = Math.max(targetRect.y, Math.min(textY, targetRect.y + targetRect.height - textHeight));

                            if (targetRectIndex !== rectIndex) {
                                // ç§»åŠ¨åˆ°ä¸åŒçŸ©å½¢
                                const sourceRect = currentLayout.rectangles[rectIndex];
                                if (!sourceRect.texts) sourceRect.texts = [];
                                const textData = sourceRect.texts.splice(index, 1)[0];

                                // æ›´æ–°ç›¸å¯¹ä½ç½®
                                textData.rel_x = (textX - targetRect.x) / targetRect.width;
                                textData.rel_y = (textY - targetRect.y) / targetRect.height;
                                // è®°å½•ç›®æ ‡çŸ©å½¢ç´¢å¼•
                                textData.rect_index = targetRectIndex;

                                if (!targetRect.texts) targetRect.texts = [];
                                targetRect.texts.push(textData);
                                element.dataset.rectIndex = targetRectIndex;

                                selectedRectIndex = targetRectIndex;
                                selectedTextIndex = targetRect.texts.length - 1;

                                console.log(`æ–‡æœ¬ä»çŸ©å½¢${rectIndex}ç§»åŠ¨åˆ°çŸ©å½¢${targetRectIndex}ï¼Œå·²è®¾ç½®rect_index=${targetRectIndex}`);
                            } else {
                                // è¿˜åœ¨åŒä¸€çŸ©å½¢
                                const textData = currentLayout.rectangles[rectIndex].texts[index];
                                if (textData) {
                                    textData.rel_x = (textX - targetRect.x) / targetRect.width;
                                    textData.rel_y = (textY - targetRect.y) / targetRect.height;
                                    // ä»åœ¨åŸçŸ©å½¢ï¼Œä¿ç•™æˆ–è®¾ç½®rect_index
                                    textData.rect_index = targetRectIndex;
                                }
                            }

                            // æ›´æ–°DOMä½ç½®
                            element.style.left = textX + 'px';
                            element.style.top = textY + 'px';

                            updateSelectedRectInfo();
                        }

                        element.classList.remove('dragging');
                        updateRectangleHighlight(-1);
                    }

                    // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
                    clearAlignmentGuides();

                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        }

        // æ£€æŸ¥å¯¹é½
        function checkAlignment(x, y, width, height, type, index) {
            const threshold = 5; // å¯¹é½é˜ˆå€¼
            let showVerticalGuide = false;
            let showHorizontalGuide = false;
            let guideX = 0;
            let guideY = 0;

            // æ£€æŸ¥å¯¹é½åˆ°å…¶ä»–çŸ©å½¢
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (type === 'rect' && rectIndex === index) return; // è·³è¿‡è‡ªå·±

                // å¯¹é½åˆ°çŸ©å½¢çš„å·¦è¾¹ç¼˜
                if (Math.abs(x - rect.x) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x;
                    x = rect.x; // å¯¹é½åˆ°è¯¥ä½ç½®
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„å³è¾¹ç¼˜
                else if (Math.abs(x + width - (rect.x + rect.width)) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x + rect.width - width;
                    x = rect.x + rect.width - width;
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„ä¸Šè¾¹ç¼˜
                if (Math.abs(y - rect.y) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y;
                    y = rect.y;
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„ä¸‹è¾¹ç¼˜
                else if (Math.abs(y + height - (rect.y + rect.height)) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y + rect.height - height;
                    y = rect.y + rect.height - height;
                }
                // å¯¹é½åˆ°çŸ©å½¢ä¸­å¿ƒçº¿ï¼ˆæ°´å¹³ï¼‰
                else if (Math.abs(y + height / 2 - (rect.y + rect.height / 2)) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y + rect.height / 2 - height / 2;
                    y = rect.y + rect.height / 2 - height / 2;
                }
                // å¯¹é½åˆ°çŸ©å½¢ä¸­å¿ƒçº¿ï¼ˆå‚ç›´ï¼‰
                else if (Math.abs(x + width / 2 - (rect.x + rect.width / 2)) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x + rect.width / 2 - width / 2;
                    x = rect.x + rect.width / 2 - width / 2;
                }
            });

            // æ˜¾ç¤ºå¯¹é½è¾…åŠ©çº¿
            if (showVerticalGuide || showHorizontalGuide) {
                showAlignmentGuides(guideX, guideY, showVerticalGuide, showHorizontalGuide);
            }

            return { x, y };
        }

        // æ˜¾ç¤ºå¯¹é½è¾…åŠ©çº¿
        function showAlignmentGuides(x, y, showVertical, showHorizontal) {
            const guidesDiv = document.getElementById('alignmentGuides');
            guidesDiv.innerHTML = '';

            if (showVertical) {
                const verticalGuide = document.createElement('div');
                verticalGuide.className = 'alignment-guide vertical';
                verticalGuide.style.left = x + 'px';
                verticalGuide.style.top = '0';
                guidesDiv.appendChild(verticalGuide);
            }

            if (showHorizontal) {
                const horizontalGuide = document.createElement('div');
                horizontalGuide.className = 'alignment-guide horizontal';
                horizontalGuide.style.left = '0';
                horizontalGuide.style.top = y + 'px';
                guidesDiv.appendChild(horizontalGuide);
            }
        }

        // æ›´æ–°çŸ©å½¢é«˜äº®çŠ¶æ€
        function updateRectangleHighlight(targetIndex) {
            // ç§»é™¤ä¹‹å‰çš„é«˜äº®
            if (currentDropTargetIndex >= 0) {
                const prevRect = document.querySelector(`.rect[data-index="${currentDropTargetIndex}"]`);
                if (prevRect) {
                    prevRect.classList.remove('drop-target');
                }
            }

            // æ·»åŠ æ–°çš„é«˜äº®
            if (targetIndex >= 0) {
                const targetRect = document.querySelector(`.rect[data-index="${targetIndex}"]`);
                if (targetRect) {
                    targetRect.classList.add('drop-target');
                }
            }

            currentDropTargetIndex = targetIndex;
        }

        // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
        function clearAlignmentGuides() {
            const guidesDiv = document.getElementById('alignmentGuides');
            guidesDiv.innerHTML = '';
        }


        // é€‰ä¸­çŸ©å½¢
        function selectRectangle(index) {
            selectedRectIndex = index;
            selectedIconIndex = -1;
            selectedTextIndex = -1; // æ¸…é™¤æ–‡æœ¬é€‰æ‹©

            // æ›´æ–°æ˜¾ç¤º
            document.querySelectorAll('.rect').forEach(rect => {
                rect.classList.remove('selected');
            });

            // æ¸…é™¤æ‰€æœ‰å›¾æ ‡çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.icon-hollow-rect').forEach(icon => {
                icon.classList.remove('selected');
            });

            // æ¸…é™¤æ‰€æœ‰æ–‡æœ¬çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.text-element').forEach(textEl => {
                textEl.classList.remove('selected');
            });

            if (currentLayout.rectangles[index]) {
                const rectDiv = document.querySelector(`.rect[data-index="${index}"]`);
                if (rectDiv) {
                    rectDiv.classList.add('selected');
                }

                // æ›´æ–°è¡¨å•å€¼
                document.getElementById('rectWidth').value = currentLayout.rectangles[index].width;
                document.getElementById('rectHeight').value = currentLayout.rectangles[index].height;
            }

            updateSelectedRectInfo();
        }

        // é€‰ä¸­å›¾æ ‡
        function selectIcon(rectIndex, iconIndex) {
            // 1. å…ˆé€‰ä¸­çŸ©å½¢ï¼ˆè¿™ä¼šé‡ç½® selectedIconIndex ä¸º -1ï¼Œå¹¶æ¸…é™¤æ‰€æœ‰å›¾æ ‡é€‰ä¸­æ ·å¼ï¼‰
            selectRectangle(rectIndex);

            // 2. é‡æ–°è®¾ç½®å›¾æ ‡é€‰ä¸­çŠ¶æ€
            selectedRectIndex = rectIndex;
            selectedIconIndex = iconIndex;

            // 3. è®¾ç½®å½“å‰å›¾æ ‡ä¸ºé€‰ä¸­çŠ¶æ€
            const iconDiv = document.querySelector(`.icon-hollow-rect[data-rect-index="${rectIndex}"][data-icon-index="${iconIndex}"]`);
            if (iconDiv) {
                iconDiv.classList.add('selected');
            }

            // 4. æ›´æ–°è¾“å…¥æ¡†æ•°æ®
            if (currentLayout.rectangles[rectIndex] &&
                currentLayout.rectangles[rectIndex].icons[iconIndex]) {
                const icon = currentLayout.rectangles[rectIndex].icons[iconIndex];
                document.getElementById('iconIndex').value = icon.icon_index || 0;
                document.getElementById('iconRelX').value = (icon.rel_x !== undefined ? icon.rel_x : 0.5).toFixed(2);
                document.getElementById('iconRelY').value = (icon.rel_y !== undefined ? icon.rel_y : 0.5).toFixed(2);
            }

            // 5. å†æ¬¡æ›´æ–°ä¿¡æ¯é¢æ¿ï¼ˆå› ä¸º selectRectangle æ›´æ–°æ—¶ selectedIconIndex è¿˜æ˜¯ -1ï¼‰
            updateSelectedRectInfo();
        }

        // æ›´æ–°é€‰ä¸­çŸ©å½¢ä¿¡æ¯
        function updateSelectedRectInfo() {
            const infoDiv = document.getElementById('selectedRectInfo');

            if (selectedRectIndex >= 0 && currentLayout.rectangles[selectedRectIndex]) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                let iconInfo = '';
                let textInfo = '';

                if (rect.icons && rect.icons.length > 0) {
                    iconInfo = '<p>å›¾æ ‡ä¿¡æ¯:</p><ul style="font-size:10px;">';
                    rect.icons.forEach((icon, index) => {
                        const relX = icon.rel_x !== undefined ? icon.rel_x.toFixed(2) : '0.50';
                        const relY = icon.rel_y !== undefined ? icon.rel_y.toFixed(2) : '0.50';
                        iconInfo += `<li>å›¾æ ‡${index}: ç´¢å¼•=${icon.icon_index}, ç›¸å¯¹(${relX}, ${relY}), å°ºå¯¸=${icon.original_width || 30}Ã—${icon.original_height || 30}</li>`;
                    });
                    iconInfo += '</ul>';
                }

                if (rect.texts && rect.texts.length > 0) {
                    const typeNames = ['å•è¯', 'éŸ³æ ‡', 'é‡Šä¹‰', 'ç¿»è¯‘'];
                    textInfo = '<p>æ–‡æœ¬ä¿¡æ¯:</p><ul style="font-size:10px;">';
                    rect.texts.forEach((text, index) => {
                        const relX = text.rel_x !== undefined ? text.rel_x.toFixed(2) : '0.50';
                        const relY = text.rel_y !== undefined ? text.rel_y.toFixed(2) : '0.50';
                        textInfo += `<li>æ–‡æœ¬${index}: ${typeNames[text.content_type] || 'æœªçŸ¥'}, "${text.content}", ç›¸å¯¹(${relX}, ${relY}), å­—ä½“${text.font_size}px</li>`;
                    });
                    textInfo += '</ul>';
                }

                let deleteBtn = '';
                if (selectedIconIndex >= 0) {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­å›¾æ ‡ (Deleteé”®)</button>`;
                } else if (selectedTextIndex >= 0) {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­æ–‡æœ¬ (Deleteé”®)</button>`;
                } else {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­çŸ©å½¢ (Deleteé”®)</button>`;
                }

                infoDiv.innerHTML = `
                    <span class="rect-id">çŸ©å½¢ ${selectedRectIndex}</span>
                    <p>ä½ç½®: (${rect.x}, ${rect.y})</p>
                    <p>å°ºå¯¸: ${rect.width}Ã—${rect.height}</p>
                    <p>å›¾æ ‡æ•°: ${rect.icon_count || 0}</p>
                    <p>æ–‡æœ¬æ•°: ${rect.texts ? rect.texts.length : 0}</p>
                    <p>çŠ¶æ€æ : ${selectedRectIndex === currentLayout.status_rect_index ? 'æ˜¯' : 'å¦'}</p>
                    <div style="margin-top:8px;">
                        <label style="font-weight:700; display:block; margin-bottom:6px;">ç„¦ç‚¹æ¨¡å¼</label>
                        <select id="rectFocusMode" style="width:100%; padding:6px; border:1px solid #ddd; border-radius:4px;">
                            <option value="0">é»˜è®¤ (Default)</option>
                            <option value="1">è§’æ ‡ (Corners)</option>
                            <option value="2">è¾¹æ¡† (Border)</option>
                        </select>
                    </div>
                    ${selectedIconIndex >= 0 ? `<p>é€‰ä¸­çš„å›¾æ ‡: ${selectedIconIndex} (ç´¢å¼•: ${currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.icon_index || 'N/A'}, ç›¸å¯¹ä½ç½®: ${(currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.rel_x || 0.5).toFixed(2)}, ${(currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.rel_y || 0.5).toFixed(2)})</p>` : ''}
                    ${selectedTextIndex >= 0 ? `<p>é€‰ä¸­çš„æ–‡æœ¬: ${selectedTextIndex} (å†…å®¹: "${currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.content || ''}", ç›¸å¯¹ä½ç½®: ${(currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.rel_x || 0.5).toFixed(2)}, ${(currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.rel_y || 0.5).toFixed(2)})</p>` : ''}
                    ${deleteBtn}
                    ${iconInfo}
                    ${textInfo}
                `;

                // å°†selectè®¾ç½®ä¸ºå½“å‰rectçš„focus_modeå¹¶ç»‘å®šäº‹ä»¶
                setTimeout(() => {
                    const sel = document.getElementById('rectFocusMode');
                    if (sel) {
                        const fm = (rect.focus_mode !== undefined) ? rect.focus_mode : 0;
                        sel.value = String(fm);
                        sel.onchange = function () {
                            const val = parseInt(this.value);
                            if (!isNaN(val) && currentLayout.rectangles[selectedRectIndex]) {
                                currentLayout.rectangles[selectedRectIndex].focus_mode = val;
                                showStatus('ç„¦ç‚¹æ¨¡å¼å·²æ›´æ–°', 'success');
                            }
                        };
                    }
                    // åˆ›å»ºå¹¶è®¾ç½® onConfirm åŠ¨ä½œé€‰æ‹©ä¸‹æ‹‰
                    const actSelId = 'rectOnConfirmAction';
                    let actSel = document.getElementById(actSelId);
                    if (!actSel) {
                        actSel = document.createElement('select');
                        actSel.id = actSelId;
                        actSel.style.width = '100%';
                        actSel.style.padding = '6px';
                        actSel.style.border = '1px solid #ddd';
                        actSel.style.borderRadius = '4px';
                        // æ’å…¥åˆ° infoDiv ä¸­ç´§è·Ÿç„¦ç‚¹æ¨¡å¼å…ƒç´ 
                        const fmEl = document.getElementById('rectFocusMode');
                        if (fmEl && fmEl.parentNode) {
                            const wrapper = document.createElement('div');
                            wrapper.style.marginTop = '8px';
                            const label = document.createElement('label');
                            label.style.fontWeight = '700';
                            label.style.display = 'block';
                            label.style.marginBottom = '6px';
                            label.textContent = 'ç¡®è®¤åŠ¨ä½œ (onConfirm)';
                            wrapper.appendChild(label);
                            wrapper.appendChild(actSel);
                            fmEl.parentNode.parentNode.insertBefore(wrapper, fmEl.parentNode.nextSibling);
                        }
                    }

                    // å¡«å……é€‰é¡¹
                    while (actSel.firstChild) actSel.removeChild(actSel.firstChild);
                    const noneOpt = document.createElement('option');
                    noneOpt.value = '';
                    noneOpt.textContent = '-- æ—  --';
                    actSel.appendChild(noneOpt);
                    const actions = window.availableActions || [];
                    actions.forEach(a => {
                        const opt = document.createElement('option');
                        opt.value = a.id || '';
                        opt.textContent = a.name || a.id || a;
                        actSel.appendChild(opt);
                    });

                    // è®¾ä¸ºå½“å‰rectçš„ç»‘å®šï¼ˆå¦‚æœæœ‰ï¼‰
                    const curAction = currentLayout.rectangles[selectedRectIndex].on_confirm_action || '';
                    actSel.value = curAction;
                    actSel.onchange = function () {
                        const val = this.value;
                        currentLayout.rectangles[selectedRectIndex].on_confirm_action = val;
                        showStatus('ç¡®è®¤åŠ¨ä½œå·²æ›´æ–°', 'success');
                    };
                }, 0);
            } else {
                infoDiv.innerHTML = 'æœªé€‰ä¸­ä»»ä½•çŸ©å½¢';
            }
        }

        // åˆ é™¤é€‰ä¸­é¡¹
        function deleteSelected() {
            if (selectedRectIndex >= 0) {
                if (selectedIconIndex >= 0) {
                    // åˆ é™¤å›¾æ ‡
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                        rect.icons.splice(selectedIconIndex, 1);
                        rect.icon_count = rect.icons.length;

                        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                        selectedIconIndex = -1;

                        // é‡æ–°æ¸²æŸ“
                        renderLayout(currentLayout);

                        // æ›´æ–°ä¿¡æ¯é¢æ¿
                        updateSelectedRectInfo();

                        showStatus('å›¾æ ‡å·²åˆ é™¤', 'success');
                    }
                } else if (selectedTextIndex >= 0) {
                    // åˆ é™¤æ–‡æœ¬
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    if (rect && rect.texts && rect.texts[selectedTextIndex]) {
                        rect.texts.splice(selectedTextIndex, 1);

                        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                        selectedTextIndex = -1;

                        // é‡æ–°æ¸²æŸ“
                        renderLayout(currentLayout);

                        // æ›´æ–°ä¿¡æ¯é¢æ¿
                        updateSelectedRectInfo();

                        showStatus('æ–‡æœ¬å·²åˆ é™¤', 'success');
                    }
                } else {
                    // åˆ é™¤çŸ©å½¢
                    removeSelectedRect();
                }
            }
        }

        // é€‰ä¸­æ–‡æœ¬
        function selectText(rectIndex, textIndex) {
            // å…ˆé€‰ä¸­çŸ©å½¢
            selectRectangle(rectIndex);

            // è®¾ç½®æ–‡æœ¬é€‰ä¸­çŠ¶æ€
            selectedRectIndex = rectIndex;
            selectedTextIndex = textIndex;

            // æ¸…é™¤æ‰€æœ‰æ–‡æœ¬çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.text-element').forEach(textEl => {
                textEl.classList.remove('selected');
            });

            // è®¾ç½®å½“å‰æ–‡æœ¬ä¸ºé€‰ä¸­çŠ¶æ€
            const textDiv = document.querySelector(`.text-element[data-rect-index="${rectIndex}"][data-text-index="${textIndex}"]`);
            if (textDiv) {
                textDiv.classList.add('selected');
            }

            // æ›´æ–°æ–‡æœ¬è¾“å…¥æ¡†æ•°æ®
            if (currentLayout.rectangles[rectIndex] &&
                currentLayout.rectangles[rectIndex].texts &&
                currentLayout.rectangles[rectIndex].texts[textIndex]) {
                const text = currentLayout.rectangles[rectIndex].texts[textIndex];
                document.getElementById('textType').value = text.content_type || 3;
                document.getElementById('textContent').value = text.content || '';
                document.getElementById('textRelX').value = (text.rel_x !== undefined ? text.rel_x : 0.5).toFixed(2);
                document.getElementById('textRelY').value = (text.rel_y !== undefined ? text.rel_y : 0.5).toFixed(2);
                document.getElementById('textFontSize').value = text.font_size || 16;
                document.getElementById('textHAlign').value = text.h_align || 1;
                document.getElementById('textVAlign').value = text.v_align || 1;
            }

            // æ›´æ–°ä¿¡æ¯é¢æ¿
            updateSelectedRectInfo();
        }

        // ç»‘å®šé”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸æ‰§è¡Œåˆ é™¤
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                    return;
                }

                deleteSelected();
                e.preventDefault();
            }
        });
        //æ›´æ–°å±å¹•å°ºå¯¸
        async function updateScreenSize() {
            const width = parseInt(document.getElementById('screenWidth').value);
            const height = parseInt(document.getElementById('screenHeight').value);

            if (width >= 100 && width <= 800 && height >= 100 && height <= 600) {
                try {
                    // æ˜¾ç¤ºæ­£åœ¨æ›´æ–°çš„çŠ¶æ€
                    showLoading('æ­£åœ¨æ›´æ–°è®¾å¤‡å±å¹•å°ºå¯¸...');
                    showStatus('æ­£åœ¨æ›´æ–°è®¾å¤‡å±å¹•å°ºå¯¸...', 'success');

                    // è·å–å½“å‰é¡µé¢çš„åŸºç¡€URL
                    const currentOrigin = window.location.origin;
                    console.log('å½“å‰é¡µé¢Origin:', currentOrigin);

                    // å‘é€è®¾ç½®å±å¹•å®½åº¦çš„å‘½ä»¤
                    const widthCommandUrl = `${currentOrigin}/command?commandText=$set/screenXSize=${width}&PAGE=0`;
                    console.log('å‘é€å®½åº¦å‘½ä»¤:', widthCommandUrl);

                    const widthResponse = await fetch(widthCommandUrl);
                    if (!widthResponse.ok) {
                        throw new Error(`è®¾ç½®å±å¹•å®½åº¦å¤±è´¥: HTTP ${widthResponse.status}`);
                    }
                    const widthResult = await widthResponse.text();
                    console.log('å®½åº¦å‘½ä»¤å“åº”:', widthResult);

                    // ç­‰å¾…ä¸€ä¸‹å†å‘é€é«˜åº¦å‘½ä»¤
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // å‘é€è®¾ç½®å±å¹•é«˜åº¦çš„å‘½ä»¤
                    const heightCommandUrl = `${currentOrigin}/command?commandText=$set/screenYSize=${height}&PAGE=0`;
                    console.log('å‘é€é«˜åº¦å‘½ä»¤:', heightCommandUrl);

                    const heightResponse = await fetch(heightCommandUrl);
                    if (!heightResponse.ok) {
                        throw new Error(`è®¾ç½®å±å¹•é«˜åº¦å¤±è´¥: HTTP ${heightResponse.status}`);
                    }
                    const heightResult = await heightResponse.text();
                    console.log('é«˜åº¦å‘½ä»¤å“åº”:', heightResult);

                    // ç­‰å¾…ä¸€ä¸‹è®©å•ç‰‡æœºå®Œæˆè®¾ç½®
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // æ›´æ–°æœ¬åœ°å¸ƒå±€æ•°æ®
                    currentLayout.screen.width = width;
                    currentLayout.screen.height = height;
                    currentLayout.screen.original_width = width;
                    currentLayout.screen.original_height = height;

                    // æ›´æ–°å±å¹•å®¹å™¨å°ºå¯¸
                    const screenContainer = document.getElementById('screenContainer');
                    screenContainer.style.width = width + 'px';
                    screenContainer.style.height = height + 'px';

                    // æ›´æ–°çŸ©å½¢è¾“å…¥æ¡†çš„æœ€å¤§å€¼
                    document.getElementById('rectWidth').max = width;
                    document.getElementById('rectHeight').max = height;

                    // æ›´æ–°æ˜¾ç¤ºçš„å±å¹•å°ºå¯¸ä¿¡æ¯
                    // document.getElementById('screenSize').textContent = `${width}Ã—${height}`;
                    // document.getElementById('designSize').textContent = `${width}Ã—${height}`;

                    // é‡æ–°ç»˜åˆ¶ç½‘æ ¼çº¿
                    drawGridLines();

                    // é‡æ–°ä»è®¾å¤‡è·å–å¸ƒå±€æ•°æ®
                    console.log('æ­£åœ¨è·å–æœ€æ–°å¸ƒå±€æ•°æ®...');
                    showStatus('æ­£åœ¨è·å–è®¾å¤‡æœ€æ–°å¸ƒå±€...', 'success');

                    try {
                        // è·å–æœ€æ–°å¸ƒå±€
                        const layoutData = await getCurrentLayoutFromDevice();

                        if (layoutData) {
                            console.log('æˆåŠŸè·å–æœ€æ–°å¸ƒå±€æ•°æ®');

                            // æ›´æ–°æœ¬åœ°currentLayoutï¼ˆgetCurrentLayoutFromDeviceå†…éƒ¨ä¼šè°ƒç”¨renderLayoutï¼‰
                            // ç¡®ä¿currentLayoutçš„å±å¹•å°ºå¯¸æ˜¯æœ€æ–°çš„
                            currentLayout.screen.width = width;
                            currentLayout.screen.height = height;
                            currentLayout.screen.original_width = width;
                            currentLayout.screen.original_height = height;

                            showStatus(`å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œå¸ƒå±€å·²é‡æ–°åŠ è½½`, 'success');
                        } else {
                            throw new Error('è·å–å¸ƒå±€æ•°æ®è¿”å›null');
                        }

                    } catch (layoutError) {
                        console.log('è·å–æœ€æ–°å¸ƒå±€å¤±è´¥:', layoutError);

                        // å¦‚æœè·å–å¸ƒå±€å¤±è´¥ï¼Œé‡æ–°æ¸²æŸ“å½“å‰å¸ƒå±€
                        renderLayout(currentLayout);
                        showStatus(`å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œä½†è·å–æœ€æ–°å¸ƒå±€å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®`, 'warning');
                    }

                } catch (error) {
                    console.error('æ›´æ–°å±å¹•å°ºå¯¸å¤±è´¥:', error);

                    // å³ä½¿è®¾å¤‡è®¾ç½®å¤±è´¥ï¼Œä¹Ÿæ›´æ–°æœ¬åœ°ç•Œé¢
                    currentLayout.screen.width = width;
                    currentLayout.screen.height = height;
                    currentLayout.screen.original_width = width;
                    currentLayout.screen.original_height = height;

                    const screenContainer = document.getElementById('screenContainer');
                    screenContainer.style.width = width + 'px';
                    screenContainer.style.height = height + 'px';

                    document.getElementById('screenSize').textContent = `${width}Ã—${height}`;
                    document.getElementById('designSize').textContent = `${width}Ã—${height}`;

                    document.getElementById('rectWidth').max = width;
                    document.getElementById('rectHeight').max = height;

                    drawGridLines();
                    renderLayout(currentLayout);

                    showStatus(`æœ¬åœ°å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œä½†è®¾å¤‡è®¾ç½®å¤±è´¥: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            } else {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å±å¹•å°ºå¯¸ (100-800 Ã— 100-600)', 'error');
            }
        }

        // æ·»åŠ æ–°çŸ©å½¢
        function addRectangle() {
            const width = parseInt(document.getElementById('rectWidth').value);
            const height = parseInt(document.getElementById('rectHeight').value);

            if (width < 10 || height < 10) {
                showStatus('çŸ©å½¢å°ºå¯¸å¤ªå°', 'error');
                return;
            }

            // æ‰¾ä¸€ä¸ªåˆé€‚çš„ä½ç½®æ”¾ç½®æ–°çŸ©å½¢
            let x = 10, y = 10;
            let placed = false;

            // ç®€å•çš„é¿è®©ç®—æ³•
            while (!placed) {
                let collision = false;
                for (const rect of currentLayout.rectangles) {
                    if (x < rect.x + rect.width &&
                        x + width > rect.x &&
                        y < rect.y + rect.height &&
                        y + height > rect.y) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    placed = true;
                } else {
                    x += 20;
                    if (x + width > currentLayout.screen.width) {
                        x = 10;
                        y += 20;
                    }
                    if (y + height > currentLayout.screen.height) {
                        // å¦‚æœæ”¾ä¸ä¸‹ï¼Œæ”¾åœ¨ç¬¬ä¸€ä¸ªçŸ©å½¢çš„æ—è¾¹
                        x = currentLayout.rectangles[0]?.x + currentLayout.rectangles[0]?.width + 10 || 10;
                        y = currentLayout.rectangles[0]?.y || 10;
                        placed = true;
                    }
                }
            }

            const newRect = {
                x: x,
                y: y,
                width: width,
                height: height,
                original_x: x,
                original_y: y,
                original_width: width,
                original_height: height,
                icon_count: 0,
                icons: [],
                is_status_bar: false,
                focus_mode: 0 // é»˜è®¤ç„¦ç‚¹æ¨¡å¼
            };

            currentLayout.rectangles.push(newRect);
            selectedRectIndex = currentLayout.rectangles.length - 1;
            selectedIconIndex = -1;

            renderLayout(currentLayout);
            showStatus('çŸ©å½¢æ·»åŠ æˆåŠŸ', 'success');
        }

        // åˆ é™¤é€‰ä¸­çŸ©å½¢
        function removeSelectedRect() {
            if (selectedRectIndex >= 0 && selectedRectIndex < currentLayout.rectangles.length) {
                currentLayout.rectangles.splice(selectedRectIndex, 1);
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                renderLayout(currentLayout);
                showStatus('çŸ©å½¢åˆ é™¤æˆåŠŸ', 'success');
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰çŸ©å½¢
        function clearAllRectangles() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰çŸ©å½¢å—ï¼Ÿ')) {
                currentLayout.rectangles = [];
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                renderLayout(currentLayout);
                showStatus('æ‰€æœ‰çŸ©å½¢å·²æ¸…ç©º', 'success');
            }
        }

        // æ·»åŠ å›¾æ ‡åˆ°é€‰ä¸­çŸ©å½¢
        function addIconToSelectedRect() {
            if (selectedRectIndex < 0 || selectedRectIndex >= currentLayout.rectangles.length) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            const iconIndex = parseInt(document.getElementById('iconIndex').value);

            if (iconIndex < 0 || iconIndex > 20) {
                showStatus('å›¾æ ‡ç´¢å¼•å¿…é¡»åœ¨0-20ä¹‹é—´', 'error');
                return;
            }

            // ä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆ0.0-1.0ï¼‰
            const relX = parseFloat(document.getElementById('iconRelX').value) || 0.5;
            const relY = parseFloat(document.getElementById('iconRelY').value) || 0.5;

            // é™åˆ¶èŒƒå›´åœ¨0.0-1.0ä¹‹é—´
            const clampedRelX = Math.max(0.0, Math.min(1.0, relX));
            const clampedRelY = Math.max(0.0, Math.min(1.0, relY));

            // æ ¹æ®å›¾æ ‡ç´¢å¼•è·å–åŸå§‹å°ºå¯¸ï¼ˆä¸C++ä»£ç ä¸­g_available_iconsåŒ¹é…ï¼‰
            const iconSizes = [
                [62, 64],   // 0 - ICON_1 (æˆ¿å­)
                [64, 64],   // 1 - ICON_2 (æµ‹é‡å›¾æ ‡) 
                [86, 64],   // 2 - ICON_3 (è®¾ç½®)
                [71, 56],   // 3 - ICON_4 (æ‰«æŠŠ)
                [76, 56],   // 4 - ICON_5 (æ‹–æŠŠ)
                [94, 64],   // 5 - ICON_6 (æ¸…æ´å·¥å…·)
                [15, 16],   // 6 - NAIL (é’‰å­)
                [32, 32],   // 7 - LOCK (é”)
                [16, 16],   // 8 - HORN (å–‡å­)
                [36, 24],   // 9 - BATTERY_1 (ç”µæ± )
                [32, 32],   // 10 - WIFI_DISCONNECT (WiFiæ–­å¼€)
                [32, 32],   // 11 - WIFI_CONNECT (WiFiè¿æ¥)
                [60, 16],   // 12 - UNDERLINE (ä¸‹åˆ’çº¿)
                [320, 36],  // 13 - promt (æç¤ºæ¡†)
                [80, 36],   // 14 - wifi_battry (WiFiç”µæ± )
                [336, 48],  // 15 - word (å•è¯æ¡†)
                [416, 24],  // 16 - Translation1 (ç¿»è¯‘æ¡†1)
                [416, 16],  // 17 - separate (åˆ†éš”çº¿)
                [80, 16],   // 18 - horn (å°å–‡å­)
                [80, 32],   // 19 - pon (åŠŸç‡æ˜¾ç¤º)
                [416, 72]   // 20 - definition (å®šä¹‰æ¡†)
            ];

            const [originalWidth, originalHeight] = iconSizes[iconIndex] || [30, 30];

            const icon = {
                icon_index: iconIndex,
                rel_x: clampedRelX,
                rel_y: clampedRelY,
                original_width: originalWidth,
                original_height: originalHeight
            };

            if (!rect.icons) rect.icons = [];
            rect.icons.push(icon);
            rect.icon_count = rect.icons.length;

            renderLayout(currentLayout);

            // é€‰ä¸­æ–°æ·»åŠ çš„å›¾æ ‡
            selectIcon(selectedRectIndex, rect.icons.length - 1);

            showStatus(`å›¾æ ‡æ·»åŠ æˆåŠŸ (rel_x=${clampedRelX.toFixed(2)}, rel_y=${clampedRelY.toFixed(2)})`, 'success');
        }

        // åˆ é™¤é€‰ä¸­å›¾æ ‡
        function removeSelectedIcon() {
            if (selectedRectIndex >= 0 && selectedIconIndex >= 0) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                    rect.icons.splice(selectedIconIndex, 1);
                    rect.icon_count = rect.icons.length;
                    selectedIconIndex = -1;
                    renderLayout(currentLayout);
                    showStatus('å›¾æ ‡åˆ é™¤æˆåŠŸ', 'success');
                }
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾æ ‡', 'error');
            }
        }

        // æ›´æ–°é€‰ä¸­å›¾æ ‡çš„ç›¸å¯¹ä½ç½®
        function updateSelectedIconPosition() {
            if (selectedRectIndex >= 0 && selectedIconIndex >= 0) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                    const icon = rect.icons[selectedIconIndex];
                    const newRelX = parseFloat(document.getElementById('iconRelX').value) || 0.5;
                    const newRelY = parseFloat(document.getElementById('iconRelY').value) || 0.5;

                    // é™åˆ¶èŒƒå›´åœ¨0.0-1.0ä¹‹é—´
                    icon.rel_x = Math.max(0.0, Math.min(1.0, newRelX));
                    icon.rel_y = Math.max(0.0, Math.min(1.0, newRelY));

                    renderLayout(currentLayout);
                    showStatus(`å›¾æ ‡ä½ç½®å·²æ›´æ–° (rel_x=${icon.rel_x.toFixed(2)}, rel_y=${icon.rel_y.toFixed(2)})`, 'success');
                }
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾æ ‡', 'error');
            }
        }

        // è‡ªåŠ¨æ’åˆ—å›¾æ ‡
        function autoArrangeIcons() {
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (rect.icons && rect.icons.length > 0) {
                    const cols = Math.ceil(Math.sqrt(rect.icons.length));
                    const rows = Math.ceil(rect.icons.length / cols);

                    rect.icons.forEach((icon, iconIndex) => {
                        const row = Math.floor(iconIndex / cols);
                        const col = iconIndex % cols;

                        const cellWidth = rect.width / cols;
                        const cellHeight = rect.height / rows;

                        const iconWidth = icon.display_width || icon.original_width || 30;
                        const iconHeight = icon.display_height || icon.original_height || 30;

                        icon.rel_x = (col + 0.5) / cols;
                        icon.rel_y = (row + 0.5) / rows;
                        icon.display_x = rect.x + col * cellWidth + cellWidth / 2 - iconWidth / 2;
                        icon.display_y = rect.y + row * cellHeight + cellHeight / 2 - iconHeight / 2;
                    });
                }
            });

            renderLayout(currentLayout);
            showStatus('å›¾æ ‡è‡ªåŠ¨æ’åˆ—å®Œæˆ', 'success');
        }

        // ===== æ–‡æœ¬ç®¡ç†åŠŸèƒ½ =====

        // æ·»åŠ æ–‡æœ¬åˆ°é€‰ä¸­çŸ©å½¢
        function addTextToSelectedRect() {
            if (selectedRectIndex < 0 || selectedRectIndex >= currentLayout.rectangles.length) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            const textType = parseInt(document.getElementById('textType').value);
            const textContent = document.getElementById('textContent').value.trim();

            if (!textContent) {
                showStatus('è¯·è¾“å…¥æ–‡æœ¬å†…å®¹', 'error');
                return;
            }

            // ä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆ0.0-1.0ï¼‰
            const relX = parseFloat(document.getElementById('textRelX').value) || 0.5;
            const relY = parseFloat(document.getElementById('textRelY').value) || 0.5;
            const fontSize = parseInt(document.getElementById('textFontSize').value) || 16;
            const hAlign = parseInt(document.getElementById('textHAlign').value) || 1;
            const vAlign = parseInt(document.getElementById('textVAlign').value) || 1;

            // é™åˆ¶èŒƒå›´
            const clampedRelX = Math.max(0.0, Math.min(1.0, relX));
            const clampedRelY = Math.max(0.0, Math.min(1.0, relY));

            const text = {
                content_type: textType,
                content: textContent,
                rel_x: clampedRelX,
                rel_y: clampedRelY,
                font_size: fontSize,
                h_align: hAlign,
                v_align: vAlign
            };

            // åˆå§‹åŒ–textsæ•°ç»„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!rect.texts) {
                rect.texts = [];
            }
            rect.texts.push(text);

            // è®¾ç½®ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼
            rect.custom_text_mode = true;

            renderLayout(currentLayout);
            showStatus(`æ–‡æœ¬å·²æ·»åŠ åˆ°çŸ©å½¢ ${selectedRectIndex}`, 'success');
        }

        // æ›´æ–°é€‰ä¸­æ–‡æœ¬ä½ç½®
        function updateSelectedTextPosition() {
            if (selectedRectIndex < 0 || selectedTextIndex < 0) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡æœ¬å…ƒç´ ', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            if (!rect.texts || selectedTextIndex >= rect.texts.length) {
                showStatus('é€‰ä¸­çš„æ–‡æœ¬ä¸å­˜åœ¨', 'error');
                return;
            }

            const text = rect.texts[selectedTextIndex];

            // ä»è¾“å…¥æ¡†è·å–æ–°å€¼
            text.rel_x = Math.max(0.0, Math.min(1.0, parseFloat(document.getElementById('textRelX').value) || 0.5));
            text.rel_y = Math.max(0.0, Math.min(1.0, parseFloat(document.getElementById('textRelY').value) || 0.5));
            text.font_size = parseInt(document.getElementById('textFontSize').value) || 16;
            text.h_align = parseInt(document.getElementById('textHAlign').value) || 1;
            text.v_align = parseInt(document.getElementById('textVAlign').value) || 1;

            // æ›´æ–°å†…å®¹ï¼ˆå¦‚æœå·²ä¿®æ”¹ï¼‰
            const newContent = document.getElementById('textContent').value.trim();
            if (newContent) {
                text.content = newContent;
            }

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬ä½ç½®å·²æ›´æ–°', 'success');
        }

        // åˆ é™¤é€‰ä¸­æ–‡æœ¬
        function removeSelectedText() {
            if (selectedRectIndex < 0 || selectedTextIndex < 0) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡æœ¬å…ƒç´ ', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            if (!rect.texts || selectedTextIndex >= rect.texts.length) {
                showStatus('é€‰ä¸­çš„æ–‡æœ¬ä¸å­˜åœ¨', 'error');
                return;
            }

            // æ ‡è®°çŸ©å½¢ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼ï¼Œé˜²æ­¢ä»é»˜è®¤é…ç½®æ¢å¤æ–‡æœ¬
            rect.custom_text_mode = true;
            console.log(`çŸ©å½¢ ${selectedRectIndex} è®¾ç½®ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼ï¼Œé˜²æ­¢æ–‡æœ¬æ¢å¤`);

            rect.texts.splice(selectedTextIndex, 1);
            selectedTextIndex = -1;

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬å·²åˆ é™¤', 'success');
        }

        // è‡ªåŠ¨æ’åˆ—æ–‡æœ¬
        function autoArrangeTexts() {
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (rect.texts && rect.texts.length > 0) {
                    // æ ¹æ®æ–‡æœ¬ç±»å‹åˆ†ç»„æ’åˆ—
                    const typePositions = {
                        0: { x: 0.5, y: 0.2 },   // WORD - é¡¶éƒ¨ä¸­å¿ƒ
                        1: { x: 0.3, y: 0.4 },   // PHONETIC - å·¦ä¾§
                        2: { x: 0.5, y: 0.6 },   // DEFINITION - ä¸­éƒ¨
                        3: { x: 0.5, y: 0.8 }    // TRANSLATION - åº•éƒ¨
                    };

                    rect.texts.forEach((text, textIndex) => {
                        const typePos = typePositions[text.content_type] || { x: 0.5, y: 0.5 };

                        // å¦‚æœæœ‰å¤šä¸ªç›¸åŒç±»å‹çš„æ–‡æœ¬ï¼Œç¨å¾®é”™å¼€ä½ç½®
                        const sameTypeCount = rect.texts.filter(t => t.content_type === text.content_type).length;
                        const sameTypeIndex = rect.texts.filter((t, i) => i <= textIndex && t.content_type === text.content_type).length - 1;

                        const offset = sameTypeCount > 1 ? (sameTypeIndex - (sameTypeCount - 1) / 2) * 0.1 : 0;

                        text.rel_x = Math.max(0.0, Math.min(1.0, typePos.x + offset));
                        text.rel_y = Math.max(0.0, Math.min(1.0, typePos.y));
                    });
                }
            });

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬è‡ªåŠ¨æ’åˆ—å®Œæˆ', 'success');
        }

        // ===== é€‰æ‹©çŠ¶æ€å˜é‡ =====
        let selectedTextIndex = -1;

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = 'status-message status-' + type;
            statusDiv.style.display = 'block';

            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // è·å–å½“å‰å¸ƒå±€
        function getCurrentLayout() {
            console.log('å¼€å§‹ç”Ÿæˆå¸ƒå±€æ•°æ®...');

            // ç¡®ä¿æ‰€æœ‰å›¾æ ‡æ•°æ®éƒ½æ˜¯æœ€æ–°çš„
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                console.log(`å¤„ç†çŸ©å½¢ ${rectIndex}: ä½ç½®(${rect.x},${rect.y}), å°ºå¯¸(${rect.width}x${rect.height})`);

                if (rect.icons && Array.isArray(rect.icons)) {
                    rect.icons.forEach((icon, iconIndex) => {
                        // ä»DOMå…ƒç´ è·å–æœ€æ–°ä½ç½®å’Œå°ºå¯¸
                        const iconDiv = document.querySelector(
                            `.icon-hollow-rect[data-rect-index="${rectIndex}"][data-icon-index="${iconIndex}"]`
                        );
                        if (iconDiv) {
                            // è·å–DOMä¸­çš„å®é™…ä½ç½®å’Œå°ºå¯¸
                            const domX = parseInt(iconDiv.style.left) || 0;
                            const domY = parseInt(iconDiv.style.top) || 0;
                            const domWidth = parseInt(iconDiv.style.width) || 30;
                            const domHeight = parseInt(iconDiv.style.height) || 30;

                            console.log(`  çŸ©å½¢ ${rectIndex} å›¾æ ‡ ${iconIndex}:`);
                            console.log(`    DOMä½ç½®: (${domX},${domY}), å°ºå¯¸: ${domWidth}x${domHeight}`);

                            // å­˜å‚¨æ˜¾ç¤ºä½ç½®å’Œå°ºå¯¸
                            icon.display_x = Number(domX);
                            icon.display_y = Number(domY);
                            icon.display_width = Number(domWidth);
                            icon.display_height = Number(domHeight);

                            // é‡æ–°è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆä½¿ç”¨å›¾æ ‡å·¦ä¸Šè§’ï¼‰
                            if (rect.width > 0 && rect.height > 0) {
                                // ä½¿ç”¨å›¾æ ‡å·¦ä¸Šè§’è®¡ç®—ç›¸å¯¹ä½ç½®
                                let rel_x = (domX - rect.x) / rect.width;
                                let rel_y = (domY - rect.y) / rect.height;

                                // ç¡®ä¿åœ¨0-1èŒƒå›´å†…
                                rel_x = Math.max(0, Math.min(1, rel_x));
                                rel_y = Math.max(0, Math.min(1, rel_y));

                                // ä¿ç•™ä¸¤ä½å°æ•°ï¼Œå››èˆäº”å…¥
                                rel_x = Math.round(rel_x * 100) / 100;
                                rel_y = Math.round(rel_y * 100) / 100;

                                // ä¿å­˜åˆ°å›¾æ ‡æ•°æ®ä¸­
                                icon.rel_x = rel_x;
                                icon.rel_y = rel_y;

                                console.log(`    ç›¸å¯¹ä½ç½®: (${rel_x},${rel_y}) ä¿ç•™ä¸¤ä½å°æ•°`);
                            }

                            // æ¸…ç†ä¸å¿…è¦çš„å±æ€§
                            delete icon.original_x;
                            delete icon.original_y;
                            delete icon.original_width;
                            delete icon.original_height;
                        } else {
                            console.warn(`æ‰¾ä¸åˆ°çŸ©å½¢ ${rectIndex} çš„å›¾æ ‡ ${iconIndex} çš„DOMå…ƒç´ `);
                        }
                    });
                }

                // æ¸…ç†çŸ©å½¢çš„ä¸å¿…è¦å±æ€§
                delete rect.original_x;
                delete rect.original_y;
                delete rect.original_width;
                delete rect.original_height;
            });

            // ç®€åŒ–æ•°æ®ç»“æ„ï¼Œåªå‘é€æœåŠ¡å™¨éœ€è¦çš„å­—æ®µ
            const simplifiedLayout = {
                screen_width: currentLayout.screen.width,
                screen_height: currentLayout.screen.height,
                rectangles: currentLayout.rectangles.map((rect, rectIdx) => ({
                    x: Number(rect.x),
                    y: Number(rect.y),
                    width: Number(rect.width),
                    height: Number(rect.height),
                    icon_count: Number(rect.icons?.length || 0),
                    text_count: Number(rect.texts?.length || 0),
                    icons: rect.icons?.map(icon => ({
                        icon_index: Number(icon.icon_index),
                        // è¿™é‡Œç›´æ¥ä½¿ç”¨å·²ç»ä¿ç•™ä¸€ä½å°æ•°çš„rel_xå’Œrel_y
                        rel_x: Number(icon.rel_x),
                        rel_y: Number(icon.rel_y),
                        display_x: Number(icon.display_x),
                        display_y: Number(icon.display_y),
                        display_width: Number(icon.display_width),
                        display_height: Number(icon.display_height),
                        // æ·»åŠ rect_indexå­—æ®µï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä½¿ç”¨å½“å‰çŸ©å½¢ç´¢å¼•
                        rect_index: Number(icon.rect_index !== undefined ? icon.rect_index : rectIdx)
                    })) || [],
                    texts: rect.texts?.map(text => ({
                        content_type: Number(text.content_type || 0),
                        content: text.content || '',
                        rel_x: Number(text.rel_x || 0.5),
                        rel_y: Number(text.rel_y || 0.5),
                        font_size: Number(text.font_size || 16),
                        h_align: Number(text.h_align || 1),
                        v_align: Number(text.v_align || 1),
                        // æ·»åŠ rect_indexå­—æ®µï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä½¿ç”¨å½“å‰çŸ©å½¢ç´¢å¼•
                        rect_index: Number(text.rect_index !== undefined ? text.rect_index : rectIdx)
                    })) || [],
                    // æ·»åŠ custom_text_modeå­—æ®µï¼Œç”¨äºé˜²æ­¢æ–‡æœ¬æ¢å¤
                    // å¦‚æœæœ‰è‡ªå®šä¹‰æ–‡æœ¬ï¼Œæˆ–è€…æ˜¯åŸæœ¬æœ‰é»˜è®¤æ–‡æœ¬çš„çŸ©å½¢(2,4,5,8)ä¸”æ–‡æœ¬è¢«æ¸…ç©ºï¼Œåˆ™è®¾ä¸ºè‡ªå®šä¹‰æ¨¡å¼
                    custom_text_mode: Boolean(rect.custom_text_mode ||
                        (rect.texts && rect.texts.length > 0) ||
                        (rect.texts && rect.texts.length === 0 && [2, 4, 5, 8].includes(rectIdx)))
                    ,
                    // å‘é€ç„¦ç‚¹æ¨¡å¼ç»™è®¾å¤‡ï¼ˆæ•´æ•°æšä¸¾ï¼‰
                    focus_mode: Number(rect.focus_mode || 0),
                    // å‘é€å½“å‰ç»‘å®šçš„åŠ¨ä½œIDï¼ˆå¦‚ä¸ºç©ºå­—ç¬¦ä¸²åˆ™è¡¨ç¤ºå–æ¶ˆç»‘å®šï¼‰
                    on_confirm_action: rect.on_confirm_action || ''
                })),
                status_rect_index: Number(currentLayout.status_rect_index || 0)
            };

            console.log('ç®€åŒ–çš„å¸ƒå±€æ•°æ®:', JSON.stringify(simplifiedLayout, null, 2));

            // éªŒè¯ä¿ç•™ä¸€ä½å°æ•°çš„æ•ˆæœ
            simplifiedLayout.rectangles.forEach((rect, i) => {
                if (rect.icons && rect.icons.length > 0) {
                    console.log(`çŸ©å½¢ ${i} å›¾æ ‡ç›¸å¯¹ä½ç½®:`);
                    rect.icons.forEach((icon, j) => {
                        console.log(`  å›¾æ ‡ ${j}: rel_x=${icon.rel_x}, rel_y=${icon.rel_y}`);
                    });
                }
            });

            return simplifiedLayout;
        }
        // éªŒè¯å¸ƒå±€æ•°æ®
        function validateLayoutData(layoutData) {
            const errors = [];

            if (!layoutData) {
                errors.push('å¸ƒå±€æ•°æ®ä¸ºç©º');
                return errors;
            }

            // éªŒè¯å±å¹•å°ºå¯¸
            if (!layoutData.screen_width || !layoutData.screen_height) {
                errors.push('å±å¹•å°ºå¯¸æ•°æ®ä¸å®Œæ•´');
            }

            if (layoutData.screen_width <= 0 || layoutData.screen_height <= 0) {
                errors.push('å±å¹•å°ºå¯¸å¿…é¡»å¤§äº0');
            }

            // éªŒè¯çŸ©å½¢æ•°æ®
            if (!Array.isArray(layoutData.rectangles)) {
                errors.push('rectangles å¿…é¡»æ˜¯ä¸€ä¸ªæ•°ç»„');
                return errors;
            }

            layoutData.rectangles.forEach((rect, index) => {
                if (!rect || typeof rect !== 'object') {
                    errors.push(`çŸ©å½¢ ${index} æ•°æ®æ ¼å¼é”™è¯¯`);
                    return;
                }

                // éªŒè¯å¿…éœ€å­—æ®µ
                const requiredFields = ['x', 'y', 'width', 'height'];
                requiredFields.forEach(field => {
                    if (rect[field] === undefined || rect[field] === null) {
                        errors.push(`çŸ©å½¢ ${index} ç¼ºå°‘ ${field} å­—æ®µ`);
                    } else if (typeof rect[field] !== 'number' || isNaN(rect[field])) {
                        errors.push(`çŸ©å½¢ ${index} çš„ ${field} å¿…é¡»æ˜¯æ•°å­—`);
                    } else if (rect[field] < 0) {
                        errors.push(`çŸ©å½¢ ${index} çš„ ${field} ä¸èƒ½ä¸ºè´Ÿæ•°`);
                    }
                });

                // éªŒè¯å›¾æ ‡æ•°æ®
                if (rect.icons && Array.isArray(rect.icons)) {
                    rect.icons.forEach((icon, iconIndex) => {
                        if (!icon || typeof icon !== 'object') {
                            errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} æ•°æ®æ ¼å¼é”™è¯¯`);
                            return;
                        }

                        // éªŒè¯å›¾æ ‡å¿…éœ€å­—æ®µ
                        if (icon.icon_index === undefined || icon.icon_index === null) {
                            errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} ç¼ºå°‘ icon_index å­—æ®µ`);
                        }

                        // éªŒè¯åæ ‡å’Œå°ºå¯¸
                        const iconFields = ['rel_x', 'rel_y', 'display_x', 'display_y', 'display_width', 'display_height'];
                        iconFields.forEach(field => {
                            if (icon[field] !== undefined && (typeof icon[field] !== 'number' || isNaN(icon[field]))) {
                                errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} çš„ ${field} å¿…é¡»æ˜¯æ•°å­—`);
                            }
                        });
                    });
                }
            });

            return errors;
        }
        // ä¿®æ”¹ applyToDevice å‡½æ•°ï¼Œæ·»åŠ éªŒè¯
        async function applyToDevice() {
            try {
                const endpoints = getApiEndpoints();
                const screenName = currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢';
                showLoading('æ­£åœ¨åº”ç”¨' + screenName + 'å¸ƒå±€åˆ°è®¾å¤‡...');
                const layoutData = getCurrentLayout();

                console.log('æ­£åœ¨å‘é€' + screenName + 'å¸ƒå±€æ•°æ®åˆ°è®¾å¤‡:', layoutData);

                // éªŒè¯æ•°æ®
                const validationErrors = validateLayoutData(layoutData);
                if (validationErrors.length > 0) {
                    console.error('æ•°æ®éªŒè¯å¤±è´¥:', validationErrors);
                    showStatus('æ•°æ®éªŒè¯å¤±è´¥: ' + validationErrors.join(', '), 'error');
                    return;
                }

                const response = await fetch(endpoints.set, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(layoutData)
                });

                console.log('å“åº”çŠ¶æ€:', response.status, response.statusText);

                if (response.ok) {
                    const result = await response.json();
                    console.log('æœåŠ¡å™¨å“åº”:', result);
                    showStatus('å¸ƒå±€å·²æˆåŠŸåº”ç”¨åˆ°è®¾å¤‡', 'success');
                } else {
                    // å°è¯•è·å–é”™è¯¯è¯¦æƒ…
                    let errorDetail = '';
                    try {
                        const errorData = await response.text();
                        console.error('é”™è¯¯å“åº”å†…å®¹:', errorData);

                        // å°è¯•è§£æJSONé”™è¯¯
                        try {
                            const errorJson = JSON.parse(errorData);
                            errorDetail = ': ' + JSON.stringify(errorJson);
                        } catch {
                            errorDetail = ': ' + errorData.substring(0, 100);
                        }
                    } catch (e) {
                        errorDetail = 'ï¼Œæ— æ³•è·å–é”™è¯¯è¯¦æƒ…';
                    }
                    showStatus(`åº”ç”¨å¸ƒå±€å¤±è´¥ (HTTP ${response.status}${errorDetail})`, 'error');
                }
            } catch (error) {
                console.error('Error applying layout:', error);
                showStatus('è¿æ¥è®¾å¤‡å¤±è´¥: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }
        // æµ‹è¯•æ•°æ®æ ¼å¼
        function testLayoutData() {
            const layoutData = getCurrentLayout();

            // éªŒè¯æ•°æ®
            const validationErrors = validateLayoutData(layoutData);

            if (validationErrors.length > 0) {
                console.error('æ•°æ®éªŒè¯å¤±è´¥:', validationErrors);
                alert('æ•°æ®éªŒè¯å¤±è´¥:\n' + validationErrors.join('\n'));
            } else {
                console.log('æ•°æ®éªŒè¯é€šè¿‡:', layoutData);

                // æ˜¾ç¤ºæ•°æ®ç»Ÿè®¡
                const rectCount = layoutData.rectangles.length;
                let iconCount = 0;
                layoutData.rectangles.forEach(rect => {
                    if (rect.icons && Array.isArray(rect.icons)) {
                        iconCount += rect.icons.length;
                    }
                });

                alert(`æ•°æ®éªŒè¯é€šè¿‡ï¼\nçŸ©å½¢æ•°: ${rectCount}\nå›¾æ ‡æ•°: ${iconCount}\nå±å¹•å°ºå¯¸: ${layoutData.screen_width}Ã—${layoutData.screen_height}`);
            }
        }
        // ä¿å­˜å¸ƒå±€åˆ°æ–‡ä»¶
        function saveLayoutToFile() {
            const layoutData = getCurrentLayout();
            const dataStr = JSON.stringify(layoutData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const downloadAnchor = document.createElement('a');
            downloadAnchor.setAttribute('href', URL.createObjectURL(dataBlob));
            downloadAnchor.setAttribute('download', 'ink_screen_layout.json');
            document.body.appendChild(downloadAnchor);
            downloadAnchor.click();
            document.body.removeChild(downloadAnchor);

            showStatus('å¸ƒå±€å·²ä¿å­˜åˆ°æ–‡ä»¶', 'success');
        }

        // ä»æ–‡ä»¶åŠ è½½å¸ƒå±€
        function loadLayoutFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const layout = JSON.parse(e.target.result);
                        currentLayout = layout;
                        renderLayout(currentLayout);
                        showStatus('å¸ƒå±€ä»æ–‡ä»¶åŠ è½½æˆåŠŸ', 'success');
                    } catch (error) {
                        showStatus('æ–‡ä»¶æ ¼å¼é”™è¯¯', 'error');
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        // é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€
        function resetToDefault() {
            if (confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€å—ï¼Ÿ')) {
                setDefaultLayout();
                renderLayout(currentLayout);
                showStatus('å·²é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€', 'success');
            }
        }

        // åˆ‡æ¢ç½‘æ ¼æ˜¾ç¤º
        function toggleGrid() {
            const gridLines = document.getElementById('gridLines');
            const show = document.getElementById('showGrid').checked;
            if (gridLines) {
                gridLines.style.display = show ? 'block' : 'none';
            }
        }

        // æ˜¾ç¤ºåŠ è½½é®ç½©
        function showLoading(text = 'å¤„ç†ä¸­...') {
            const overlay = document.getElementById('loadingOverlay');
            const textEl = document.getElementById('loadingText');
            if (overlay && textEl) {
                textEl.textContent = text;
                overlay.style.display = 'flex';
            }
        }

        // éšè—åŠ è½½é®ç½©
        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // é”®ç›˜ç§»åŠ¨é€‰ä¸­é¡¹
        document.addEventListener('keydown', function (e) {
            // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸æ‰§è¡Œç§»åŠ¨
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            const step = e.shiftKey ? 10 : 1; // æŒ‰ä½ShiftåŠ é€Ÿç§»åŠ¨

            if (selectedRectIndex >= 0) {
                if (selectedIconIndex >= 0) {
                    // ç§»åŠ¨å›¾æ ‡
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    const icon = rect.icons[selectedIconIndex];
                    const iconDiv = document.querySelector(`.icon-hollow-rect[data-rect-index="${selectedRectIndex}"][data-icon-index="${selectedIconIndex}"]`);

                    if (icon && iconDiv) {
                        let newX = parseInt(iconDiv.style.left);
                        let newY = parseInt(iconDiv.style.top);
                        let moved = false;

                        switch (e.key) {
                            case 'ArrowLeft': newX -= step; moved = true; break;
                            case 'ArrowRight': newX += step; moved = true; break;
                            case 'ArrowUp': newY -= step; moved = true; break;
                            case 'ArrowDown': newY += step; moved = true; break;
                        }

                        if (moved) {
                            e.preventDefault();
                            // é™åˆ¶åœ¨çŸ©å½¢èŒƒå›´å†…
                            const iconWidth = parseInt(iconDiv.style.width);
                            const iconHeight = parseInt(iconDiv.style.height);
                            newX = Math.max(rect.x, Math.min(newX, rect.x + rect.width - iconWidth));
                            newY = Math.max(rect.y, Math.min(newY, rect.y + rect.height - iconHeight));

                            iconDiv.style.left = newX + 'px';
                            iconDiv.style.top = newY + 'px';

                            // æ›´æ–°æ•°æ®
                            icon.display_x = newX;
                            icon.display_y = newY;
                            icon.rel_x = (newX - rect.x) / rect.width;
                            icon.rel_y = (newY - rect.y) / rect.height;

                            updateSelectedRectInfo();
                        }
                    }
                } else {
                    // ç§»åŠ¨çŸ©å½¢
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    const rectDiv = document.querySelector(`.rect[data-index="${selectedRectIndex}"]`);

                    if (rect && rectDiv) {
                        let newX = rect.x;
                        let newY = rect.y;
                        let moved = false;

                        switch (e.key) {
                            case 'ArrowLeft': newX -= step; moved = true; break;
                            case 'ArrowRight': newX += step; moved = true; break;
                            case 'ArrowUp': newY -= step; moved = true; break;
                            case 'ArrowDown': newY += step; moved = true; break;
                        }

                        if (moved) {
                            e.preventDefault();
                            // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                            newX = Math.max(0, Math.min(newX, currentLayout.screen.width - rect.width));
                            newY = Math.max(0, Math.min(newY, currentLayout.screen.height - rect.height));

                            // æ£€æŸ¥ç¢°æ’
                            const tempRect = { ...rect, x: newX, y: newY };
                            if (!checkRectCollision(tempRect, selectedRectIndex)) {
                                rect.x = newX;
                                rect.y = newY;
                                rect.original_x = newX;
                                rect.original_y = newY;

                                rectDiv.style.left = newX + 'px';
                                rectDiv.style.top = newY + 'px';

                                // ç§»åŠ¨çŸ©å½¢å†…çš„å›¾æ ‡
                                if (rect.icons) {
                                    rect.icons.forEach((icon, idx) => {
                                        const iconDiv = document.querySelector(`.icon-hollow-rect[data-rect-index="${selectedRectIndex}"][data-icon-index="${idx}"]`);
                                        if (iconDiv) {
                                            // é‡æ–°è®¡ç®—å›¾æ ‡ç»å¯¹ä½ç½®
                                            const iconX = rect.x + icon.rel_x * rect.width;
                                            const iconY = rect.y + icon.rel_y * rect.height;
                                            icon.display_x = iconX;
                                            icon.display_y = iconY;
                                            iconDiv.style.left = iconX + 'px';
                                            iconDiv.style.top = iconY + 'px';
                                        }
                                    });
                                }

                                updateSelectedRectInfo();
                            }
                        }
                    }
                }
            }
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        // ç‚¹å‡»å±å¹•ç©ºç™½å¤„å–æ¶ˆé€‰ä¸­
        document.getElementById('screenContainer').onclick = function (e) {
            if (e.target === this || e.target.className === 'grid-lines' || e.target.id === 'alignmentGuides') {
                selectedRectIndex = -1;
                selectedIconIndex = -1;

                // æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.rect').forEach(rect => {
                    rect.classList.remove('selected');
                });
                document.querySelectorAll('.icon-hollow-rect').forEach(icon => {
                    icon.classList.remove('selected');
                });

                updateSelectedRectInfo();
            }
        };

        // ==================== ç„¦ç‚¹çŸ©å½¢é…ç½®åŠŸèƒ½ ====================

        let focusableRects = [];  // å­˜å‚¨å¯ç„¦ç‚¹çŸ©å½¢çš„ç´¢å¼•æ•°ç»„

        /**
         * æ›´æ–°ç„¦ç‚¹é…ç½®å¤é€‰æ¡†åˆ—è¡¨
         */
        function updateFocusConfigCheckboxes() {
            const container = document.getElementById('focusableRectsCheckboxes');
            if (!container) return;

            container.innerHTML = '';

            const rectCount = currentLayout.rectangles.length;
            if (rectCount === 0) {
                container.innerHTML = '\u003cp style="color: #999; text-align: center;"\u003eå½“å‰æ²¡æœ‰çŸ©å½¢\u003c/p\u003e';
                return;
            }

            for (let i = 0; i < rectCount; i++) {
                const rect = currentLayout.rectangles[i];
                const isChecked = focusableRects.includes(i);

                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; align-items: center;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `focusRect${i}`;
                checkbox.value = i;
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
                checkbox.onchange = function () {
                    updateFocusableRectsArray();
                };

                const label = document.createElement('label');
                label.htmlFor = `focusRect${i}`;
                label.style.cssText = 'cursor: pointer; flex: 1; font-size: 14px;';
                label.innerHTML = `\u003cstrong\u003eçŸ©å½¢ ${i}\u003c/strong\u003e - (${rect.x}, ${rect.y}) ${rect.width}Ã—${rect.height}`;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            }
        }

        /**
         * æ›´æ–°å¯ç„¦ç‚¹çŸ©å½¢æ•°ç»„
         */
        function updateFocusableRectsArray() {
            focusableRects = [];
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]:checked');
            checkboxes.forEach(cb => {
                focusableRects.push(parseInt(cb.value));
            });

            console.log('å¯ç„¦ç‚¹çŸ©å½¢å·²æ›´æ–°:', focusableRects);
            updateFocusConfigInfo();
            updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
        }

        /**
         * å…¨é€‰ç„¦ç‚¹çŸ©å½¢
         */
        function selectAllFocusableRects() {
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateFocusableRectsArray();
        }

        /**
         * å…¨ä¸é€‰ç„¦ç‚¹çŸ©å½¢
         */
        function deselectAllFocusableRects() {
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            updateFocusableRectsArray();
        }

        /**
         * æ›´æ–°ç„¦ç‚¹é…ç½®ä¿¡æ¯æ˜¾ç¤º
         */
        function updateFocusConfigInfo() {
            const infoDiv = document.getElementById('focusConfigInfo');
            const statusDiv = document.getElementById('focusConfigStatus');

            if (!infoDiv || !statusDiv) return;

            if (focusableRects.length === 0) {
                statusDiv.style.display = 'none';
                return;
            }

            statusDiv.style.display = 'block';
            infoDiv.innerHTML = `å…± ${focusableRects.length} ä¸ªå¯ç„¦ç‚¹çŸ©å½¢: [${focusableRects.join(', ')}]`;
        }

        /**
         * ä¿å­˜ç„¦ç‚¹é…ç½®åˆ°è®¾å¤‡
         */
        async function saveFocusConfig() {
            if (focusableRects.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯ç„¦ç‚¹çŸ©å½¢ï¼');
                return;
            }

            const config = {
                count: focusableRects.length,
                focusable_indices: focusableRects,
                screen_type: currentScreenMode  // æ·»åŠ ç•Œé¢ç±»å‹ (main æˆ– vocab)
            };

            try {
                showLoading('æ­£åœ¨ä¿å­˜' + (currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢') + 'ç„¦ç‚¹é…ç½®...');

                const response = await fetch('/setfocusconfig', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                hideLoading();

                if (response.ok) {
                    const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                    showStatus(screenName + 'ç„¦ç‚¹é…ç½®å·²ä¿å­˜åˆ°è®¾å¤‡ï¼', 'success');
                    console.log(screenName + 'ç„¦ç‚¹é…ç½®å·²ä¿å­˜:', config);
                } else {
                    showStatus('ä¿å­˜ç„¦ç‚¹é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('ä¿å­˜ç„¦ç‚¹é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('ä¿å­˜ç„¦ç‚¹é…ç½®é”™è¯¯:', error);
            }
        }

        /**
         * ä»è®¾å¤‡åŠ è½½ç„¦ç‚¹é…ç½®
         */
        async function loadFocusConfig() {
            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨åŠ è½½' + screenName + 'ç„¦ç‚¹é…ç½®...');

                const response = await fetch('/getfocusconfig?screen_type=' + currentScreenMode);
                hideLoading();

                if (response.ok) {
                    const config = await response.json();

                    if (config && config.focusable_indices && Array.isArray(config.focusable_indices)) {
                        focusableRects = config.focusable_indices;
                        updateFocusConfigCheckboxes();
                        updateFocusConfigInfo();
                        updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
                        showStatus(screenName + `ç„¦ç‚¹é…ç½®å·²åŠ è½½ï¼š${config.count} ä¸ªå¯ç„¦ç‚¹çŸ©å½¢`, 'success');
                        console.log(screenName + 'ç„¦ç‚¹é…ç½®å·²åŠ è½½:', config);
                    } else {
                        showStatus('è®¾å¤‡ä¸Šæ²¡æœ‰' + screenName + 'ç„¦ç‚¹é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®', 'error');
                        // é»˜è®¤æ‰€æœ‰çŸ©å½¢éƒ½å¯ç„¦ç‚¹
                        focusableRects = Array.from({ length: currentLayout.rectangles.length }, (_, i) => i);
                        updateFocusConfigCheckboxes();
                        updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
                    }
                } else {
                    showStatus('åŠ è½½' + screenName + 'ç„¦ç‚¹é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('åŠ è½½ç„¦ç‚¹é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('åŠ è½½ç„¦ç‚¹é…ç½®é”™è¯¯:', error);
            }
        }

        // ==================== å­æ•°ç»„é…ç½®åŠŸèƒ½ ====================

        let subArrayConfig = {};  // å­˜å‚¨å­æ•°ç»„é…ç½® { parent_index: [sub_indices...] }

        /**
         * æ›´æ–°æ¯æ•°ç»„çŸ©å½¢é€‰æ‹©ä¸‹æ‹‰æ¡†
         */
        function updateSubArrayParentSelect() {
            const select = document.getElementById('subArrayParentSelect');
            if (!select) return;

            // ä¿å­˜å½“å‰é€‰ä¸­å€¼
            const currentValue = select.value;

            // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
            select.innerHTML = '<option value="">-- è¯·é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ --</option>';

            // ä»ç„¦ç‚¹é…ç½®ä¸­è·å–æ¯æ•°ç»„çŸ©å½¢
            focusableRects.forEach((rectIndex, arrayIndex) => {
                const rect = currentLayout.rectangles[rectIndex];
                if (rect) {
                    const option = document.createElement('option');
                    option.value = arrayIndex;
                    option.textContent = `æ¯æ•°ç»„[${arrayIndex}] - çŸ©å½¢${rectIndex} (${rect.width}Ã—${rect.height})`;
                    select.appendChild(option);
                }
            });

            // æ¢å¤é€‰ä¸­å€¼
            if (currentValue !== '') {
                select.value = currentValue;
            }
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®ç•Œé¢
         */
        function updateSubArrayConfig() {
            const select = document.getElementById('subArrayParentSelect');
            const checkboxContainer = document.getElementById('subArrayCheckboxes');

            if (!select || !checkboxContainer) return;

            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) {
                checkboxContainer.style.display = 'none';
                return;
            }

            checkboxContainer.style.display = 'block';
            checkboxContainer.innerHTML = '';

            const parentRectIndex = focusableRects[parentIndex];

            // æ˜¾ç¤ºå¯é€‰çš„å­çŸ©å½¢ï¼ˆæ‰€æœ‰æœ‰æ•ˆçŸ©å½¢ï¼Œæ’é™¤å½“å‰æ¯çŸ©å½¢ï¼‰
            const rectCount = currentLayout.rectangles.length;
            const currentSubArray = subArrayConfig[parentIndex] || [];

            for (let i = 0; i < rectCount; i++) {
                const rect = currentLayout.rectangles[i];
                if (!rect || rect.width <= 0 || rect.height <= 0) continue;
                if (i === parentRectIndex) continue;  // æ’é™¤æ¯çŸ©å½¢æœ¬èº«

                const isChecked = currentSubArray.includes(i);

                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; align-items: center;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `subRect_${parentIndex}_${i}`;
                checkbox.value = i;
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
                checkbox.onchange = function() {
                    updateSubArrayConfigData();
                };

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.style.cssText = 'cursor: pointer; flex: 1; font-size: 14px;';
                label.innerHTML = `<strong>çŸ©å½¢ ${i}</strong> - (${rect.x}, ${rect.y}) ${rect.width}Ã—${rect.height}`;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                checkboxContainer.appendChild(checkboxDiv);
            }

            updateSubArrayConfigInfo();
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®æ•°æ®
         */
        function updateSubArrayConfigData() {
            const select = document.getElementById('subArrayParentSelect');
            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) return;

            const checkboxes = document.querySelectorAll(`#subArrayCheckboxes input[type="checkbox"]:checked`);
            const subIndices = [];

            checkboxes.forEach(cb => {
                subIndices.push(parseInt(cb.value));
            });

            if (subIndices.length > 0) {
                subArrayConfig[parentIndex] = subIndices;
            } else {
                delete subArrayConfig[parentIndex];
            }

            updateSubArrayConfigInfo();
            console.log('å­æ•°ç»„é…ç½®å·²æ›´æ–°:', subArrayConfig);
        }

        /**
         * æ¸…ç©ºå½“å‰é€‰ä¸­çš„å­æ•°ç»„
         */
        function clearSubArray() {
            const select = document.getElementById('subArrayParentSelect');
            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¯æ•°ç»„çŸ©å½¢ï¼');
                return;
            }

            delete subArrayConfig[parentIndex];

            // å–æ¶ˆæ‰€æœ‰å¤é€‰æ¡†
            const checkboxes = document.querySelectorAll('#subArrayCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);

            updateSubArrayConfigInfo();
            showStatus(`å·²æ¸…ç©ºæ¯æ•°ç»„[${parentIndex}]çš„å­æ•°ç»„é…ç½®`, 'success');
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®ä¿¡æ¯æ˜¾ç¤º
         */
        function updateSubArrayConfigInfo() {
            const statusDiv = document.getElementById('subArrayConfigStatus');
            const infoDiv = document.getElementById('subArrayConfigInfo');

            if (!statusDiv || !infoDiv) return;

            const configCount = Object.keys(subArrayConfig).length;

            if (configCount === 0) {
                statusDiv.style.display = 'none';
                return;
            }

            statusDiv.style.display = 'block';

            let html = `<div style="font-size: 12px;">`;
            html += `<p style="margin-bottom: 8px;">å·²é…ç½® ${configCount} ä¸ªæ¯æ•°ç»„å…ƒç´ çš„å­æ•°ç»„ï¼š</p>`;

            for (const [parentIdx, subIndices] of Object.entries(subArrayConfig)) {
                const parentRectIndex = focusableRects[parseInt(parentIdx)];
                html += `<div style="margin: 5px 0; padding: 5px; background: white; border-radius: 3px;">`;
                html += `<strong>æ¯[${parentIdx}]çŸ©å½¢${parentRectIndex}</strong> â†’ å­æ•°ç»„: [${subIndices.join(', ')}] (${subIndices.length}ä¸ª)`;
                html += `</div>`;
            }

            html += `</div>`;
            infoDiv.innerHTML = html;
        }

        /**
         * ä¿å­˜å­æ•°ç»„é…ç½®åˆ°è®¾å¤‡
         */
        async function saveSubArrayConfig() {
            if (Object.keys(subArrayConfig).length === 0) {
                alert('å½“å‰æ²¡æœ‰é…ç½®ä»»ä½•å­æ•°ç»„ï¼');
                return;
            }

            // è½¬æ¢ä¸ºè®¾å¤‡éœ€è¦çš„æ ¼å¼
            const configData = {
                sub_arrays: [],
                screen_type: currentScreenMode  // æ·»åŠ ç•Œé¢ç±»å‹
            };

            for (const [parentIdx, subIndices] of Object.entries(subArrayConfig)) {
                configData.sub_arrays.push({
                    parent_index: parseInt(parentIdx),
                    sub_indices: subIndices,
                    sub_count: subIndices.length
                });
            }

            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨ä¿å­˜' + screenName + 'å­æ•°ç»„é…ç½®...');

                const response = await fetch('/setsubarrayconfig', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configData)
                });

                hideLoading();

                if (response.ok) {
                    showStatus('å­æ•°ç»„é…ç½®å·²ä¿å­˜åˆ°è®¾å¤‡ï¼', 'success');
                    console.log('å­æ•°ç»„é…ç½®å·²ä¿å­˜:', configData);
                } else {
                    showStatus('ä¿å­˜å­æ•°ç»„é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('ä¿å­˜å­æ•°ç»„é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('ä¿å­˜å­æ•°ç»„é…ç½®é”™è¯¯:', error);
            }
        }

        /**
         * ä»è®¾å¤‡åŠ è½½å­æ•°ç»„é…ç½®
         */
        async function loadSubArrayConfig() {
            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨åŠ è½½' + screenName + 'å­æ•°ç»„é…ç½®...');

                const response = await fetch('/getsubarrayconfig?screen_type=' + currentScreenMode);
                hideLoading();

                if (response.ok) {
                    const data = await response.json();

                    if (data && data.sub_arrays && Array.isArray(data.sub_arrays)) {
                        subArrayConfig = {};

                        data.sub_arrays.forEach(item => {
                            if (item.parent_index !== undefined && item.sub_indices && Array.isArray(item.sub_indices)) {
                                subArrayConfig[item.parent_index] = item.sub_indices;
                            }
                        });

                        updateSubArrayParentSelect();
                        updateSubArrayConfig();
                        updateSubArrayConfigInfo();

                        showStatus(screenName + `å­æ•°ç»„é…ç½®å·²åŠ è½½ï¼š${data.sub_arrays.length} ä¸ªé…ç½®`, 'success');
                        console.log(screenName + 'å­æ•°ç»„é…ç½®å·²åŠ è½½:', subArrayConfig);
                    } else {
                        showStatus('è®¾å¤‡ä¸Šæ²¡æœ‰' + screenName + 'å­æ•°ç»„é…ç½®', 'error');
                        subArrayConfig = {};
                    }
                } else {
                    showStatus('åŠ è½½' + screenName + 'å­æ•°ç»„é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('åŠ è½½å­æ•°ç»„é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('åŠ è½½å­æ•°ç»„é…ç½®é”™è¯¯:', error);
            }
        }

    </script>
</body>

</html>