// é¦–å…ˆï¼Œåœ¨CSSä¸­æ·»åŠ ç©ºå¿ƒçŸ©å½¢çš„æ ·å¼
const char* WEB_LAYOUT_HTML = R"rawliteral(
<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="20241215-v2">
    <title>å¢¨æ°´å±å¸ƒå±€ç¼–è¾‘å™¨</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }

        .preview-section {
            flex: 1;
            min-width: 400px;
        }

        .controls-section {
            flex: 1;
            min-width: 300px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .screen-container {
            width: 416px;
            height: 240px;
            border: 3px solid #333;
            background: #fff;
            position: relative;
            margin: 20px auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            user-select: none;
            /* é˜²æ­¢æ‹–åŠ¨æ—¶é€‰ä¸­æ–‡å­— */
        }

        .rect {
            position: absolute;
            border: 2px solid #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            cursor: move;
            transition: all 0.3s;
            z-index: 10;
        }

        .rect:hover {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.2);
            z-index: 15;
        }

        .rect.selected {
            border-color: #FF9800;
            border-width: 3px;
            background: rgba(255, 152, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 152, 0, 0.6);
            z-index: 20;
        }

        /* æ‹–æ‹½ç›®æ ‡çŸ©å½¢é«˜äº®æ ·å¼ */
        .rect.drop-target {
            border-color: #9C27B0;
            border-width: 3px;
            border-style: dashed;
            background: rgba(156, 39, 176, 0.2);
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.4) inset;
            z-index: 18;
        }

        /* è°ƒæ•´å¤§å°çš„æ‰‹æŸ„æ ·å¼ */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background-color: #fff;
            border: 2px solid #2196F3;
            border-radius: 50%;
            z-index: 101;
            display: none;
            /* é»˜è®¤éšè— */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .rect:hover .resize-handle,
        .rect.selected .resize-handle {
            display: block;
        }

        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        .resize-handle.e {
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .resize-handle.s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .resize-handle:hover {
            background-color: #2196F3;
            transform: scale(1.2);
        }

        .resize-handle.e:hover {
            transform: translateY(-50%) scale(1.2);
        }

        .resize-handle.s:hover {
            transform: translateX(-50%) scale(1.2);
        }

        /* åˆ é™¤æŒ‰é’®æ ·å¼ */
        .delete-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
            transition: background 0.3s;
        }

        .delete-btn:hover {
            background-color: #d32f2f;
        }

        /* Canvas å›¾æ ‡æ ·å¼ */
        .icon-canvas {
            transition: all 0.2s ease;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: block;
        }

        .icon-canvas:hover {
            box-shadow: 0 4px 12px rgba(233, 30, 99, 0.4);
            z-index: 60;
        }

        .icon-canvas.selected {
            box-shadow: 0 0 0 2px #2196F3, 0 0 12px #2196F3;
            z-index: 55;
        }

        .icon-canvas.dragging {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
            opacity: 0.95;
        }

        /* æ–‡æœ¬å…ƒç´ æ ·å¼ */
        .text-element {
            font-family: Arial, sans-serif;
            line-height: 1.2;
            z-index: 45;
            transition: all 0.2s ease;
        }

        .text-element.selected {
            border-color: #2196F3 !important;
            border-width: 2px !important;
            border-style: solid !important;
            background-color: rgba(33, 150, 243, 0.2) !important;
            box-shadow: 0 0 0 1px white, 0 0 8px #2196F3;
            z-index: 55;
        }

        .text-element.dragging {
            border-style: solid !important;
            border-width: 2px !important;
            background-color: rgba(156, 39, 176, 0.3) !important;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
            opacity: 0.9;
            z-index: 100;
        }

        .text-element:hover {
            z-index: 50;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 600;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .rect-info {
            background: white;
            border-radius: 5px;
            padding: 15px;
            margin-top: 10px;
            border: 1px solid #ddd;
        }

        .rect-id {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }

        .grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .grid-line {
            position: absolute;
            background: rgba(0, 0, 0, 0.05);
        }

        .grid-line.vertical {
            width: 1px;
            height: 100%;
        }

        .grid-line.horizontal {
            height: 1px;
            width: 100%;
        }

        /* å¯¹é½è¾…åŠ©çº¿ */
        .alignment-guide {
            position: absolute;
            z-index: 200;
            pointer-events: none;
        }

        .alignment-guide.vertical {
            width: 2px;
            background: #2196F3;
            height: 100%;
        }

        .alignment-guide.horizontal {
            height: 2px;
            background: #2196F3;
            width: 100%;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .screen-container {
                width: 100%;
                max-width: 416px;
                height: 240px;
            }
        }

        .bitmap-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>

<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div id="loadingText">å¤„ç†ä¸­...</div>
    </div>

    <!-- ç¯å¢ƒçŠ¶æ€æ¡ -->
    <div id="envStatusBar" style="background: #f5f5f5; padding: 10px 20px; border-bottom: 2px solid #ddd; font-size: 0.9em; color: #666; display: flex; justify-content: space-between; align-items: center;">
        <span id="envStatusText">æ­£åœ¨æ£€æµ‹è¿è¡Œç¯å¢ƒ...</span>
        <span id="envIndicator" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background: #ffb300; margin-left: 10px;"></span>
    </div>

    <div class="container">
        <header>
            <h1>å¢¨æ°´å±å¸ƒå±€ç¼–è¾‘å™¨</h1>
            <p class="subtitle">å¯è§†åŒ–ç¼–è¾‘å¢¨æ°´å±çŸ©å½¢å’Œå›¾æ ‡å¸ƒå±€</p>
            <div style="margin-top: 20px;">
                <label style="font-size: 1.1em; margin-right: 10px;">ç¼–è¾‘ç•Œé¢:</label>
                <select id="screenMode" onchange="switchScreenMode()"
                    style="font-size: 1em; padding: 8px 15px; border-radius: 5px; border: 2px solid white; background: rgba(255,255,255,0.2); color: white; cursor: pointer;">
                    <option value="main">ä¸»ç•Œé¢ (Main Screen)</option>
                    <option value="vocab">å•è¯ç•Œé¢ (Vocabulary Screen)</option>
                </select>
            </div>
        </header>

        <div class="main-content">
            <div class="preview-section">
                <div class="screen-container" id="screenContainer">
                    <!-- ç½‘æ ¼çº¿ -->
                    <div class="grid-lines" id="gridLines"></div>
                    <!-- å¯¹é½è¾…åŠ©çº¿ -->
                    <div id="alignmentGuides"></div>
                    <!-- çŸ©å½¢å’Œå›¾æ ‡ä¼šåŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
                </div>

                <div style="text-align: center; margin-top: 20px;">
                    <p>å±å¹•å°ºå¯¸: <span id="screenSize">416Ã—240</span></p>
                    <p>å½“å‰çŸ©å½¢æ•°: <span id="rectCount">0</span></p>
                    <p>å½“å‰å›¾æ ‡æ•°: <span id="iconCount">0</span></p>
                </div>
            </div>

            <div class="controls-section">
                <div class="control-group">
                    <h3>ğŸ“± å±å¹•è®¾ç½®</h3>
                    <div class="form-group">
                        <label>å±å¹•å®½åº¦ (px)</label>
                        <input type="number" id="screenWidth" value="416" min="100" max="800">
                    </div>
                    <div class="form-group">
                        <label>å±å¹•é«˜åº¦ (px)</label>
                        <input type="number" id="screenHeight" value="240" min="100" max="600">
                    </div>
                    <div class="form-group" style="display: flex; align-items: center; gap: 10px;">
                        <input type="checkbox" id="showGrid" checked onchange="toggleGrid()" style="width: auto;">
                        <label for="showGrid" style="margin: 0; cursor: pointer;">æ˜¾ç¤ºç½‘æ ¼</label>
                    </div>
                    <button class="btn" onclick="updateScreenSize()">æ›´æ–°å±å¹•å°ºå¯¸</button>
                </div>

                <div class="control-group">
                    <h3>ğŸ“ çŸ©å½¢æ“ä½œ</h3>
                    <div class="rect-info" id="selectedRectInfo">
                        æœªé€‰ä¸­ä»»ä½•çŸ©å½¢
                    </div>
                    <div class="form-group">
                        <label>çŸ©å½¢å®½åº¦ (px)</label>
                        <input type="number" id="rectWidth" value="138" min="10" max="416">
                    </div>
                    <div class="form-group">
                        <label>çŸ©å½¢é«˜åº¦ (px)</label>
                        <input type="number" id="rectHeight" value="100" min="10" max="240">
                    </div>
                    <button class="btn" onclick="addRectangle()">æ·»åŠ æ–°çŸ©å½¢</button>
                    <button class="btn btn-warning" onclick="removeSelectedRect()">åˆ é™¤é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn btn-danger" onclick="clearAllRectangles()">æ¸…ç©ºæ‰€æœ‰çŸ©å½¢</button>
                </div>

                <div class="control-group">
                    <h3>ğŸ¯ å›¾æ ‡æ“ä½œ</h3>
                    <div class="form-group">
                        <label>é€‰æ‹©å›¾æ ‡æ–‡ä»¶ (.bin)</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="file" id="iconFileInput" accept=".bin" style="display: none;">
                            <input type="text" id="iconFileName" placeholder="æœªé€‰æ‹©æ–‡ä»¶" readonly style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 5px; background: #f5f5f5;">
                            <button class="btn" onclick="document.getElementById('iconFileInput').click()">ğŸ“ æµè§ˆæ–‡ä»¶</button>
                        </div>
                        <small style="color: #666; margin-top: 5px; display: block;">ä» resource/icon/ æ–‡ä»¶å¤¹ä¸­é€‰æ‹© .bin æ ¼å¼å›¾æ ‡</small>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹Xä½ç½® (0.0-1.0)</label>
                        <input type="number" id="iconRelX" value="0.5" min="0" max="1" step="0.01">
                        <small style="color: #666;">0.5 = ä¸­å¿ƒï¼Œ0.0 = å·¦ä¸Š</small>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹Yä½ç½® (0.0-1.0)</label>
                        <input type="number" id="iconRelY" value="0.5" min="0" max="1" step="0.01">
                        <small style="color: #666;">0.5 = ä¸­å¿ƒï¼Œ0.0 = å·¦ä¸Š</small>
                    </div>
                    <button class="btn" onclick="addIconToSelectedRect()">æ·»åŠ å›¾æ ‡åˆ°é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn" onclick="updateSelectedIconPosition()">æ›´æ–°é€‰ä¸­å›¾æ ‡ä½ç½®</button>
                    <button class="btn btn-warning" onclick="removeSelectedIcon()">åˆ é™¤é€‰ä¸­å›¾æ ‡</button>
                    <button class="btn" onclick="autoArrangeIcons()">è‡ªåŠ¨æ’åˆ—å›¾æ ‡</button>
                    <div
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px;">
                        <strong>æç¤ºï¼š</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>ç‚¹å‡»"æµè§ˆæ–‡ä»¶"ä» resource/icon/ æ–‡ä»¶å¤¹é€‰æ‹© .bin æ ¼å¼å›¾æ ‡</li>
                            <li>æ–‡ä»¶åæ ¼å¼ï¼š{index}_{name}.bin (ä¾‹å¦‚ï¼š0_icon1_62x64.bin)</li>
                            <li>ç›¸å¯¹ä½ç½®åŸºäºå›¾æ ‡<strong>ä¸­å¿ƒç‚¹</strong>ï¼š(0.5, 0.5)è¡¨ç¤ºå›¾æ ‡ä¸­å¿ƒåœ¨çŸ©å½¢ä¸­å¿ƒ</li>
                            <li>ç‚¹å‡»å›¾æ ‡å¯æŸ¥çœ‹å½“å‰ä½ç½®å¹¶æ‰‹åŠ¨è°ƒæ•´</li>
                            <li>æ‹–åŠ¨å›¾æ ‡å¯å®æ—¶è°ƒæ•´ä½ç½®ï¼Œç›¸å¯¹åæ ‡è‡ªåŠ¨æ›´æ–°</li>
                            <li>å…±13ä¸ªå›¾æ ‡å¯ç”¨ï¼š0-12</li>
                        </ul>
                    </div>
                </div>

                <div class="control-group" id="textManagementGroup">
                    <h3>ğŸ“ æ–‡æœ¬ç®¡ç†</h3>
                    <div class="form-group">
                        <label>æ–‡æœ¬ç±»å‹</label>
                        <select id="textType"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="3">å•è¯ (WORD)</option>
                            <option value="4">éŸ³æ ‡ (PHONETIC)</option>
                            <option value="5">é‡Šä¹‰ (DEFINITION)</option>
                            <option value="6">ç¿»è¯‘ (TRANSLATION)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>æ–‡æœ¬å†…å®¹</label>
                        <input type="text" id="textContent" placeholder="è¾“å…¥è¦æ˜¾ç¤ºçš„å†…å®¹"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹ä½ç½® X (0.0-1.0)</label>
                        <input type="number" id="textRelX" min="0" max="1" step="0.01" value="0.5"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                        <small style="color: #666;">0.0 = å·¦è¾¹ï¼Œ0.5 = ä¸­å¿ƒï¼Œ1.0 = å³è¾¹</small>
                    </div>
                    <div class="form-group">
                        <label>ç›¸å¯¹ä½ç½® Y (0.0-1.0)</label>
                        <input type="number" id="textRelY" min="0" max="1" step="0.01" value="0.5"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                        <small style="color: #666;">0.0 = é¡¶éƒ¨ï¼Œ0.5 = ä¸­å¿ƒï¼Œ1.0 = åº•éƒ¨</small>
                    </div>
                    <div class="form-group">
                        <label>å­—ä½“å¤§å°</label>
                        <input type="number" id="textFontSize" min="12" max="48" value="16"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;" />
                    </div>
                    <div class="form-group">
                        <label>æ°´å¹³å¯¹é½</label>
                        <select id="textHAlign"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="0">å·¦å¯¹é½ (LEFT)</option>
                            <option value="1">å±…ä¸­ (CENTER)</option>
                            <option value="2">å³å¯¹é½ (RIGHT)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>å‚ç›´å¯¹é½</label>
                        <select id="textVAlign"
                            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                            <option value="0">é¡¶éƒ¨ (TOP)</option>
                            <option value="1">ä¸­é—´ (MIDDLE)</option>
                            <option value="2">åº•éƒ¨ (BOTTOM)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="addTextToSelectedRect()">æ·»åŠ æ–‡æœ¬åˆ°é€‰ä¸­çŸ©å½¢</button>
                    <button class="btn" onclick="updateSelectedTextPosition()">æ›´æ–°é€‰ä¸­æ–‡æœ¬ä½ç½®</button>
                    <button class="btn btn-warning" onclick="removeSelectedText()">åˆ é™¤é€‰ä¸­æ–‡æœ¬</button>
                    <button class="btn" onclick="autoArrangeTexts()">è‡ªåŠ¨æ’åˆ—æ–‡æœ¬</button>

                    <div
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px;">
                        <strong>æç¤ºï¼š</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li><strong>å•è¯æ¨¡å¼</strong>ï¼šä¸»è¦ç”¨äºä¸»ç•Œé¢å¸ƒå±€çš„æ–‡æœ¬æ ‡è®°</li>
                            <li><strong>è¯æ±‡æ¨¡å¼</strong>ï¼šç”¨äºå®é™…å•è¯/éŸ³æ ‡/é‡Šä¹‰/ç¿»è¯‘å†…å®¹</li>
                            <li>æ–‡æœ¬å†…å®¹ç”¨äºé¢„è§ˆæ•ˆæœï¼Œå®é™…æ˜¾ç¤ºå†…å®¹ç”±è®¾å¤‡æ•°æ®å†³å®š</li>
                            <li>æ”¯æŒä¸­è‹±æ–‡æ··åˆæ–‡æœ¬æ˜¾ç¤º</li>
                        </ul>
                    </div>
                </div>
                <div class="control-group" id="focusConfigGroup" style="display: none;">
                    <h3>ğŸ¯ æ¯æ•°ç»„çŸ©å½¢é…ç½®</h3>
                    <div
                        style="margin-bottom: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; font-size: 13px;">
                        <strong>âš ï¸ é‡è¦è¯´æ˜ï¼š</strong><br>
                        è¿™é‡Œåªé…ç½®<strong>æ¯æ•°ç»„çŸ©å½¢</strong>ï¼ˆç¬¬ä¸€å±‚å¯¼èˆªï¼‰ã€‚<br>
                        â–ª åœ¨æ¯æ•°ç»„æ¨¡å¼ä¸‹ï¼ŒæŒ‰é”®1/3åªåœ¨è¿™äº›çŸ©å½¢é—´å¾ªç¯<br>
                        â–ª æŒ‰é”®2ç¡®è®¤åè¿›å…¥è¯¥çŸ©å½¢çš„å­æ•°ç»„ï¼ˆéœ€åœ¨ä¸‹æ–¹é…ç½®å­æ•°ç»„ï¼‰<br>
                        â–ª <strong style="color: red;">è¯·å‹¿å‹¾é€‰å­æ•°ç»„çŸ©å½¢ï¼Œå¦åˆ™ä¼šæ··ä¹±ï¼</strong>
                    </div>

                    <div id="focusableRectsCheckboxes"
                        style="max-height: 200px; overflow-y: auto; padding: 10px; background: white; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 15px;">
                        <!-- å¤é€‰æ¡†å°†åŠ¨æ€ç”Ÿæˆ -->
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn" onclick="selectAllFocusableRects()" style="flex: 1;">å…¨é€‰</button>
                        <button class="btn" onclick="deselectAllFocusableRects()" style="flex: 1;">å…¨ä¸é€‰</button>
                    </div>

                    <button class="btn btn-success" onclick="saveFocusConfig()">ä¿å­˜ç„¦ç‚¹é…ç½®åˆ°è®¾å¤‡</button>
                    <button class="btn" onclick="loadFocusConfig()">ä»è®¾å¤‡åŠ è½½ç„¦ç‚¹é…ç½®</button>

                    <div id="focusConfigStatus"
                        style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 12px; display: none;">
                        <strong>å½“å‰ç„¦ç‚¹é…ç½®ï¼š</strong>
                        <div id="focusConfigInfo"></div>
                    </div>

                    <!-- å­æ•°ç»„é…ç½®åŒºåŸŸ -->
                    <div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 5px; border: 2px solid #2196F3;">
                        <h4 style="margin: 0 0 10px 0; color: #1976D2;">ï¿½ å­æ•°ç»„çŸ©å½¢é…ç½®ï¼ˆç¬¬äºŒå±‚å¯¼èˆªï¼‰</h4>
                        <div style="margin-bottom: 10px; padding: 8px; background: #fff3cd; border-radius: 3px; font-size: 12px;">
                            <strong>å¯¼èˆªé€»è¾‘ï¼š</strong><br>
                            1. åœ¨æ¯æ•°ç»„æ¨¡å¼ä¸‹ï¼Œé€‰æ‹©ä¸€ä¸ªæ¯çŸ©å½¢ï¼ˆå¦‚çŸ©å½¢0ï¼‰<br>
                            2. æŒ‰<strong>ç¡®è®¤é”®</strong>è¿›å…¥è¯¥çŸ©å½¢çš„å­æ•°ç»„ï¼ˆå¦‚çŸ©å½¢1,3,5ï¼‰<br>
                            3. åœ¨å­æ•°ç»„ä¸­ï¼ŒæŒ‰é”®1/3<strong>åªåœ¨å­çŸ©å½¢é—´å¾ªç¯</strong><br>
                            4. å†æŒ‰<strong>ç¡®è®¤é”®</strong>é€€å›æ¯æ•°ç»„ï¼Œç»§ç»­åœ¨æ¯çŸ©å½¢é—´å¾ªç¯<br>
                            <strong style="color: #d32f2f;">âš ï¸ å­çŸ©å½¢ä¸è¦åœ¨ä¸Šæ–¹æ¯æ•°ç»„ä¸­å‹¾é€‰ï¼</strong>
                        </div>

                        <div style="margin-bottom: 10px;">
                            <label style="font-size: 14px; font-weight: bold; color: #333;">é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ï¼š</label>
                            <select id="subArrayParentSelect" onchange="updateSubArrayConfig()" 
                                style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 14px;">
                                <option value="">-- è¯·é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ --</option>
                            </select>
                        </div>

                        <div id="subArrayCheckboxes"
                            style="max-height: 150px; overflow-y: auto; padding: 10px; background: white; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px; display: none;">
                            <!-- å­æ•°ç»„å¤é€‰æ¡†å°†åŠ¨æ€ç”Ÿæˆ -->
                        </div>

                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="clearSubArray()" style="flex: 1; background: linear-gradient(135deg, #FF5722 0%, #E64A19 100%);">æ¸…ç©ºå½“å‰å­æ•°ç»„</button>
                        </div>

                        <button class="btn btn-success" onclick="saveSubArrayConfig()" style="margin-top: 10px;">ä¿å­˜å­æ•°ç»„é…ç½®åˆ°è®¾å¤‡</button>

                        <div id="subArrayConfigStatus"
                            style="margin-top: 10px; padding: 10px; background: #fff9c4; border-radius: 5px; font-size: 12px; display: none;">
                            <strong>å½“å‰å­æ•°ç»„é…ç½®ï¼š</strong>
                            <div id="subArrayConfigInfo"></div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <h3>ğŸ’¾ å¸ƒå±€ç®¡ç†</h3>
                    <div class="status-message" id="statusMessage"></div>
                    <button class="btn" onclick="testLayoutData()">æµ‹è¯•æ•°æ®æ ¼å¼</button>
                    <button class="btn btn-success" onclick="getCurrentLayout()">è·å–å½“å‰å¸ƒå±€</button>
                    <button class="btn btn-success" onclick="applyToDevice()">åº”ç”¨åˆ°è®¾å¤‡</button>
                    <button class="btn" onclick="saveLayoutToFile()">ä¿å­˜åˆ°æ–‡ä»¶</button>
                    <button class="btn" onclick="loadLayoutFromFile()">ä»æ–‡ä»¶åŠ è½½</button>
                    <button class="btn btn-warning" onclick="resetToDefault()">é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€</button>
                </div>

                <div class="control-group">
                    <h3>ğŸ”¤ TTF å­—ä½“ç®¡ç† 
                        <span style="font-size: 12px; color: #666; font-weight: normal;">
                            (.bin å­—åº“ç”Ÿæˆç³»ç»Ÿ)
                        </span>
                    </h3>
                    <div style="background: #e8f5e9; padding: 8px; margin-bottom: 10px; border-radius: 4px; font-size: 12px;">
                        âœ… æ··åˆç¼“å­˜ç³»ç»Ÿ - ä» TTF ç”Ÿæˆ .bin å­—åº“æ–‡ä»¶
                    </div>
                    <div class="form-group">
                        <label>é€‰æ‹© TTF å­—ä½“æ–‡ä»¶</label>
                        <input type="file" id="ttfFileInput" accept=".ttf,.otf" onchange="handleTTFUpload(event)">
                    </div>
                    <div class="form-group">
                        <label>é¢„è§ˆæ–‡å­—</label>
                        <input type="text" id="previewText" value="æµ‹è¯•æ–‡å­—ABC123" placeholder="è¾“å…¥è¦é¢„è§ˆçš„æ–‡å­—">
                    </div>
                    
                    <!-- .bin å­—åº“ç”ŸæˆåŒºåŸŸ -->
                    <div style="background: #e3f2fd; padding: 12px; margin: 15px 0; border-radius: 6px; border-left: 4px solid #2196F3;">
                        <h4 style="margin: 0 0 10px 0; color: #1976D2; font-size: 14px;">
                            ğŸ“¦ æ··åˆç¼“å­˜ç³»ç»Ÿ - .binå­—åº“ç”Ÿæˆ
                        </h4>
                        <p style="font-size: 12px; color: #666; margin: 5px 0;">
                            ç”Ÿæˆç”¨äºChineseFontCacheæ··åˆç¼“å­˜ç³»ç»Ÿçš„äºŒè¿›åˆ¶å­—åº“æ–‡ä»¶ (GB2312æ±‰å­—, 0x4E00-0x9FA5)
                        </p>
                        <div class="form-group" style="margin: 10px 0;">
                            <label>å­—åº“å°ºå¯¸ (é¢„è§ˆå’Œç”Ÿæˆéƒ½ä½¿ç”¨æ­¤å°ºå¯¸)</label>
                            <select id="binFontSize" onchange="previewTTFFont()">
                                <option value="16" selected>16x16 (32å­—èŠ‚/å­—, ~650KB)</option>
                                <option value="24">24x24 (72å­—èŠ‚/å­—, ~1.5MB)</option>
                                <option value="32">32x32 (128å­—èŠ‚/å­—, ~2.6MB)</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin: 10px 0;">
                            <label>å­—ç¬¦é›†é€‰æ‹©</label>
                            <select id="charsetRange" onchange="updateCharsetInfo()">
                                <option value="english">è‹±æ–‡ ASCII (0x0020-0x007E, 95ä¸ªå­—ç¬¦, ~3-12KB)</option>
                                <option value="gb2312" selected>ä¸­æ–‡ GB2312 (0x4E00-0x9FA5, ~20000å­—ç¬¦, ~650KB)</option>
                            </select>
                            <div id="charsetInfo" style="font-size: 11px; color: #666; margin-top: 5px;"></div>
                        </div>
                        <button class="btn btn-primary" style="background: #2196F3;" onclick="convertTTFtoBin()">
                            ğŸ”„ ç”Ÿæˆ .bin å­—åº“æ–‡ä»¶
                        </button>
                        <button class="btn btn-success" onclick="downloadBinFile()" id="downloadBinBtn" style="display: none;">
                            ğŸ’¾ ä¸‹è½½ .bin æ–‡ä»¶
                        </button>
                        <button class="btn btn-success" onclick="uploadBinToSD()" id="uploadBinBtn" style="display: none;">
                            ğŸ“¤ ä¸Šä¼ åˆ° SD å¡
                        </button>
                        <div id="binGenerationStatus" style="margin-top: 10px; font-size: 12px;"></div>
                    </div>
                    
                    <div id="fontPreviewCanvas" style="background: white; border: 1px solid #ccc; margin: 10px 0; min-height: 80px; padding: 10px;">
                        <!-- Canvas é¢„è§ˆåŒºåŸŸ -->
                    </div>
                    <button class="btn" onclick="previewTTFFont()">é¢„è§ˆå­—ä½“</button>
                    
                    <div class="status-message" id="fontStatusMessage" style="margin-top: 10px;"></div>
                    
                    <!-- å­—ä½“åº“æœç´¢ -->
                    <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px;">
                        <h4 style="margin-bottom: 10px;">ğŸ“š å­—ä½“åº“ç®¡ç†</h4>
                        <button class="btn" onclick="searchFontLibrary()">ğŸ” æŸ¥è¯¢å­—ä½“åº“</button>
                        <div id="fontLibraryList" style="margin-top: 10px; max-height: 300px; overflow-y: auto;"></div>
                    </div>
                    
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; font-weight: bold;">ğŸ“– ä½¿ç”¨è¯´æ˜</summary>
                        <div style="font-size: 12px; margin-top: 10px; line-height: 1.6;">
                            <p><strong>æ­¥éª¤ï¼š</strong></p>
                            <ol>
                                <li>ä¸Šä¼  TTF/OTF å­—ä½“æ–‡ä»¶</li>
                                <li>è¾“å…¥é¢„è§ˆæ–‡å­—å¹¶ç‚¹å‡»"é¢„è§ˆå­—ä½“"</li>
                                <li>é€‰æ‹©å­—åº“å°ºå¯¸ (16x16/24x24/32x32)</li>
                                <li>ç‚¹å‡»"ç”Ÿæˆ .bin å­—åº“æ–‡ä»¶"</li>
                                <li>ä¸‹è½½ .bin æ–‡ä»¶æˆ–ç›´æ¥ä¸Šä¼ åˆ° SD å¡</li>
                                <li>åœ¨ ESP32 ä»£ç ä¸­ä½¿ç”¨ SDFontLoader åŠ è½½</li>
                            </ol>
                            <p><strong>æ³¨æ„ï¼š</strong></p>
                            <ul>
                                <li>ç”ŸæˆåŒ…å«å…¨éƒ¨ GB2312 æ±‰å­— (0x4E00-0x9FA5)</li>
                                <li>æ–‡ä»¶è¾ƒå¤§ï¼Œç”Ÿæˆéœ€è¦ 10-30 ç§’</li>
                                <li>å­—å·è¶Šå¤§ï¼Œæ–‡ä»¶è¶Šå¤§</li>
                            </ul>
                        </div>
                    </details>
                </div>
                
                <!-- å›¾ç‰‡è½¬æ¢åŠŸèƒ½ -->
                <div class="control-panel">
                    <h3>
                        ğŸ“· å›¾ç‰‡è½¬æ¢
                        <span style="font-size: 12px; color: #666; font-weight: normal;">
                            (æ”¯æŒ JPG/PNG/BMP)
                        </span>
                    </h3>
                    <div style="background: #fff3cd; padding: 8px; margin-bottom: 10px; border-radius: 4px; font-size: 12px;">
                        ğŸ’¡ å°†å›¾ç‰‡è½¬æ¢ä¸ºå¢¨æ°´å±å¯ç”¨çš„ .bin äºŒè¿›åˆ¶æ–‡ä»¶
                    </div>
                    
                    <div class="form-group">
                        <label>é€‰æ‹©å›¾ç‰‡æ–‡ä»¶</label>
                        <input type="file" id="imageFileInput" accept="image/*" onchange="handleImageUpload(event)">
                    </div>
                    
                    <div class="form-group">
                        <label>å›¾ç‰‡å®½åº¦ (åƒç´ )</label>
                        <input type="number" id="imageWidth" value="200" min="1" max="800">
                    </div>
                    
                    <div class="form-group">
                        <label>å›¾ç‰‡é«˜åº¦ (åƒç´ )</label>
                        <input type="number" id="imageHeight" value="200" min="1" max="600">
                    </div>
                    
                    <div class="form-group">
                        <label>å¤„ç†æ¨¡å¼</label>
                        <select id="imageMode">
                            <option value="threshold">é˜ˆå€¼äºŒå€¼åŒ–</option>
                            <option value="dithering" selected>æŠ–åŠ¨ç®—æ³• (æ¨è)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>é˜ˆå€¼ (0-255)</label>
                        <input type="number" id="imageThreshold" value="128" min="0" max="255">
                        <small>ä»…åœ¨äºŒå€¼åŒ–æ¨¡å¼ä¸‹æœ‰æ•ˆ</small>
                    </div>
                    
                    <div id="imagePreviewCanvas" style="background: white; border: 1px solid #ccc; margin: 10px 0; min-height: 200px; padding: 10px; text-align: center;">
                        <canvas id="srcImageCanvas" style="max-width: 100%; border: 1px solid #ddd;"></canvas>
                        <canvas id="dstImageCanvas" style="max-width: 100%; border: 1px solid #ddd; margin-left: 10px;"></canvas>
                    </div>
                    
                    <button class="btn" onclick="previewImage()">é¢„è§ˆå¤„ç†æ•ˆæœ</button>
                    
                    <!-- .bin æ–‡ä»¶è½¬æ¢åŒºåŸŸ -->
                    <div style="background: #e3f2fd; padding: 12px; margin: 15px 0; border-radius: 6px; border-left: 4px solid #2196F3;">
                        <h4 style="margin: 0 0 10px 0; color: #1976D2; font-size: 14px;">
                            ğŸ“¦ å›¾ç‰‡è½¬ .bin æ–‡ä»¶
                        </h4>
                        <p style="font-size: 12px; color: #666; margin: 5px 0;">
                            ç”Ÿæˆç”¨äºå¢¨æ°´å±åŠ¨æ€åŠ è½½çš„äºŒè¿›åˆ¶å›¾ç‰‡æ–‡ä»¶ (åŒ…å«8å­—èŠ‚æ–‡ä»¶å¤´: å®½åº¦+é«˜åº¦)
                        </p>
                        <button class="btn btn-primary" style="background: #2196F3;" onclick="convertImageToBin()">
                            ğŸ”„ è½¬æ¢ä¸º .bin æ–‡ä»¶
                        </button>
                        <button class="btn btn-info" onclick="addBitmapToSelectedRect()" id="addBitmapBtn" style="display: none;">
                            â• æ·»åŠ å›¾ç‰‡åˆ°é€‰ä¸­çŸ©å½¢
                        </button>
                        <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
                        <input type="file" id="bitmapFileInput" accept=".bin" style="display: none;">
                        <button class="btn" onclick="document.getElementById('bitmapFileInput').click()" id="browseBitmapBtn" style="display: none;">
                            ğŸ“ æµè§ˆä½å›¾æ–‡ä»¶
                        </button>
                        <div id="imageBinStatus" style="margin-top: 10px; font-size: 12px;"></div>
                    </div>
                    
                    <!-- å›¾ç‰‡åº“æœç´¢ -->
                    <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px;">
                        <h4 style="margin-bottom: 10px;">ğŸ–¼ï¸ å›¾ç‰‡åº“ç®¡ç†</h4>
                        <button class="btn" onclick="searchBitmapLibrary()">ğŸ” æŸ¥è¯¢å›¾ç‰‡åº“</button>
                        <div id="bitmapLibraryList" style="margin-top: 10px; max-height: 400px; overflow-y: auto;"></div>
                        <div id="bitmapPreviewArea" style="margin-top: 10px; padding: 10px; background: white; border: 1px solid #ddd; display: none;">
                            <h5>é¢„è§ˆ:</h5>
                            <canvas id="bitmapPreviewCanvas" style="border: 1px solid #ccc; max-width: 100%;"></canvas>
                            <div id="bitmapPreviewInfo" style="margin-top: 10px; font-size: 12px;"></div>
                        </div>
                    </div>

                    <!-- SDå¡æ–‡ä»¶ç®¡ç† -->
                    <div style="margin-top: 20px; border-top: 1px solid #ddd; padding-top: 15px;">
                        <h4 style="margin-bottom: 10px;">ğŸ’¾ SD å¡æ–‡ä»¶ç®¡ç†</h4>
                        <div style="margin-bottom: 10px;">
                            <button class="btn" onclick="refreshSDFiles()">ğŸ”„ åˆ·æ–°æ–‡ä»¶åˆ—è¡¨</button>
                            <button class="btn btn-danger" onclick="deleteSelectedFiles()" style="margin-left: 5px;">ğŸ—‘ï¸ æ‰¹é‡åˆ é™¤</button>
                            <button class="btn btn-danger" onclick="deleteAllFiles()" style="margin-left: 5px;">âš ï¸ å…¨éƒ¨åˆ é™¤</button>
                        </div>
                        <div id="sdCardInfo" style="margin: 10px 0; padding: 10px; background: #f9f9f9; border-radius: 4px; font-size: 12px;"></div>
                        <div style="margin-bottom: 10px;">
                            <label style="cursor: pointer;">
                                <input type="checkbox" id="selectAllCheckbox" onclick="toggleSelectAll()"> å…¨é€‰
                            </label>
                        </div>
                        <div id="sdFilesList" style="max-height: 500px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;"></div>
                    </div>
                    
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; font-weight: bold;">ğŸ“– ä½¿ç”¨è¯´æ˜</summary>
                        <div style="font-size: 12px; margin-top: 10px; line-height: 1.6;">
                            <p><strong>æ­¥éª¤ï¼š</strong></p>
                            <ol>
                                <li>ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶ (JPG/PNG/BMP)</li>
                                <li>è®¾ç½®ç›®æ ‡å®½é«˜ (å»ºè®®ä¸è¶…è¿‡å¢¨æ°´å±åˆ†è¾¨ç‡)</li>
                                <li>é€‰æ‹©å¤„ç†æ¨¡å¼ (æŠ–åŠ¨ç®—æ³•æ•ˆæœæ›´å¥½)</li>
                                <li>ç‚¹å‡»"é¢„è§ˆå¤„ç†æ•ˆæœ"æŸ¥çœ‹æ•ˆæœ</li>
                                <li>ç‚¹å‡»"è½¬æ¢ä¸º .bin æ–‡ä»¶"</li>
                                <li>ä¸‹è½½ .bin æ–‡ä»¶æˆ–ç›´æ¥ä¸Šä¼ åˆ° SD å¡</li>
                                <li>åœ¨ ESP32 ä»£ç ä¸­ä½¿ç”¨ displayImageFromSD() æ˜¾ç¤º</li>
                            </ol>
                            
                            <p><strong>æ³¨æ„ï¼š</strong></p>
                            <ul>
                                <li>.bin æ–‡ä»¶åŒ…å« 8 å­—èŠ‚æ–‡ä»¶å¤´ (å®½åº¦+é«˜åº¦)</li>
                                <li>ä½¿ç”¨æŠ–åŠ¨ç®—æ³•å¯è·å¾—æ›´å¥½çš„å›¾ç‰‡è´¨é‡</li>
                                <li>å»ºè®®å›¾ç‰‡å°ºå¯¸ä¸è¦è¶…è¿‡å¢¨æ°´å±åˆ†è¾¨ç‡</li>
                            </ul>
                        </div>
                    </details>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== å…¨å±€é…ç½®ï¼šè‡ªåŠ¨æ£€æµ‹æœåŠ¡åœ°å€ï¼Œä¼˜å…ˆ PC ç«¯ï¼Œé™çº§åˆ° ESP32 =====
        const CONFIG = {
            // PC ç«¯ Flask æœåŠ¡åœ°å€
            PC_SERVICE_URL: 'http://localhost:5001',
            
            // Python åç«¯æœåŠ¡åœ°å€ (ç”¨äºå­—ä½“/å›¾ç‰‡è½¬æ¢)
            PYTHON_SERVICE_URL: 'http://localhost:5000',
            
            // ESP32 æœåŠ¡åœ°å€ (è‡ªåŠ¨æ£€æµ‹)
            get ESP32_BASE_URL() {
                if (window.location.protocol === 'file:') {
                    // æœ¬åœ°æ–‡ä»¶æ‰“å¼€æ—¶ä½¿ç”¨é»˜è®¤åœ°å€
                    return 'http://192.168.0.2:8848';
                } else {
                    // ä» ESP32 ç½‘é¡µæ‰“å¼€æ—¶ä½¿ç”¨å½“å‰åœ°å€
                    return `${window.location.protocol}//${window.location.host}`;
                }
            },
            
            // è¾…åŠ©å‡½æ•°ï¼šè·å– Python æœåŠ¡URL
            pythonUrl: function(path) {
                return this.PYTHON_SERVICE_URL + path;
            },
            
            // è¾…åŠ©å‡½æ•°ï¼šè·å– ESP32 æœåŠ¡URL
            esp32Url: function(path) {
                return this.ESP32_BASE_URL + path;
            },
            
            // è¾…åŠ©å‡½æ•°ï¼šè·å– PC ç«¯æœåŠ¡URL
            pcUrl: function(path) {
                return this.PC_SERVICE_URL + path;
            },
            
            // è¾…åŠ©å‡½æ•°ï¼šå¸¦å›é€€çš„ Python æœåŠ¡ URL
            pythonUrlWithFallback: function(path) {
                // PC ç«¯ä¼˜å…ˆè¿”å› PC æœåŠ¡ URL
                return this.PC_SERVICE_URL + path;
            }
        };
        
        /**
         * å¸¦å›é€€çš„ fetch å‡½æ•°ï¼šä¼˜å…ˆå°è¯• PC ç«¯æ¥å£ï¼Œå¤±è´¥åˆ™é™çº§åˆ° ESP32 æ¥å£
         * @param {string} pcPath - PC ç«¯æ¥å£è·¯å¾„ (ç›¸å¯¹ localhost:5001)
         * @param {string} esp32Path - ESP32 æ¥å£è·¯å¾„ (ç›¸å¯¹ ESP32 ä¸»æœº)
         * @param {object} options - fetch é€‰é¡¹
         * @returns {Promise} fetch å“åº”
         */
        async function fetchWithFallback(pcPath, esp32Path, options = {}) {
            try {
                // ä¼˜å…ˆå°è¯• PC ç«¯æ¥å£
                const pcUrl = CONFIG.pcUrl(pcPath);
                const response = await Promise.race([
                    fetch(pcUrl, options),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('PC endpoint timeout')), 5000)
                    )
                ]);
                
                if (response.ok) {
                    console.log(`âœ“ PC endpoint success: ${pcPath}`);
                    return response;
                } else {
                    throw new Error(`PC endpoint returned ${response.status}`);
                }
            } catch (pcError) {
                console.warn(`âš  PC endpoint failed (${pcPath}):`, pcError.message);
                
                try {
                    // é™çº§åˆ° ESP32 æ¥å£
                    const esp32Url = CONFIG.esp32Url(esp32Path);
                    const response = await fetch(esp32Url, options);
                    
                    if (response.ok) {
                        console.log(`âœ“ ESP32 endpoint success: ${esp32Path}`);
                        return response;
                    } else {
                        throw new Error(`ESP32 endpoint returned ${response.status}`);
                    }
                } catch (esp32Error) {
                    console.error(`âœ— Both endpoints failed. PC: ${pcError.message}, ESP32: ${esp32Error.message}`);
                    throw new Error(`All endpoints failed: ${esp32Error.message}`);
                }
            }
        }
        
        /**
         * ä¸º Python æœåŠ¡ API çš„å¸¦å›é€€ fetchï¼šPC ä¼˜å…ˆï¼ŒPython å¤‡ç”¨
         * @param {string} path - API è·¯å¾„
         * @param {object} options - fetch é€‰é¡¹
         * @returns {Promise} fetch å“åº”
         */
        async function fetchWithFallbackForPython(path, options = {}) {
            try {
                // ä¼˜å…ˆå°è¯• PC ç«¯æœåŠ¡
                const pcPath = CONFIG.PC_SERVICE_URL + path;
                const response = await Promise.race([
                    fetch(pcPath, options),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('PC endpoint timeout')), 5000)
                    )
                ]);
                
                if (response.ok) {
                    console.log(`âœ“ PC endpoint success for Python API: ${path}`);
                    return response;
                } else {
                    throw new Error(`PC endpoint returned ${response.status}`);
                }
            } catch (pcError) {
                console.warn(`âš  PC endpoint failed for Python API (${path}):`, pcError.message);
                
                try {
                    // é™çº§åˆ° Python åç«¯æœåŠ¡
                    const pythonPath = CONFIG.PYTHON_SERVICE_URL + path;
                    const response = await fetch(pythonPath, options);
                    
                    if (response.ok) {
                        console.log(`âœ“ Python endpoint success: ${path}`);
                        return response;
                    } else {
                        throw new Error(`Python endpoint returned ${response.status}`);
                    }
                } catch (pythonError) {
                    console.error(`âœ— Both endpoints failed. PC: ${pcError.message}, Python: ${pythonError.message}`);
                    throw new Error(`All endpoints failed: ${pythonError.message}`);
                }
            }
        }
        
        // ç¯å¢ƒæ£€æµ‹ï¼šåˆ¤æ–­æ˜¯åœ¨ç”µè„‘è¿˜æ˜¯åœ¨ESP32ä¸Šè¿è¡Œ
        let g_env = {
            isPC: false,           // æ˜¯å¦åœ¨ç”µè„‘ä¸Šè¿è¡Œ
            isESP32: false,        // æ˜¯å¦åœ¨ESP32ä¸Šè¿è¡Œ
            esp32Host: '',         // ESP32ä¸»æœºåœ°å€
            pcHost: 'localhost',   // ç”µè„‘æœåŠ¡å™¨åœ°å€
            pcPort: 5001           // ç”µè„‘æœåŠ¡å™¨ç«¯å£
        };

        // æ£€æµ‹è¿è¡Œç¯å¢ƒ
        async function detectEnvironment() {
            console.log('[detectEnvironment] å¼€å§‹æ£€æµ‹è¿è¡Œç¯å¢ƒ...');
            
            // é¦–å…ˆå°è¯•è¿æ¥æœ¬åœ°PCæœåŠ¡å™¨ (localhost:5001)
            try {
                const response = await Promise.race([
                    fetch(`http://${g_env.pcHost}:${g_env.pcPort}/api/health`, {
                        method: 'GET'
                    }),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('timeout')), 3000)
                    )
                ]);
                
                if (response && response.ok) {
                    g_env.isPC = true;
                    console.log('[detectEnvironment] âœ“ æ£€æµ‹åˆ°åœ¨ç”µè„‘ä¸Šè¿è¡Œï¼ŒPCæœåŠ¡å™¨å¯ç”¨');
                    
                    // æ›´æ–°ç¯å¢ƒçŠ¶æ€æ¡
                    const statusBar = document.getElementById('envStatusBar');
                    const statusText = document.getElementById('envStatusText');
                    const indicator = document.getElementById('envIndicator');
                    
                    if (statusBar) statusBar.style.background = '#e8f5e9';
                    if (statusText) statusText.textContent = 'âœ“ åœ¨ç”µè„‘ä¸Šè¿è¡Œ (PC Mode) - ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ (localhost:5001)';
                    if (indicator) indicator.style.background = '#4CAF50';
                    
                    return;
                }
            } catch (error) {
                console.warn('[detectEnvironment] æœ¬åœ°PCæœåŠ¡å™¨ä¸å¯ç”¨:', error.message);
            }
            
            // å¦‚æœPCæœåŠ¡å™¨ä¸å¯ç”¨ï¼Œåˆ™åœ¨ESP32ä¸Šè¿è¡Œ
            g_env.isESP32 = true;
            g_env.esp32Host = window.location.hostname || '192.168.1.100';
            console.log('[detectEnvironment] âœ“ æ£€æµ‹åˆ°åœ¨ESP32ä¸Šè¿è¡Œï¼Œä¸»æœº:', g_env.esp32Host);
            
            // æ›´æ–°ç¯å¢ƒçŠ¶æ€æ¡
            const statusBar = document.getElementById('envStatusBar');
            const statusText = document.getElementById('envStatusText');
            const indicator = document.getElementById('envIndicator');
            
            if (statusBar) statusBar.style.background = '#e3f2fd';
            if (statusText) statusText.textContent = `âœ“ åœ¨ESP32ä¸Šè¿è¡Œ (ESP32 Mode) - ä¸»æœº: ${g_env.esp32Host}`;
            if (indicator) indicator.style.background = '#2196F3';
        }
        
        // ===== å›¾æ ‡ä½å›¾æ•°æ®ï¼ˆæ¥è‡ª Pic.hï¼‰=====
        // æ¯ä¸ªå›¾æ ‡çš„åŸºæœ¬ä¿¡æ¯
        const ICON_METADATA = [
            {index: 0, name: 'ICON_1', width: 62, height: 64, dataSize: 512},
            {index: 1, name: 'ICON_2', width: 64, height: 64, dataSize: 512},
            {index: 2, name: 'ICON_3', width: 86, height: 64, dataSize: 704},
            {index: 3, name: 'ICON_4', width: 71, height: 56, dataSize: 504},
            {index: 4, name: 'ICON_5', width: 76, height: 56, dataSize: 560},
            {index: 5, name: 'ICON_6', width: 94, height: 64, dataSize: 768},
            {index: 6, name: 'separate', width: 120, height: 8, dataSize: 120},
            {index: 7, name: 'WIFI_CONNECT', width: 32, height: 32, dataSize: 128},
            {index: 8, name: 'WIFI_DISCONNECT', width: 32, height: 32, dataSize: 128},
            {index: 9, name: 'BATTERY_1', width: 36, height: 24, dataSize: 120},
            {index: 10, name: 'HORN', width: 16, height: 16, dataSize: 32},
            {index: 11, name: 'NAIL', width: 15, height: 16, dataSize: 32},
            {index: 12, name: 'LOCK', width: 32, height: 32, dataSize: 128},
        ];
        
        // å›¾æ ‡ä½å›¾æ•°æ®ç¼“å­˜
        const ICON_BITMAP_DATA = {};
        
        // è·å–å›¾æ ‡çš„ä½å›¾æ•°æ®ï¼ˆ1ä½é»‘ç™½ä½å›¾ï¼‰
        async function getIconBitmapData(iconIndex) {
            if (iconIndex in ICON_BITMAP_DATA) {
                console.log(`Icon ${iconIndex} loaded from cache, size: ${ICON_BITMAP_DATA[iconIndex].length} bytes`);
                return ICON_BITMAP_DATA[iconIndex];
            }
            
            try {
                console.log(`[getIconBitmapData] å¼€å§‹è·å–å›¾æ ‡ ${iconIndex}`);
                const response = await fetchWithFallback(
                    `/api/icon/binary/${iconIndex}`,
                    `/api/icon/data/${iconIndex}`
                );
                console.log(`[getIconBitmapData] æ”¶åˆ°å“åº”: ${response.status} ${response.statusText}`);
                
                if (!response.ok) {
                    console.error(`Failed to fetch icon ${iconIndex}: HTTP ${response.status}`);
                    return null;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯äºŒè¿›åˆ¶æ•°æ®ï¼ˆArrayBufferï¼‰æˆ–æ–‡æœ¬æ•°æ®ï¼ˆBase64ï¼‰
                const contentType = response.headers.get('content-type');
                console.log(`[getIconBitmapData] Content-Type: ${contentType}`);
                
                let binaryData;
                const isESP32Mode = g_env && g_env.isESP32;
                
                if (contentType && contentType.includes('octet-stream')) {
                    // PC ç«¯è¿”å›çš„æ˜¯äºŒè¿›åˆ¶
                    const arrayBuffer = await response.arrayBuffer();
                    binaryData = new Uint8Array(arrayBuffer);
                    console.log(`[getIconBitmapData] PCæ¨¡å¼ï¼šæ¥æ”¶äºŒè¿›åˆ¶æ•°æ®ï¼ˆicon ${iconIndex}ï¼‰: é•¿åº¦=${binaryData.length} å­—èŠ‚`);
                } else {
                    // ESP32 ç«¯è¿”å› Base64
                    const base64Data = await response.text();
                    console.log(`[getIconBitmapData] æ¥æ”¶ Base64 æ•°æ®ï¼ˆicon ${iconIndex}ï¼‰: é•¿åº¦=${base64Data.length} å­—ç¬¦`);
                    
                    const binaryString = atob(base64Data);
                    binaryData = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        binaryData[i] = binaryString.charCodeAt(i);
                    }
                    console.log(`[getIconBitmapData] è§£ç åäºŒè¿›åˆ¶æ•°æ®ï¼ˆicon ${iconIndex}ï¼‰: é•¿åº¦=${binaryData.length} å­—èŠ‚ï¼Œç›´æ¥ä½¿ç”¨`);
                    
                    // ESP32 æ¨¡å¼ï¼šæ¥æ”¶åˆ°çš„æ•°æ®å·²ç»æ˜¯çº¯ä½å›¾ï¼Œæ— éœ€å¤„ç†å¤´éƒ¨
                }
                
                ICON_BITMAP_DATA[iconIndex] = binaryData;
                return binaryData;
            } catch (error) {
                console.error(`[getIconBitmapData] è·å–å›¾æ ‡ ${iconIndex} å‡ºé”™:`, error);
                return null;
            }
        }
        
        // ä¸ºç”¨æˆ·ä¸Šä¼ çš„ä½å›¾ç»˜åˆ¶åˆ°Canvasï¼ˆå¸¦é¢œè‰²åè½¬ã€æ°´å¹³é•œåƒå’Œé¡ºæ—¶é’ˆæ—‹è½¬90åº¦ï¼‰
        function drawBitmapToCanvasForUser(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight) {
            if (!bitmapData) {
                console.error(`[drawBitmapToCanvasForUser] é”™è¯¯: bitmapDataä¸ºnullæˆ–undefined`);
                return;
            }
            
            console.log(`[drawBitmapToCanvasForUser] å¼€å§‹ç»˜åˆ¶ç”¨æˆ·ä½å›¾: origSize=${origWidth}x${origHeight}, displaySize=${displayWidth}x${displayHeight}, dataSize=${bitmapData.length}`);
            
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆé¡ºæ—¶é’ˆæ—‹è½¬90åº¦åï¼Œå®½é«˜äº’æ¢ï¼‰
            const scaleX = displayWidth / origHeight;   // åŸé«˜åº¦å˜æˆæ–°å®½åº¦
            const scaleY = displayHeight / origWidth;   // åŸå®½åº¦å˜æˆæ–°é«˜åº¦
            
            // è®¡ç®—æ¯è¡Œçš„å­—èŠ‚æ•°ï¼ˆ8åƒç´ å¯¹é½ï¼‰
            const bytesPerRow = Math.ceil(origWidth / 8);
            const expectedDataSize = bytesPerRow * origHeight;
            
            console.log(`[drawBitmapToCanvasForUser] è®¡ç®—å‚æ•°: bytesPerRow=${bytesPerRow}, expectedDataSize=${expectedDataSize}, scaleX=${scaleX}, scaleY=${scaleY}`);
            
            if (bitmapData.length < expectedDataSize) {
                console.warn(`[drawBitmapToCanvasForUser] è­¦å‘Š: ä½å›¾æ•°æ®ä¸å®Œæ•´ã€‚æœŸæœ› ${expectedDataSize} å­—èŠ‚ï¼Œå®é™… ${bitmapData.length} å­—èŠ‚`);
            }
            
            // åˆ›å»ºImageDataç”¨äºæ›´é«˜æ•ˆçš„ç»˜åˆ¶
            const imageData = ctx.createImageData(displayWidth, displayHeight);
            const data = imageData.data;
            
            console.log(`[drawBitmapToCanvasForUser] ImageDataå·²åˆ›å»º: ${displayWidth}x${displayHeight}, æ€»åƒç´ : ${displayWidth * displayHeight}`);
            
            // é€åƒç´ å¤„ç†ï¼ˆé¢œè‰²åè½¬ + æ°´å¹³é•œåƒ + é¡ºæ—¶é’ˆæ—‹è½¬90åº¦ï¼‰
            for (let y = 0; y < origHeight; y++) {
                for (let x = 0; x < origWidth; x++) {
                    // è®¡ç®—å­—èŠ‚ç´¢å¼•å’Œä½ä½ç½®
                    const byteIndex = y * bytesPerRow + Math.floor(x / 8);
                    const bitPosition = 7 - (x % 8);
                    
                    // è·å–è¯¥åƒç´ çš„ä½å€¼
                    let pixelColor = [255, 255, 255, 255]; // é»˜è®¤ç™½è‰²
                    
                    if (byteIndex < bitmapData.length) {
                        const pixelValue = (bitmapData[byteIndex] >> bitPosition) & 1;
                        
                        // é¢œè‰²åè½¬ï¼š1â†’é»‘è‰²ï¼Œ0â†’ç™½è‰²
                        if (pixelValue) {  // åŸå§‹ä½å€¼ä¸º1
                            pixelColor = [0, 0, 0, 255];      // é»‘è‰²
                        } else {  // åŸå§‹ä½å€¼ä¸º0
                            pixelColor = [255, 255, 255, 255]; // ç™½è‰²
                        }
                    }
                    
                    // ä¸æ°´å¹³é•œåƒï¼Œç›´æ¥è¿›è¡Œé¡ºæ—¶é’ˆæ—‹è½¬180åº¦
                    // ç¬¬ä¸€æ¬¡é¡ºæ—¶é’ˆæ—‹è½¬90åº¦ï¼š(x, y) â†’ (y, origWidth - 1 - x)
                    let rotated1X = y;
                    let rotated1Y = origWidth - 1 - x;
                    
                    // ç¬¬äºŒæ¬¡é¡ºæ—¶é’ˆæ—‹è½¬90åº¦ï¼ˆæ€»å…±æ—‹è½¬180åº¦ï¼‰
                    // åœ¨rotated1çš„å°ºå¯¸ä¸­ï¼ˆrotated1Height=origWidth, rotated1Width=origHeightï¼‰
                    // (rotated1X, rotated1Y) â†’ (origWidth - 1 - rotated1Y, rotated1X)
                    const rotatedX = origWidth - 1 - rotated1Y;  // æ–°çš„xåæ ‡
                    const rotatedY = rotated1X;                  // æ–°çš„yåæ ‡
                    
                    // æ”¾å¤§åƒç´ åˆ°æ˜¾ç¤ºåˆ†è¾¨ç‡
                    const displayX = Math.floor(rotatedX * scaleX);
                    const displayY = Math.floor(rotatedY * scaleY);
                    const pixelWidth = Math.ceil(scaleX);
                    const pixelHeight = Math.ceil(scaleY);
                    
                    for (let dy = 0; dy < pixelHeight && displayY + dy < displayHeight; dy++) {
                        for (let dx = 0; dx < pixelWidth && displayX + dx < displayWidth; dx++) {
                            const imgIdx = ((displayY + dy) * displayWidth + (displayX + dx)) * 4;
                            data[imgIdx] = pixelColor[0];     // R
                            data[imgIdx + 1] = pixelColor[1]; // G
                            data[imgIdx + 2] = pixelColor[2]; // B
                            data[imgIdx + 3] = pixelColor[3]; // A
                        }
                    }
                }
            }
            
            // å°†å¤„ç†å¥½çš„å›¾åƒæ•°æ®ç»˜åˆ¶åˆ°Canvasä¸Š
            ctx.putImageData(imageData, 0, 0);
            console.log(`âœ“ [drawBitmapToCanvasForUser] ç”¨æˆ·ä½å›¾å·²ç»˜åˆ¶åˆ°Canvasï¼Œå¤§å°: ${displayWidth}x${displayHeight}`);
        }
        
        // å°† 1 ä½é»‘ç™½ä½å›¾æ¸²æŸ“åˆ° Canvas
        // PC æ¨¡å¼ï¼šç›´æ¥æ˜ å°„ï¼Œä¸æ—‹è½¬
        function drawBitmapToCanvasPC(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight) {
            if (!bitmapData) {
                console.error(`[drawBitmapToCanvasPC] é”™è¯¯: bitmapDataä¸ºnullæˆ–undefined`);
                return;
            }
            
            console.log(`[drawBitmapToCanvasPC] å¼€å§‹ç»˜åˆ¶: origSize=${origWidth}x${origHeight}, displaySize=${displayWidth}x${displayHeight}, dataSize=${bitmapData.length}`);
            const scaleX = displayWidth / origWidth;
            const scaleY = displayHeight / origHeight;
            const bytesPerRow = Math.ceil(origWidth / 8);
            const expectedDataSize = bytesPerRow * origHeight;
            
            console.log(`[drawBitmapToCanvasPC] è®¡ç®—å‚æ•°: bytesPerRow=${bytesPerRow}, expectedDataSize=${expectedDataSize}, scaleX=${scaleX}, scaleY=${scaleY}`);
            
            if (bitmapData.length < expectedDataSize) {
                console.warn(`[drawBitmapToCanvasPC] è­¦å‘Š: ä½å›¾æ•°æ®ä¸å®Œæ•´ã€‚æœŸæœ› ${expectedDataSize} å­—èŠ‚ï¼Œå®é™… ${bitmapData.length} å­—èŠ‚`);
            }
            
            const imageData = ctx.createImageData(displayWidth, displayHeight);
            const data = imageData.data;
            
            console.log(`[drawBitmapToCanvasPC] ImageDataå·²åˆ›å»º: ${displayWidth}x${displayHeight}, æ€»åƒç´ : ${displayWidth * displayHeight}`);
            
            for (let y = 0; y < origHeight; y++) {
                for (let x = 0; x < origWidth; x++) {
                    const byteIndex = y * bytesPerRow + Math.floor(x / 8);
                    const bitPosition = 7 - (x % 8);
                    let pixelColor = [255, 255, 255, 255];
                    
                    if (byteIndex < bitmapData.length) {
                        const pixelValue = (bitmapData[byteIndex] >> bitPosition) & 1;
                        if (pixelValue) {
                            pixelColor = [0, 0, 0, 255];       // é»‘è‰²
                        } else {
                            pixelColor = [255, 255, 255, 255]; // ç™½è‰²
                        }
                    }
                    
                    const displayX = Math.floor(x * scaleX);
                    const displayY = Math.floor(y * scaleY);
                    const pixelWidth = Math.ceil(scaleX);
                    const pixelHeight = Math.ceil(scaleY);
                    
                    for (let dy = 0; dy < pixelHeight && displayY + dy < displayHeight; dy++) {
                        for (let dx = 0; dx < pixelWidth && displayX + dx < displayWidth; dx++) {
                            const imgIdx = ((displayY + dy) * displayWidth + (displayX + dx)) * 4;
                            data[imgIdx] = pixelColor[0];
                            data[imgIdx + 1] = pixelColor[1];
                            data[imgIdx + 2] = pixelColor[2];
                            data[imgIdx + 3] = pixelColor[3];
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log(`âœ“ [drawBitmapToCanvasPC] ä½å›¾å·²ç»˜åˆ¶åˆ°Canvasï¼Œå¤§å°: ${displayWidth}x${displayHeight}`);
        }
        
        // ESP32 æ¨¡å¼ï¼šåº”ç”¨æ—‹è½¬å’Œé•œåƒå˜æ¢
        function drawBitmapToCanvasESP32(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight) {
            if (!bitmapData) {
                console.error(`[drawBitmapToCanvasESP32] é”™è¯¯: bitmapDataä¸ºnullæˆ–undefined`);
                return;
            }
            
            console.log(`[drawBitmapToCanvasESP32] å¼€å§‹ç»˜åˆ¶: origSize=${origWidth}x${origHeight}, displaySize=${displayWidth}x${displayHeight}, dataSize=${bitmapData.length}`);
            const scaleX = displayWidth / origHeight;   
            const scaleY = displayHeight / origWidth;   
            const bytesPerRow = Math.ceil(origWidth / 8);
            const expectedDataSize = bytesPerRow * origHeight;
            
            console.log(`[drawBitmapToCanvasESP32] è®¡ç®—å‚æ•°: bytesPerRow=${bytesPerRow}, expectedDataSize=${expectedDataSize}, scaleX=${scaleX}, scaleY=${scaleY}`);
            
            if (bitmapData.length < expectedDataSize) {
                console.warn(`[drawBitmapToCanvasESP32] è­¦å‘Š: ä½å›¾æ•°æ®ä¸å®Œæ•´ã€‚æœŸæœ› ${expectedDataSize} å­—èŠ‚ï¼Œå®é™… ${bitmapData.length} å­—èŠ‚`);
            }
            
            const imageData = ctx.createImageData(displayWidth, displayHeight);
            const data = imageData.data;
            
            console.log(`[drawBitmapToCanvasESP32] ImageDataå·²åˆ›å»º: ${displayWidth}x${displayHeight}, æ€»åƒç´ : ${displayWidth * displayHeight}`);
            
            for (let y = 0; y < origHeight; y++) {
                for (let x = 0; x < origWidth; x++) {
                    const byteIndex = y * bytesPerRow + Math.floor(x / 8);
                    const bitPosition = 7 - (x % 8);
                    let pixelColor = [255, 255, 255, 255]; 
                    
                    if (byteIndex < bitmapData.length) {
                        const pixelValue = (bitmapData[byteIndex] >> bitPosition) & 1;
                        if (pixelValue) {  
                            pixelColor = [255, 255, 255, 255]; 
                        } else {  
                            pixelColor = [0, 0, 0, 255];       
                        }
                    }
                    
                    // ESP32 æ¨¡å¼ï¼šåº”ç”¨æ°´å¹³é•œåƒå’Œæ—‹è½¬90åº¦
                    const mirroredX = origWidth - 1 - x;
                    const rotatedX = y;                        
                    const rotatedY = origWidth - 1 - mirroredX; 
                    const displayX = Math.floor(rotatedX * scaleX);
                    const displayY = Math.floor(rotatedY * scaleY);
                    const pixelWidth = Math.ceil(scaleX);
                    const pixelHeight = Math.ceil(scaleY);
                    
                    for (let dy = 0; dy < pixelHeight && displayY + dy < displayHeight; dy++) {
                        for (let dx = 0; dx < pixelWidth && displayX + dx < displayWidth; dx++) {
                            const imgIdx = ((displayY + dy) * displayWidth + (displayX + dx)) * 4;
                            data[imgIdx] = pixelColor[0];     // R
                            data[imgIdx + 1] = pixelColor[1]; // G
                            data[imgIdx + 2] = pixelColor[2]; // B
                            data[imgIdx + 3] = pixelColor[3]; // A
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            console.log(`âœ“ [drawBitmapToCanvasESP32] ä½å›¾å·²ç»˜åˆ¶åˆ°Canvasï¼Œå¤§å°: ${displayWidth}x${displayHeight}`);
        }
        
        function drawBitmapToCanvas(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight) {
            if (!bitmapData) {
                console.error(`[drawBitmapToCanvas] é”™è¯¯: bitmapDataä¸ºnullæˆ–undefined`);
                return;
            }
            
            console.log(`[drawBitmapToCanvas] å¼€å§‹ç»˜åˆ¶: origSize=${origWidth}x${origHeight}, displaySize=${displayWidth}x${displayHeight}, dataSize=${bitmapData.length}`);
            
            // æ£€æŸ¥è¿è¡Œç¯å¢ƒ
            const isESP32Mode = g_env && g_env.isESP32;
            console.log(`[drawBitmapToCanvas] ç¯å¢ƒ: ${isESP32Mode ? 'ESP32æ¨¡å¼' : 'PCæ¨¡å¼'}`);
            
            if (isESP32Mode) {
                drawBitmapToCanvasESP32(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight);
            } else {
                drawBitmapToCanvasPC(ctx, bitmapData, origWidth, origHeight, displayWidth, displayHeight);
            }
        }
        
        
        
        let currentTTFFont = null;  // å­˜å‚¨ä¸Šä¼ çš„TTFå­—ä½“çš„ Data URL
        let currentTTFFile = null;  // å­˜å‚¨ä¸Šä¼ çš„TTFæ–‡ä»¶å¯¹è±¡
        let currentFontName = '';   // å­—ä½“åç§°
        let fontCanvas = null;      // é¢„è§ˆç”¨çš„ Canvas
        let fontContext = null;     // Canvas ä¸Šä¸‹æ–‡
        
        // ===== å›¾ç‰‡ç›¸å…³å…¨å±€å˜é‡ =====
        let currentImageFile = null;     // å­˜å‚¨ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶
        let currentImageData = null;     // å­˜å‚¨å›¾ç‰‡çš„ Data URL
        let srcImageCanvas = null;       // æºå›¾ç‰‡ Canvas
        let dstImageCanvas = null;       // å¤„ç†åçš„å›¾ç‰‡ Canvas
        let processedBitmapData = null;  // å¤„ç†åçš„ä½å›¾æ•°æ®
        
        let currentScreenMode = 'main'; // 'main' æˆ– 'vocab'
        let currentLayout = {
            screen: { width: 416, height: 240 },
            rectangles: [],
            status_rect_index: 0
        };

        // è·å–å½“å‰APIç«¯ç‚¹
        function getApiEndpoints() {
            if (currentScreenMode === 'vocab') {
                return {
                    get: '/getvocablayout',
                    set: '/setvocablayout'
                };
            } else {
                return {
                    get: '/getlayout',
                    set: '/setlayout'
                };
            }
        }

        // åˆ‡æ¢ç•Œé¢æ¨¡å¼
        function switchScreenMode() {
            const select = document.getElementById('screenMode');
            currentScreenMode = select.value;
            console.log('åˆ‡æ¢åˆ°' + (currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢') + 'ç¼–è¾‘æ¨¡å¼');

            // æ§åˆ¶æ–‡æœ¬ç®¡ç†é¢æ¿çš„æ˜¾ç¤º
            const textManagementGroup = document.getElementById('textManagementGroup');
            if (textManagementGroup) {
                if (currentScreenMode === 'vocab') {
                    textManagementGroup.style.display = 'block';
                } else {
                    textManagementGroup.style.display = 'none';
                }
            }

            // æ§åˆ¶ç„¦ç‚¹é…ç½®é¢æ¿çš„æ˜¾ç¤ºï¼ˆä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºï¼‰
            const focusConfigGroup = document.getElementById('focusConfigGroup');
            if (focusConfigGroup) {
                // ä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºç„¦ç‚¹é…ç½®
                focusConfigGroup.style.display = 'block';
            }

            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            document.getElementById('loadingOverlay').style.display = 'flex';

            // é‡æ–°åŠ è½½å¸ƒå±€å’Œç„¦ç‚¹é…ç½®
            setTimeout(() => {
                getCurrentLayoutFromDevice();
                // åŠ è½½å¯¹åº”ç•Œé¢çš„ç„¦ç‚¹é…ç½®
                loadFocusConfig();
                // åŠ è½½å¯¹åº”ç•Œé¢çš„å­æ•°ç»„é…ç½®
                loadSubArrayConfig();
            }, 300);
        }

        let selectedRectIndex = -1;
        let selectedIconIndex = -1;
        let draggedIconElement = null;
        let currentDropTargetIndex = -1; // å½“å‰æ‹–æ‹½ç›®æ ‡çŸ©å½¢ç´¢å¼•


        // åˆå§‹åŒ–
        function init() {
            // æ£€æµ‹è¿è¡Œç¯å¢ƒ
            detectEnvironment();
            
            // åˆå§‹åŒ–æ–‡æœ¬ç®¡ç†é¢æ¿å¯è§æ€§
            const textManagementGroup = document.getElementById('textManagementGroup');
            if (textManagementGroup) {
                textManagementGroup.style.display = currentScreenMode === 'vocab' ? 'block' : 'none';
            }

            // åˆå§‹åŒ–ç„¦ç‚¹é…ç½®é¢æ¿å¯è§æ€§ï¼ˆä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºï¼‰
            const focusConfigGroup = document.getElementById('focusConfigGroup');
            if (focusConfigGroup) {
                // ä¸»ç•Œé¢å’Œå•è¯ç•Œé¢éƒ½æ˜¾ç¤ºç„¦ç‚¹é…ç½®
                focusConfigGroup.style.display = 'block';
            }

            // åˆå§‹åŒ–å›¾æ ‡æ–‡ä»¶é€‰æ‹©
            initIconFileSelector();

            // åˆå§‹åŒ–ä½å›¾æ–‡ä»¶é€‰æ‹©
            initBitmapFileSelector();

            drawGridLines();
            // è®¾ç½®é»˜è®¤å¸ƒå±€ä½†ä¸ç«‹å³æ¸²æŸ“
            //setDefaultLayout();
            // ç„¶åå°è¯•ä»è®¾å¤‡è·å–å¸ƒå±€å’Œç„¦ç‚¹é…ç½®
            getCurrentLayoutFromDevice();
            // åˆå§‹åŒ–æ—¶åŠ è½½ç„¦ç‚¹é…ç½®å’Œå­æ•°ç»„é…ç½®
            setTimeout(() => {
                loadFocusConfig();
                loadSubArrayConfig();
            }, 500);
        }

        // åˆå§‹åŒ–å›¾æ ‡æ–‡ä»¶é€‰æ‹©å™¨
        function initIconFileSelector() {
            const fileInput = document.getElementById('iconFileInput');
            if (!fileInput) return;

            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) return;

                // è·å–æ–‡ä»¶åï¼ˆä¸å«è·¯å¾„ï¼‰
                const fileName = file.name;
                
                // æ›´æ–°æ˜¾ç¤ºçš„æ–‡ä»¶å
                document.getElementById('iconFileName').value = fileName;
                
                // ä»æ–‡ä»¶åè§£æå›¾æ ‡ç´¢å¼•
                const iconIndex = extractIconIndexFromFileName(fileName);
                
                if (iconIndex < 0 || iconIndex > 12) {
                    showStatus(`æ— æ•ˆçš„å›¾æ ‡æ–‡ä»¶ï¼š${fileName}ã€‚æ–‡ä»¶åæ ¼å¼åº”ä¸ºï¼š{index}_{name}.bin`, 'error');
                    document.getElementById('iconFileInput').value = '';
                    document.getElementById('iconFileName').value = '';
                    return;
                }
                
                showStatus(`å·²é€‰æ‹©å›¾æ ‡æ–‡ä»¶ï¼š${fileName} (ç´¢å¼•: ${iconIndex})`, 'success');
                
                // å­˜å‚¨é€‰ä¸­çš„ç´¢å¼•ä¾› addIconToSelectedRect ä½¿ç”¨
                window.selectedIconIndex = iconIndex;
            });
        }

        // ä»æ–‡ä»¶åä¸­æå–å›¾æ ‡ç´¢å¼•
        // æ–‡ä»¶åæ ¼å¼: {index}_{name}.bin ä¾‹å¦‚: 0_icon1_62x64.bin
        function extractIconIndexFromFileName(fileName) {
            // ç§»é™¤ .bin æ‰©å±•å
            const nameWithoutExt = fileName.replace(/\.bin$/i, '');
            
            // æå–ç¬¬ä¸€ä¸ªæ•°å­—æˆ–æ•°å­—ç»„
            const match = nameWithoutExt.match(/^(\d+)/);
            if (match) {
                return parseInt(match[1], 10);
            }
            
            return -1;  // æ— æ•ˆçš„æ ¼å¼
        }

        /**
         * åˆå§‹åŒ–ä½å›¾æ–‡ä»¶é€‰æ‹©å™¨
         */
        function initBitmapFileSelector() {
            const fileInput = document.getElementById('bitmapFileInput');
            if (!fileInput) return;

            fileInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) return;

                // è·å–æ–‡ä»¶åï¼ˆä¸å«è·¯å¾„ï¼‰
                const fileName = file.name;
                
                // è¯»å–æ–‡ä»¶å†…å®¹ä½œä¸ºæ•°æ®
                const reader = new FileReader();
                reader.onload = function(e) {
                    // å­˜å‚¨ä½å›¾æ–‡ä»¶æ•°æ®ä¾›åç»­ä½¿ç”¨
                    generatedImageBinData = new Blob([e.target.result], { type: 'application/octet-stream' });
                    generatedImageBinFilename = fileName;

                    // ä»æ–‡ä»¶åæå–å°ºå¯¸ä¿¡æ¯
                    extractBitmapIndexFromFileName(fileName);

                    const width = window.generatedBitmapWidth || 0;
                    const height = window.generatedBitmapHeight || 0;

                    showStatus(`âœ… å·²é€‰æ‹©ä½å›¾æ–‡ä»¶ï¼š${fileName} (å°ºå¯¸: ${width}x${height})`, 'success');

                    // æ˜¾ç¤ºæ·»åŠ æŒ‰é’®
                    document.getElementById('addBitmapBtn').style.display = 'inline-block';
                };

                reader.onerror = function() {
                    showStatus(`âŒ è¯»å–ä½å›¾æ–‡ä»¶å¤±è´¥: ${fileName}`, 'error');
                    document.getElementById('bitmapFileInput').value = '';
                };

                reader.readAsArrayBuffer(file);
            });
        }


        // æ·»åŠ ä¸€ä¸ªè®¾ç½®é»˜è®¤å¸ƒå±€ä½†ä¸æ¸²æŸ“çš„å‡½æ•°
        function setDefaultLayout() {
            currentLayout = {
                screen: { width: 416, height: 240 },
                rectangles: [],
                status_rect_index: 0
            };

            // æ·»åŠ ä¸»ç•Œé¢é»˜è®¤çŸ©å½¢ï¼ˆ7ä¸ªæ¡†æ¶ï¼‰
            const defaultRects = [
                // çŸ©å½¢0ï¼šçŠ¶æ€æ 
                { x: 0, y: 0, width: 416, height: 36, icon_count: 0, icons: [] },

                // çŸ©å½¢1ï¼šå·¦ä¸ŠåŒºåŸŸ - 3ä¸ªå›¾æ ‡
                {
                    x: 0, y: 40, width: 138, height: 100, icon_count: 3, icons: [
                        { icon_index: 0, rel_x: 0.2, rel_y: 0.2, original_width: 62, original_height: 64 },
                        { icon_index: 1, rel_x: 0.6, rel_y: 0.2, original_width: 64, original_height: 64 },
                        { icon_index: 2, rel_x: 0.4, rel_y: 0.6, original_width: 86, original_height: 64 }
                    ]
                },

                // çŸ©å½¢2ï¼šä¸­ä¸ŠåŒºåŸŸ - 2ä¸ªå›¾æ ‡
                {
                    x: 142, y: 40, width: 132, height: 100, icon_count: 2, icons: [
                        { icon_index: 3, rel_x: 0.3, rel_y: 0.3, original_width: 71, original_height: 56 },
                        { icon_index: 4, rel_x: 0.6, rel_y: 0.5, original_width: 76, original_height: 56 }
                    ]
                },

                // çŸ©å½¢3ï¼šå³ä¸ŠåŒºåŸŸ - 2ä¸ªå›¾æ ‡
                {
                    x: 278, y: 40, width: 138, height: 100, icon_count: 2, icons: [
                        { icon_index: 5, rel_x: 0.2, rel_y: 0.4, original_width: 94, original_height: 64 },
                        { icon_index: 0, rel_x: 0.6, rel_y: 0.4, original_width: 62, original_height: 64 }
                    ]
                },

                // çŸ©å½¢4ï¼šå·¦ä¸‹åŒºåŸŸ - 4ä¸ªå›¾æ ‡
                {
                    x: 0, y: 144, width: 138, height: 96, icon_count: 4, icons: [
                        { icon_index: 1, rel_x: 0.15, rel_y: 0.2, original_width: 64, original_height: 64 },
                        { icon_index: 2, rel_x: 0.35, rel_y: 0.2, original_width: 86, original_height: 64 },
                        { icon_index: 3, rel_x: 0.6, rel_y: 0.2, original_width: 71, original_height: 56 },
                        { icon_index: 4, rel_x: 0.4, rel_y: 0.6, original_width: 76, original_height: 56 }
                    ]
                },

                // çŸ©å½¢5ï¼šä¸­ä¸‹åŒºåŸŸ - 3ä¸ªå›¾æ ‡
                {
                    x: 142, y: 144, width: 132, height: 96, icon_count: 3, icons: [
                        { icon_index: 5, rel_x: 0.2, rel_y: 0.2, original_width: 94, original_height: 64 },
                        { icon_index: 0, rel_x: 0.3, rel_y: 0.6, original_width: 62, original_height: 64 },
                        { icon_index: 1, rel_x: 0.6, rel_y: 0.6, original_width: 64, original_height: 64 }
                    ]
                },

                // çŸ©å½¢6ï¼šå³ä¸‹åŒºåŸŸ - 1ä¸ªå›¾æ ‡
                {
                    x: 278, y: 144, width: 138, height: 96, icon_count: 1, icons: [
                        { icon_index: 2, rel_x: 0.5, rel_y: 0.5, original_width: 86, original_height: 64 }
                    ]
                }
            ];

            defaultRects.forEach((rect, index) => {
                currentLayout.rectangles.push({
                    ...rect,
                    original_x: rect.x,
                    original_y: rect.y,
                    original_width: rect.width,
                    original_height: rect.height,
                    is_status_bar: index === 0
                });
            });
        }

        // ç»˜åˆ¶ç½‘æ ¼çº¿
        function drawGridLines() {
            const gridLines = document.getElementById('gridLines');
            if (!gridLines) {
                console.warn('gridLines å…ƒç´ ä¸å­˜åœ¨');
                return;
            }

            // æ¸…ç©ºä¹‹å‰çš„ç½‘æ ¼çº¿
            gridLines.innerHTML = '';

            const gridSize = 20;
            const screenWidth = currentLayout.screen.width || 416;
            const screenHeight = currentLayout.screen.height || 240;

            // å‚ç›´çº¿
            for (let x = gridSize; x < screenWidth; x += gridSize) {
                const line = document.createElement('div');
                line.className = 'grid-line vertical';
                line.style.position = 'absolute';
                line.style.left = x + 'px';
                line.style.top = '0';
                line.style.width = '1px';
                line.style.height = '100%';
                line.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                line.style.pointerEvents = 'none';
                gridLines.appendChild(line);
            }

            // æ°´å¹³çº¿
            for (let y = gridSize; y < screenHeight; y += gridSize) {
                const line = document.createElement('div');
                line.className = 'grid-line horizontal';
                line.style.position = 'absolute';
                line.style.left = '0';
                line.style.top = y + 'px';
                line.style.width = '100%';
                line.style.height = '1px';
                line.style.backgroundColor = 'rgba(0, 0, 0, 0.05)';
                line.style.pointerEvents = 'none';
                gridLines.appendChild(line);
            }
        }

        // ä»è®¾å¤‡è·å–å½“å‰å¸ƒå±€
        async function getCurrentLayoutFromDevice() {
            console.log('å¼€å§‹è·å–å¸ƒå±€æ•°æ®...');
            const endpoints = getApiEndpoints();
            const screenName = currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢';
            showLoading('æ­£åœ¨è·å–' + screenName + 'å¸ƒå±€...');

            try {
                const response = await fetchWithFallback(endpoints.get, endpoints.get);
                console.log('HTTPå“åº”çŠ¶æ€:', response.status, response.statusText);

                if (!response.ok) {
                    throw new Error(`HTTPé”™è¯¯: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                console.log('è·å–åˆ°JSONæ•°æ®:', data);

                // æ•°æ®éªŒè¯
                if (!data) {
                    throw new Error('æœåŠ¡å™¨è¿”å›ç©ºæ•°æ®');
                }

                // ç¡®ä¿æ•°æ®æ ¼å¼æ­£ç¡®
                if (!data.rectangles || !Array.isArray(data.rectangles)) {
                    console.warn('rectangles ä¸æ˜¯æ•°ç»„æˆ–ä¸å­˜åœ¨ï¼Œå°è¯•ä¿®å¤...');
                    data.rectangles = [];
                }

                // å­˜å‚¨ä»è®¾å¤‡è·å–çš„å›¾æ ‡å°ºå¯¸
                if (data.rectangles && Array.isArray(data.rectangles)) {
                    data.rectangles.forEach((rect, rectIndex) => {
                        if (rect.icons && Array.isArray(rect.icons)) {
                            rect.icons.forEach((icon, iconIndex) => {
                                // è®°å½•å›¾æ ‡å°ºå¯¸
                                console.log(`çŸ©å½¢ ${rectIndex} å›¾æ ‡ ${iconIndex}: å°ºå¯¸=${icon.display_width || 30}x${icon.display_height || 30}`);
                            });
                        }
                        // æ·»åŠ æ–‡æœ¬æ•°æ®è°ƒè¯•
                        if (rect.texts && Array.isArray(rect.texts)) {
                            console.log(`çŸ©å½¢ ${rectIndex} æ–‡æœ¬æ•°æ®:`, rect.texts);
                        } else {
                            console.log(`çŸ©å½¢ ${rectIndex} æ²¡æœ‰æ–‡æœ¬æ•°æ®`);
                        }
                    });
                }

                // è°ƒç”¨ renderLayout å¹¶ä¼ é€’æ•°æ®
                renderLayout(data);
                return data;

            } catch (error) {
                console.error('è·å–å¸ƒå±€å¤±è´¥:', error);
                showStatus('è·å–å¸ƒå±€å¤±è´¥: ' + error.message, 'error');
                return null;
            } finally {
                hideLoading();
            }
        }

        function renderLayout(layout) {
            console.log('renderLayout æ¥æ”¶åˆ°æ•°æ®:', layout);

            try {
                if (!layout) {
                    throw new Error('å¸ƒå±€æ•°æ®ä¸ºç©º');
                }

                const container = document.getElementById('screenContainer');
                if (!container) {
                    throw new Error('screenContainer å…ƒç´ ä¸å­˜åœ¨');
                }

                // æ¸…ç©ºå®¹å™¨å†…å®¹ï¼ˆé™¤äº†ç½‘æ ¼çº¿å’Œå¯¹é½è¾…åŠ©çº¿ï¼‰
                const children = Array.from(container.children);
                console.log(`[renderLayout] å‡†å¤‡æ¸…ç©ºå®¹å™¨ï¼Œå½“å‰å­å…ƒç´ æ•°: ${children.length}`);
                children.forEach(child => {
                    if (child.id !== 'gridLines' && child.id !== 'alignmentGuides') {
                        container.removeChild(child);
                    }
                });
                console.log(`[renderLayout] å®¹å™¨å·²æ¸…ç©º`);

                // éªŒè¯å±å¹•å°ºå¯¸
                const screenWidth = layout.screen_width || 416;
                const screenHeight = layout.screen_height || 240;

                console.log(`å±å¹•å°ºå¯¸: ${screenWidth}x${screenHeight}`);

                // æ›´æ–°å±å¹•å®¹å™¨çš„å°ºå¯¸
                container.style.width = screenWidth + 'px';
                container.style.height = screenHeight + 'px';

                // æ›´æ–°æ˜¾ç¤ºçš„å±å¹•å°ºå¯¸
                const screenSizeSpan = document.getElementById('screenSize');
                if (screenSizeSpan) {
                    screenSizeSpan.textContent = `${screenWidth}Ã—${screenHeight}`;
                }

                // æ›´æ–°å±å¹•è®¾ç½®è¾“å…¥æ¡†çš„å€¼
                const screenWidthInput = document.getElementById('screenWidth');
                const screenHeightInput = document.getElementById('screenHeight');
                if (screenWidthInput) screenWidthInput.value = screenWidth;
                if (screenHeightInput) screenHeightInput.value = screenHeight;

                // æ›´æ–° currentLayout çš„å±å¹•å°ºå¯¸
                currentLayout.screen.width = screenWidth;
                currentLayout.screen.height = screenHeight;

                // æ›´æ–° currentLayout çš„çŸ©å½¢æ•°æ®
                if (layout.rectangles && Array.isArray(layout.rectangles)) {
                    currentLayout.rectangles = layout.rectangles.map((rect, index) => {
                        if (!rect) return null;

                        const newRect = {
                            x: rect.x || 0,
                            y: rect.y || 0,
                            width: rect.width || 0,
                            height: rect.height || 0,
                            original_x: rect.original_x || rect.x || 0,
                            original_y: rect.original_y || rect.y || 0,
                            original_width: rect.original_width || rect.width || 0,
                            original_height: rect.original_height || rect.height || 0,
                            icon_count: rect.icon_count || (rect.icons ? rect.icons.length : 0),
                            text_count: rect.text_count || (rect.texts ? rect.texts.length : 0),
                            icons: rect.icons || [],
                            texts: rect.texts || [], // æ·»åŠ æ–‡æœ¬æ•°ç»„æ”¯æŒ
                            is_status_bar: rect.is_status_bar || index === 0,
                            bitmap: rect.bitmap || null  // ä¿ç•™ä½å›¾æ•°æ®ï¼
                        };

                        // ç¡®ä¿æ¯ä¸ªå›¾æ ‡éƒ½æœ‰å®Œæ•´çš„æ•°æ®
                        if (newRect.icons && Array.isArray(newRect.icons)) {
                            newRect.icons.forEach((icon, iconIndex) => {
                                if (icon) {
                                    // è·å–è¯¥å›¾æ ‡çš„çœŸå®å°ºå¯¸ï¼ˆä»ICON_METADATAä¸­ï¼‰
                                    const iconIndex_actual = icon.icon_index !== undefined ? icon.icon_index : iconIndex;
                                    const iconMeta = ICON_METADATA[iconIndex_actual];
                                    const trueWidth = iconMeta ? iconMeta.width : 30;
                                    const trueHeight = iconMeta ? iconMeta.height : 30;
                                    
                                    // è®¾ç½®æ˜¾ç¤ºå°ºå¯¸ï¼šå¦‚æœæ˜¯é»˜è®¤çš„30x30ï¼Œå°±ç”¨çœŸå®å°ºå¯¸ï¼›å¦åˆ™ä½¿ç”¨ä»æ•°æ®ä¸­è¯»å–çš„å€¼
                                    const displayW = (icon.display_width === 30 && trueWidth !== 30) ? trueWidth : (icon.display_width || trueWidth);
                                    const displayH = (icon.display_height === 30 && trueHeight !== 30) ? trueHeight : (icon.display_height || trueHeight);
                                    
                                    // ç¡®ä¿æœ‰æ˜¾ç¤ºä½ç½®å’Œå°ºå¯¸
                                    icon.display_x = icon.display_x || newRect.x + (newRect.width - displayW) * (icon.rel_x || 0.5);
                                    icon.display_y = icon.display_y || newRect.y + (newRect.height - displayH) * (icon.rel_y || 0.5);
                                    icon.display_width = displayW;
                                    icon.display_height = displayH;

                                    console.log(`çŸ©å½¢ ${index} å›¾æ ‡ ${iconIndex}: ä½ç½®(${icon.display_x},${icon.display_y}), å°ºå¯¸(${icon.display_width}x${icon.display_height}), çœŸå®å°ºå¯¸(${trueWidth}x${trueHeight})`);
                                }
                            });
                        }

                        return newRect;
                    }).filter(rect => rect !== null);
                } else {
                    currentLayout.rectangles = [];
                }

                // æ›´æ–°çŸ©å½¢å’Œå›¾æ ‡è®¡æ•°
                const rectCountSpan = document.getElementById('rectCount');
                const iconCountSpan = document.getElementById('iconCount');
                if (rectCountSpan) {
                    rectCountSpan.textContent = currentLayout.rectangles.length;
                }
                if (iconCountSpan) {
                    const totalIcons = currentLayout.rectangles.reduce((sum, rect) => sum + (rect.icons ? rect.icons.length : 0), 0);
                    iconCountSpan.textContent = totalIcons;
                }

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                drawGridLines();

                // æ¸²æŸ“çŸ©å½¢
                if (currentLayout.rectangles && Array.isArray(currentLayout.rectangles)) {
                    console.log(`æ‰¾åˆ° ${currentLayout.rectangles.length} ä¸ªçŸ©å½¢`);

                    currentLayout.rectangles.forEach((rect, index) => {
                        try {
                            // éªŒè¯çŸ©å½¢æ•°æ®
                            if (!rect) {
                                console.warn(`çŸ©å½¢ ${index} æ•°æ®ä¸ºç©º`);
                                return;
                            }

                            // æ£€æŸ¥å¿…éœ€çš„å±æ€§
                            if (rect.x === undefined || rect.y === undefined || rect.width === undefined || rect.height === undefined) {
                                console.error(`çŸ©å½¢ ${index} ç¼ºå°‘å¿…éœ€å±æ€§:`, rect);
                                return;
                            }

                            console.log(`æ¸²æŸ“çŸ©å½¢ ${index}:`, {
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: rect.height,
                                icon_count: rect.icon_count
                            });

                            // åˆ›å»ºçŸ©å½¢å…ƒç´ 
                            const rectDiv = document.createElement('div');
                            rectDiv.className = 'rect';
                            rectDiv.dataset.index = index;
                            rectDiv.style.position = 'absolute';
                            rectDiv.style.left = rect.x + 'px';
                            rectDiv.style.top = rect.y + 'px';
                            rectDiv.style.width = rect.width + 'px';
                            rectDiv.style.height = rect.height + 'px';
                            rectDiv.style.border = '2px solid #4CAF50';
                            rectDiv.style.backgroundColor = rect.is_status_bar ?
                                'rgba(0, 100, 200, 0.2)' : 'rgba(76, 175, 80, 0.1)';
                            rectDiv.style.boxSizing = 'border-box';
                            rectDiv.style.cursor = 'move';

                            // ç‚¹å‡»äº‹ä»¶å°†ç”± makeDraggable å¤„ç†

                            // ä½¿çŸ©å½¢å¯æ‹–æ‹½
                            makeDraggable(rectDiv, index, 'rect');

                            // æ·»åŠ çŸ©å½¢ç¼–å·æ ‡ç­¾
                            const label = document.createElement('div');
                            label.textContent = `${index}`;
                            label.style.position = 'absolute';
                            label.style.top = '2px';
                            label.style.left = '2px';
                            label.style.fontSize = '10px';
                            label.style.fontWeight = 'bold';
                            label.style.color = rect.is_status_bar ? '#0066cc' : '#4CAF50';
                            rectDiv.appendChild(label);

                            // æ·»åŠ è°ƒæ•´å¤§å°çš„æ‰‹æŸ„
                            const handleSE = document.createElement('div');
                            handleSE.className = 'resize-handle se';
                            rectDiv.appendChild(handleSE);
                            makeResizable(rectDiv, handleSE, index, 'se');

                            const handleE = document.createElement('div');
                            handleE.className = 'resize-handle e';
                            rectDiv.appendChild(handleE);
                            makeResizable(rectDiv, handleE, index, 'e');

                            const handleS = document.createElement('div');
                            handleS.className = 'resize-handle s';
                            rectDiv.appendChild(handleS);
                            makeResizable(rectDiv, handleS, index, 's');

                            container.appendChild(rectDiv);

                            // æ¸²æŸ“å›¾æ ‡ - ä½¿ç”¨Canvasæ˜¾ç¤ºä½å›¾å›¾æ ‡
                            if (rect.icons && Array.isArray(rect.icons)) {
                                rect.icons.forEach((icon, iconIndex) => {
                                    try {
                                        if (!icon) {
                                            console.warn(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} æ•°æ®ä¸ºç©º`);
                                            return;
                                        }

                                        // è·å–å›¾æ ‡çš„çœŸå®å°ºå¯¸ï¼ˆä»ICON_METADATAä¸­è·å–ï¼‰
                                        const actualIconIndex = icon.icon_index !== undefined ? icon.icon_index : iconIndex;
                                        const iconMetadata = ICON_METADATA[actualIconIndex];
                                        
                                        // ä¼˜å…ˆä½¿ç”¨ICON_METADATAä¸­çš„å°ºå¯¸ï¼Œå¦åˆ™ä½¿ç”¨display_width/display_heightï¼Œæœ€åæ‰ç”¨é»˜è®¤å€¼30x30
                                        const iconWidth = icon.display_width || (iconMetadata ? iconMetadata.width : 30);
                                        const iconHeight = icon.display_height || (iconMetadata ? iconMetadata.height : 30);

                                        // ä½¿ç”¨ç›¸å¯¹åæ ‡è®¡ç®—æ˜¾ç¤ºä½ç½®
                                        const relX = icon.rel_x !== undefined ? icon.rel_x : 0.5;
                                        const relY = icon.rel_y !== undefined ? icon.rel_y : 0.5;

                                        // è®¡ç®—ç»å¯¹ä½ç½®ï¼šçŸ©å½¢å·¦ä¸Šè§’ + ç›¸å¯¹ä½ç½® * çŸ©å½¢å°ºå¯¸ï¼ˆå›¾æ ‡å·¦ä¸Šè§’ä½ç½®ï¼‰
                                        const iconX = rect.x + relX * rect.width;
                                        const iconY = rect.y + relY * rect.height;

                                        console.log(`æ¸²æŸ“å›¾æ ‡ ${iconIndex} (ç´¢å¼•=${icon.icon_index}): ç›¸å¯¹(${relX.toFixed(2)},${relY.toFixed(2)}), ç»å¯¹ä½ç½®(${iconX.toFixed(1)},${iconY.toFixed(1)}), å°ºå¯¸(${iconWidth}x${iconHeight})`);

                                        // åˆ›å»º Canvas æ¥æ˜¾ç¤ºä½å›¾å›¾æ ‡
                                        const iconCanvas = document.createElement('canvas');
                                        iconCanvas.className = 'icon-canvas';
                                        iconCanvas.width = iconWidth;
                                        iconCanvas.height = iconHeight;
                                        iconCanvas.dataset.rectIndex = index;
                                        iconCanvas.dataset.iconIndex = iconIndex;
                                        iconCanvas.style.position = 'absolute';
                                        iconCanvas.style.left = iconX + 'px';
                                        iconCanvas.style.top = iconY + 'px';
                                        iconCanvas.style.borderRadius = '3px';
                                        iconCanvas.style.cursor = 'move';
                                        iconCanvas.style.boxSizing = 'border-box';
                                        iconCanvas.style.backgroundColor = '#FFFFFF';

                                        const ctx = iconCanvas.getContext('2d');
                                        
                                        // å¼‚æ­¥åŠ è½½å›¾æ ‡ä½å›¾æ•°æ®å¹¶ç»˜åˆ¶
                                        (async () => {
                                            try {
                                                const bitmapData = await getIconBitmapData(actualIconIndex);
                                                
                                                if (bitmapData && ICON_METADATA[actualIconIndex]) {
                                                    const meta = ICON_METADATA[actualIconIndex];
                                                    const isESP32Mode = g_env && g_env.isESP32;
                                                    // ESP32 æ¨¡å¼ä¸‹äº’æ¢å®½é«˜
                                                    const origWidth = isESP32Mode ? meta.height : meta.width;
                                                    const origHeight = isESP32Mode ? meta.width : meta.height;
                                                    drawBitmapToCanvas(ctx, bitmapData, origWidth, origHeight, iconWidth, iconHeight);
                                                    console.log(`âœ“ å›¾æ ‡ ${actualIconIndex} æ¸²æŸ“æˆåŠŸ`);
                                                } else {
                                                    // å¤±è´¥æ—¶æ˜¾ç¤ºå ä½ç¬¦
                                                    ctx.fillStyle = '#F0F0F0';
                                                    ctx.fillRect(0, 0, iconWidth, iconHeight);
                                                    ctx.fillStyle = '#FF5722';
                                                    ctx.font = 'bold 12px Arial';
                                                    ctx.textAlign = 'center';
                                                    ctx.textBaseline = 'middle';
                                                    ctx.fillText(`${actualIconIndex}`, iconWidth/2, iconHeight/2);
                                                    ctx.strokeStyle = '#FF5722';
                                                    ctx.lineWidth = 1;
                                                    ctx.strokeRect(0, 0, iconWidth, iconHeight);
                                                    console.log(`âš  å›¾æ ‡ ${actualIconIndex} åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºå ä½ç¬¦`);
                                                }
                                            } catch (error) {
                                                console.error(`å›¾æ ‡æ¸²æŸ“å‡ºé”™:`, error);
                                                // æ˜¾ç¤ºé”™è¯¯å ä½ç¬¦
                                                ctx.fillStyle = '#FFE0E0';
                                                ctx.fillRect(0, 0, iconWidth, iconHeight);
                                                ctx.fillStyle = '#FF0000';
                                                ctx.font = '10px Arial';
                                                ctx.textAlign = 'center';
                                                ctx.textBaseline = 'middle';
                                                ctx.fillText('ERROR', iconWidth/2, iconHeight/2);
                                            }
                                        })();

                                        // å°†Canvaså…ƒç´ æ·»åŠ åˆ°ä¸»å®¹å™¨ä¸­ï¼ˆå…¨å±€åæ ‡ï¼‰
                                        container.appendChild(iconCanvas);

                                        // ä¸ºå›¾æ ‡Canvasæ·»åŠ å¯æ‹–åŠ¨åŠŸèƒ½
                                        makeDraggable(iconCanvas, iconIndex, 'icon', index);

                                    } catch (iconError) {
                                        console.error(`æ¸²æŸ“å›¾æ ‡ ${iconIndex} å¤±è´¥:`, iconError);
                                    }
                                });
                            }

                            // æ¸²æŸ“ä½å›¾ - æ˜¾ç¤ºè½¬æ¢çš„å›¾ç‰‡
                            if (rect.bitmap) {
                                try {
                                    const bitmap = rect.bitmap;
                                    
                                    console.log(`[renderLayout] æ£€æµ‹åˆ°ä½å›¾åœ¨çŸ©å½¢ ${index}:`, bitmap.filename);
                                    console.log(`[renderLayout] çŸ©å½¢ä¿¡æ¯: x=${rect.x}, y=${rect.y}, w=${rect.width}, h=${rect.height}`);
                                    
                                    // ä½å›¾å°ºå¯¸
                                    const bitmapDisplayWidth = bitmap.display_width || Math.min(bitmap.width, rect.width * 0.8);
                                    const bitmapDisplayHeight = bitmap.display_height || Math.min(bitmap.height, rect.height * 0.8);
                                    
                                    // ä½å›¾ç›¸å¯¹ä½ç½®ï¼ˆé»˜è®¤å±…ä¸­ï¼‰
                                    const relX = bitmap.rel_x !== undefined ? bitmap.rel_x : 0.5;
                                    const relY = bitmap.rel_y !== undefined ? bitmap.rel_y : 0.5;
                                    
                                    // è®¡ç®—ç»å¯¹ä½ç½® - ç®€åŒ–é€»è¾‘ï¼šç›´æ¥åœ¨çŸ©å½¢å†…éƒ¨æ”¾ç½®
                                    const bitmapX = rect.x + (rect.width - bitmapDisplayWidth) / 2;   // æ°´å¹³å±…ä¸­
                                    const bitmapY = rect.y + (rect.height - bitmapDisplayHeight) / 2; // ç«–ç›´å±…ä¸­
                                    
                                    // ä¿å­˜ä½å›¾çš„displayä½ç½®ï¼ˆç”¨äºæ‹–åŠ¨çŸ©å½¢æ—¶ç§»åŠ¨ä½å›¾ï¼‰
                                    bitmap.display_x = bitmapX;
                                    bitmap.display_y = bitmapY;
                                    
                                    console.log(`[renderLayout] æ¸²æŸ“ä½å›¾: ç›¸å¯¹(${relX.toFixed(2)},${relY.toFixed(2)}), çŸ©å½¢èŒƒå›´(${rect.x},${rect.y}~${rect.x+rect.width},${rect.y+rect.height}), ä½å›¾ä½ç½®(${bitmapX.toFixed(1)},${bitmapY.toFixed(1)}), æ˜¾ç¤ºå°ºå¯¸(${bitmapDisplayWidth}x${bitmapDisplayHeight})`);
                                    
                                    // åˆ›å»ºä½å›¾ Canvas
                                    const bitmapCanvas = document.createElement('canvas');
                                    bitmapCanvas.className = 'bitmap-canvas';
                                    bitmapCanvas.width = bitmapDisplayWidth;
                                    bitmapCanvas.height = bitmapDisplayHeight;
                                    bitmapCanvas.dataset.rectIndex = index;
                                    bitmapCanvas.style.position = 'absolute';
                                    bitmapCanvas.style.left = bitmapX + 'px';
                                    bitmapCanvas.style.top = bitmapY + 'px';
                                    bitmapCanvas.style.cursor = 'move';
                                    bitmapCanvas.style.boxSizing = 'border-box';
                                    bitmapCanvas.style.zIndex = '1000';  // ç¡®ä¿åœ¨æœ€å‰é¢
                                    bitmapCanvas.style.display = 'block';  // æ˜¾å¼è®¾ç½®ä¸ºblock
                                    
                                    console.log(`[renderLayout] åˆ›å»ºä½å›¾Canvas: ${bitmapDisplayWidth}x${bitmapDisplayHeight}, ä½ç½®(${bitmapX}, ${bitmapY}), æ ·å¼å·²è®¾ç½®`);
                                    
                                    const ctx = bitmapCanvas.getContext('2d');
                                    
                                    // å¼‚æ­¥åŠ è½½å¹¶ç»˜åˆ¶ä½å›¾æ•°æ®
                                    (async () => {
                                        try {
                                            console.log(`[renderLayout] å¼€å§‹å¼‚æ­¥æ¸²æŸ“ä½å›¾æ•°æ®...`);
                                            
                                            // ä»ä¿å­˜çš„ä½å›¾æ•°æ®ä¸­è·å–æ•°æ®
                                            if (bitmap.bitmapData) {
                                                console.log(`[renderLayout] bitmap.bitmapDataå­˜åœ¨ï¼Œç±»å‹: ${bitmap.bitmapData.constructor.name}`);
                                                
                                                // è½¬æ¢ Blob ä¸º UInt8Array
                                                let bitmapDataArray;
                                                if (bitmap.bitmapData instanceof Blob) {
                                                    // ä» Blob è¯»å–æ•°æ®
                                                    const arrayBuffer = await bitmap.bitmapData.arrayBuffer();
                                                    const fullArray = new Uint8Array(arrayBuffer);
                                                    
                                                    console.log(`[renderLayout] Blobè½¬æ¢å®Œæˆï¼Œæ€»å¤§å°: ${fullArray.length} å­—èŠ‚`);
                                                    
                                                    // .bin æ–‡ä»¶æ ¼å¼: 4å­—èŠ‚å®½åº¦ + 4å­—èŠ‚é«˜åº¦ + ä½å›¾æ•°æ®
                                                    // è·³è¿‡å‰8å­—èŠ‚çš„æ–‡ä»¶å¤´
                                                    if (fullArray.length > 8) {
                                                        bitmapDataArray = fullArray.slice(8);
                                                        console.log(`[renderLayout] æ–‡ä»¶å¤´å·²ç§»é™¤ï¼Œä½å›¾æ•°æ®å¤§å°: ${bitmapDataArray.length} å­—èŠ‚ (åŸå§‹: ${fullArray.length})`);
                                                    } else {
                                                        bitmapDataArray = fullArray;
                                                        console.warn(`[renderLayout] æ–‡ä»¶å°äº8å­—èŠ‚ï¼Œå¯èƒ½ä¸æ˜¯æ ‡å‡†.binæ ¼å¼`);
                                                    }
                                                } else if (bitmap.bitmapData instanceof ArrayBuffer) {
                                                    const fullArray = new Uint8Array(bitmap.bitmapData);
                                                    if (fullArray.length > 8) {
                                                        bitmapDataArray = fullArray.slice(8);
                                                    } else {
                                                        bitmapDataArray = fullArray;
                                                    }
                                                } else if (bitmap.bitmapData instanceof Uint8Array) {
                                                    if (bitmap.bitmapData.length > 8) {
                                                        bitmapDataArray = bitmap.bitmapData.slice(8);
                                                    } else {
                                                        bitmapDataArray = bitmap.bitmapData;
                                                    }
                                                } else {
                                                    console.warn(`[renderLayout] ä½å›¾æ•°æ®ç±»å‹æœªçŸ¥: ${typeof bitmap.bitmapData}`);
                                                    bitmapDataArray = null;
                                                }

                                                if (bitmapDataArray && bitmapDataArray.length > 0) {
                                                    console.log(`[renderLayout] å¼€å§‹ç»˜åˆ¶ä½å›¾Canvasï¼Œæ•°æ®å¤§å°: ${bitmapDataArray.length}`);
                                                    // åˆ¤æ–­æ˜¯å¦ä¸ºç”¨æˆ·ä¸Šä¼ çš„ä½å›¾ï¼ˆæœ‰.binæ‰©å±•åï¼‰
                                                    if (bitmap.filename && bitmap.filename.endsWith('.bin')) {
                                                        // ç”¨æˆ·ä½å›¾ï¼šåº”ç”¨é¢œè‰²åè½¬ã€æ°´å¹³é•œåƒå’Œé¡ºæ—¶é’ˆæ—‹è½¬90åº¦
                                                        drawBitmapToCanvasForUser(ctx, bitmapDataArray, bitmap.width, bitmap.height, bitmapDisplayWidth, bitmapDisplayHeight);
                                                    } else {
                                                        // å›¾æ ‡ä½å›¾ï¼šä¿æŒåŸå§‹é€»è¾‘
                                                        drawBitmapToCanvas(ctx, bitmapDataArray, bitmap.width, bitmap.height, bitmapDisplayWidth, bitmapDisplayHeight);
                                                    }
                                                    console.log(`âœ“ [renderLayout] ä½å›¾æ¸²æŸ“æˆåŠŸ: ${bitmap.filename}`);
                                                } else {
                                                    throw new Error('ä½å›¾æ•°æ®ä¸ºç©ºæˆ–æ— æ•ˆ');
                                                }
                                            } else {
                                                console.log(`[renderLayout] bitmap.bitmapDataä¸å­˜åœ¨ï¼Œæ˜¾ç¤ºå ä½ç¬¦`);
                                                // æ˜¾ç¤ºå ä½ç¬¦
                                                ctx.fillStyle = '#F0F0F0';
                                                ctx.fillRect(0, 0, bitmapDisplayWidth, bitmapDisplayHeight);
                                                ctx.fillStyle = '#FF6B6B';
                                                ctx.font = 'bold 14px Arial';
                                                ctx.textAlign = 'center';
                                                ctx.textBaseline = 'middle';
                                                ctx.fillText(bitmap.filename || 'å›¾ç‰‡', bitmapDisplayWidth/2, bitmapDisplayHeight/2);
                                                console.log(`âš  [renderLayout] ä½å›¾æ•°æ®ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºå ä½ç¬¦`);
                                            }
                                        } catch (error) {
                                            console.error(`[renderLayout] ä½å›¾æ¸²æŸ“å‡ºé”™:`, error);
                                            ctx.fillStyle = '#FFE0E0';
                                            ctx.fillRect(0, 0, bitmapDisplayWidth, bitmapDisplayHeight);
                                            ctx.fillStyle = '#FF0000';
                                            ctx.font = '10px Arial';
                                            ctx.textAlign = 'center';
                                            ctx.textBaseline = 'middle';
                                            ctx.fillText('ERROR', bitmapDisplayWidth/2, bitmapDisplayHeight/2);
                                        }
                                    })();
                                    
                                    // æ·»åŠ åˆ°å®¹å™¨
                                    container.appendChild(bitmapCanvas);
                                    console.log(`[renderLayout] âœ“ Canvaså·²æ·»åŠ åˆ°å®¹å™¨ï¼ŒéªŒè¯: ${container.contains(bitmapCanvas) ? 'æˆåŠŸ' : 'å¤±è´¥'}, å®¹å™¨å†…Canvasæ€»æ•°: ${container.querySelectorAll('canvas.bitmap-canvas').length}`);
                                    
                                    // æ·»åŠ å¯æ‹–åŠ¨åŠŸèƒ½
                                    makeDraggable(bitmapCanvas, index, 'bitmap', index);
                                    
                                    // æ·»åŠ è°ƒæ•´å¤§å°çš„æ‰‹æŸ„
                                    const bitmapHandle = document.createElement('div');
                                    bitmapHandle.className = 'resize-handle se';
                                    bitmapHandle.style.width = '10px';
                                    bitmapHandle.style.height = '10px';
                                    bitmapHandle.style.position = 'absolute';
                                    bitmapHandle.style.bottom = '-5px';
                                    bitmapHandle.style.right = '-5px';
                                    bitmapHandle.style.backgroundColor = '#FF6B6B';
                                    bitmapHandle.style.cursor = 'nwse-resize';
                                    bitmapHandle.style.zIndex = '10';
                                    bitmapCanvas.appendChild(bitmapHandle);
                                    
                                } catch (bitmapError) {
                                    console.error(`æ¸²æŸ“ä½å›¾å¤±è´¥:`, bitmapError);
                                }
                            }

                            // æ¸²æŸ“æ–‡æœ¬å…ƒç´  - æ–°å¢åŠŸèƒ½
                            console.log(`çŸ©å½¢ ${index} çš„æ–‡æœ¬æ•°æ®:`, rect.texts, `æ–‡æœ¬æ•°é‡: ${rect.texts ? rect.texts.length : 0}`);

                            if (rect.texts && Array.isArray(rect.texts) && rect.texts.length > 0) {
                                console.log(`çŸ©å½¢ ${index} å¼€å§‹æ¸²æŸ“ ${rect.texts.length} ä¸ªæ–‡æœ¬`);
                                rect.texts.forEach((text, textIndex) => {
                                    try {
                                        if (!text) {
                                            console.warn(`çŸ©å½¢ ${index} çš„æ–‡æœ¬ ${textIndex} æ•°æ®ä¸ºç©º`);
                                            return;
                                        }

                                        // è·å–æ–‡æœ¬å‚æ•°
                                        const relX = text.rel_x !== undefined ? text.rel_x : 0.5;
                                        const relY = text.rel_y !== undefined ? text.rel_y : 0.5;
                                        const fontSize = text.font_size || 16;
                                        const content = text.content || '';
                                        const contentType = text.content_type || 0;
                                        const hAlign = text.h_align || 1; // 0=left, 1=center, 2=right
                                        const vAlign = text.v_align || 1; // 0=top, 1=middle, 2=bottom

                                        // è®¡ç®—æ–‡æœ¬ä½ç½®ï¼ˆåŸºäºå¯¹é½æ–¹å¼ï¼‰
                                        const textX = rect.x + relX * rect.width;
                                        const textY = rect.y + relY * rect.height;

                                        console.log(`æ¸²æŸ“æ–‡æœ¬ ${textIndex} (ç±»å‹=${contentType}): ç›¸å¯¹(${relX.toFixed(2)},${relY.toFixed(2)}), ç»å¯¹ä½ç½®(${textX.toFixed(1)},${textY.toFixed(1)}), å†…å®¹="${content}"`);

                                        // åˆ›å»ºæ–‡æœ¬å…ƒç´ 
                                        const textDiv = document.createElement('div');
                                        textDiv.className = 'text-element';
                                        textDiv.dataset.rectIndex = index;
                                        textDiv.dataset.textIndex = textIndex;
                                        textDiv.style.position = 'absolute';
                                        textDiv.style.left = textX + 'px';
                                        textDiv.style.top = textY + 'px';
                                        textDiv.style.fontSize = fontSize + 'px';
                                        textDiv.style.color = '#333';
                                        textDiv.style.cursor = 'move';
                                        textDiv.style.userSelect = 'none';
                                        textDiv.style.whiteSpace = 'nowrap';
                                        textDiv.style.border = '1px dashed #9C27B0';
                                        textDiv.style.padding = '2px 4px';
                                        textDiv.style.backgroundColor = 'rgba(156, 39, 176, 0.1)';
                                        textDiv.style.borderRadius = '3px';

                                        // è®¾ç½®æ–‡æœ¬å¯¹é½
                                        const alignMap = ['left', 'center', 'right'];
                                        textDiv.style.textAlign = alignMap[hAlign] || 'center';

                                        // è®¾ç½®transform based on alignment
                                        let transformX = '0%';
                                        let transformY = '0%';

                                        switch (hAlign) {
                                            case 0: transformX = '0%'; break;    // left
                                            case 1: transformX = '-50%'; break;  // center
                                            case 2: transformX = '-100%'; break; // right
                                        }

                                        switch (vAlign) {
                                            case 0: transformY = '0%'; break;    // top
                                            case 1: transformY = '-50%'; break;  // middle
                                            case 2: transformY = '-100%'; break; // bottom
                                        }

                                        textDiv.style.transform = `translate(${transformX}, ${transformY})`;

                                        // è®¾ç½®æ–‡æœ¬å†…å®¹å’Œç±»å‹æ ‡è¯†
                                        // æ˜ å°„C++ç«¯çš„æšä¸¾å€¼
                                        const typeNamesMap = {
                                            0: 'æ— å†…å®¹',
                                            1: 'çŠ¶æ€æ ',
                                            2: 'ä»…å›¾æ ‡',
                                            3: 'å•è¯',      // CONTENT_WORD = 3
                                            4: 'éŸ³æ ‡',      // CONTENT_PHONETIC = 4
                                            5: 'é‡Šä¹‰',      // CONTENT_DEFINITION = 5
                                            6: 'ç¿»è¯‘',      // CONTENT_TRANSLATION = 6
                                            7: 'åˆ†éš”çº¿',
                                            8: 'è‡ªå®šä¹‰'
                                        };
                                        const typeColorsMap = {
                                            0: '#999999',
                                            1: '#999999',
                                            2: '#999999',
                                            3: '#2196F3',   // å•è¯ - è“è‰²
                                            4: '#FF9800',   // éŸ³æ ‡ - æ©™è‰²
                                            5: '#4CAF50',   // é‡Šä¹‰ - ç»¿è‰²
                                            6: '#9C27B0',   // ç¿»è¯‘ - ç´«è‰²
                                            7: '#999999',
                                            8: '#999999'
                                        };

                                        const currentName = typeNamesMap[contentType] || 'æœªçŸ¥';
                                        const currentColor = typeColorsMap[contentType] || '#999999';

                                        textDiv.innerHTML = `
                                            <div style="font-size: 10px; color: ${currentColor}; margin-bottom: 2px;">
                                                ${currentName}[${textIndex}]
                                            </div>
                                            <div>${content || '(ç©ºæ–‡æœ¬)'}</div>
                                        `;
                                        textDiv.style.borderColor = currentColor;
                                        textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.1)`;

                                        // é¼ æ ‡æ‚¬åœæ•ˆæœ
                                        textDiv.onmouseenter = () => {
                                            if (!textDiv.classList.contains('dragging')) {
                                                textDiv.style.borderStyle = 'solid';
                                                textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.2)`;
                                            }
                                        };
                                        textDiv.onmouseleave = () => {
                                            if (!textDiv.classList.contains('dragging')) {
                                                textDiv.style.borderStyle = 'dashed';
                                                textDiv.style.backgroundColor = `rgba(${currentColor.substring(1).match(/.{2}/g).map(x => parseInt(x, 16)).join(',')}, 0.1)`;
                                            }
                                        };

                                        // ç‚¹å‡»é€‰ä¸­
                                        textDiv.onclick = function (e) {
                                            e.stopPropagation();
                                            selectText(index, textIndex);
                                        };

                                        // ä½¿æ–‡æœ¬å¯æ‹–æ‹½
                                        makeDraggable(textDiv, textIndex, 'text', index);

                                        container.appendChild(textDiv);

                                    } catch (textError) {
                                        console.error(`æ¸²æŸ“æ–‡æœ¬ ${textIndex} å¤±è´¥:`, textError);
                                    }
                                });
                            }

                        } catch (rectError) {
                            console.error(`æ¸²æŸ“çŸ©å½¢ ${index} å¤±è´¥:`, rectError);
                        }
                    });
                } else {
                    console.warn('æ²¡æœ‰æ‰¾åˆ°çŸ©å½¢æ•°æ®');
                }

                // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                selectedTextIndex = -1;
                updateSelectedRectInfo();

                // æ›´æ–°ç„¦ç‚¹é…ç½®å¤é€‰æ¡†åˆ—è¡¨ï¼ˆå•è¯ç•Œé¢æ‰éœ€è¦ï¼‰
                if (currentScreenMode === 'vocab') {
                    updateFocusConfigCheckboxes();
                    updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„é€‰æ‹©å™¨
                    // å¦‚æœè¿˜æ²¡æœ‰ç„¦ç‚¹é…ç½®ï¼Œå°è¯•åŠ è½½
                    if (focusableRects.length === 0) {
                        loadFocusConfig();
                    }
                    // å¦‚æœè¿˜æ²¡æœ‰å­æ•°ç»„é…ç½®ï¼Œå°è¯•åŠ è½½
                    if (Object.keys(subArrayConfig).length === 0) {
                        loadSubArrayConfig();
                    }
                }

                console.log('å¸ƒå±€æ¸²æŸ“å®Œæˆ');

            } catch (error) {
                console.error('æ¸²æŸ“å¸ƒå±€æ—¶å‘ç”Ÿé”™è¯¯:', error);
                showStatus('æ¸²æŸ“å¸ƒå±€æ—¶å‡ºé”™: ' + error.message, 'error');
            }
        }

        // æ£€æŸ¥çŸ©å½¢ç¢°æ’
        function checkRectCollision(targetRect, ignoreIndex) {
            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                if (i === ignoreIndex) continue;
                const other = currentLayout.rectangles[i];

                // ç®€å•çš„AABBç¢°æ’æ£€æµ‹
                if (targetRect.x < other.x + other.width &&
                    targetRect.x + targetRect.width > other.x &&
                    targetRect.y < other.y + other.height &&
                    targetRect.y + targetRect.height > other.y) {
                    return true;
                }
            }
            return false;
        }

        // ä½¿å…ƒç´ å¯è°ƒæ•´å¤§å°
        function makeResizable(rectDiv, handle, index, direction) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            handle.onmousedown = function (e) {
                e.stopPropagation(); // é˜²æ­¢è§¦å‘æ‹–åŠ¨
                e.preventDefault();

                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(rectDiv.style.width);
                startHeight = parseInt(rectDiv.style.height);

                // é€‰ä¸­å½“å‰çŸ©å½¢
                selectRectangle(index);

                document.onmousemove = function (e) {
                    if (!isResizing) return;

                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;

                    let newWidth = startWidth;
                    let newHeight = startHeight;

                    if (direction === 'se' || direction === 'e') {
                        newWidth = Math.max(10, startWidth + dx);
                    }
                    if (direction === 'se' || direction === 's') {
                        newHeight = Math.max(10, startHeight + dy);
                    }

                    // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                    const screenWidth = currentLayout.screen.width;
                    const screenHeight = currentLayout.screen.height;
                    const currentX = parseInt(rectDiv.style.left);
                    const currentY = parseInt(rectDiv.style.top);

                    newWidth = Math.min(newWidth, screenWidth - currentX);
                    newHeight = Math.min(newHeight, screenHeight - currentY);

                    // ç¢°æ’æ£€æµ‹
                    const tempRect = {
                        x: currentX,
                        y: currentY,
                        width: newWidth,
                        height: newHeight
                    };

                    if (!checkRectCollision(tempRect, index)) {
                        // å¦‚æœæ²¡æœ‰ç¢°æ’ï¼Œåº”ç”¨æ–°å°ºå¯¸
                        rectDiv.style.width = newWidth + 'px';
                        rectDiv.style.height = newHeight + 'px';

                        // æ›´æ–°æ•°æ®
                        if (currentLayout.rectangles[index]) {
                            currentLayout.rectangles[index].width = newWidth;
                            currentLayout.rectangles[index].height = newHeight;
                            currentLayout.rectangles[index].original_width = newWidth;
                            currentLayout.rectangles[index].original_height = newHeight;

                            // æ›´æ–°è¾“å…¥æ¡†
                            document.getElementById('rectWidth').value = newWidth;
                            document.getElementById('rectHeight').value = newHeight;

                            // æ›´æ–°å›¾æ ‡ä½ç½®ï¼ˆä¿æŒç›¸å¯¹ä½ç½®ï¼‰
                            const rect = currentLayout.rectangles[index];
                            if (rect.icons && Array.isArray(rect.icons)) {
                                rect.icons.forEach((icon, iconIndex) => {
                                    // é‡æ–°è®¡ç®—ç»å¯¹ä½ç½®
                                    icon.display_x = rect.x + (newWidth - (icon.display_width || 30)) * (icon.rel_x || 0.5);
                                    icon.display_y = rect.y + (newHeight - (icon.display_height || 30)) * (icon.rel_y || 0.5);

                                    // æ›´æ–°DOM - ä½¿ç”¨ç»å¯¹ä½ç½®
                                    const iconDiv = document.querySelector(
                                        `.icon-canvas[data-rect-index="${index}"][data-icon-index="${iconIndex}"]`
                                    );
                                    if (iconDiv) {
                                        iconDiv.style.left = icon.display_x + 'px';
                                        iconDiv.style.top = icon.display_y + 'px';
                                    }
                                });
                            }
                        }

                        updateSelectedRectInfo();
                    }
                };

                document.onmouseup = function () {
                    isResizing = false;
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        }

        // ä½¿å…ƒç´ å¯æ‹–æ‹½
        function makeDraggable(element, index, type, rectIndex = -1) {
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;
            let originalIconPositions = []; // Store original icon positions for rect dragging
            let originalBitmapPosition = null; // Store original bitmap position for rect dragging

            element.onmousedown = function (e) {
                if (e.button !== 0) return; // åªå“åº”å·¦é”®
                // å¦‚æœç‚¹å‡»çš„æ˜¯resize handleï¼Œä¸è§¦å‘æ‹–åŠ¨
                if (e.target.classList.contains('resize-handle')) return;

                e.stopPropagation(); // é˜²æ­¢äº‹ä»¶å†’æ³¡

                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;

                const rect = element.getBoundingClientRect();
                initialLeft = parseInt(element.style.left) || 0;
                initialTop = parseInt(element.style.top) || 0;

                // è®¾ç½®æ‹–åŠ¨çŠ¶æ€
                if (type === 'icon') {
                    draggedIconElement = element;
                    element.classList.add('dragging');
                } else if (type === 'rect') {
                    // Store original icon positions
                    const rectData = currentLayout.rectangles[index];
                    if (rectData && rectData.icons && Array.isArray(rectData.icons)) {
                        originalIconPositions = rectData.icons.map(icon => ({
                            x: icon.display_x || 0,
                            y: icon.display_y || 0
                        }));
                    }
                    // Store original bitmap position
                    if (rectData && rectData.bitmap) {
                        originalBitmapPosition = {
                            x: rectData.bitmap.display_x || 0,
                            y: rectData.bitmap.display_y || 0
                        };
                    }
                }

                e.preventDefault();

                // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
                clearAlignmentGuides();

                document.onmousemove = function (e) {
                    if (!isDragging) return;

                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;

                    let newX = initialLeft + dx;
                    let newY = initialTop + dy;

                    // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                    const screenWidth = currentLayout.screen.width;
                    const screenHeight = currentLayout.screen.height;
                    const elementWidth = parseInt(element.style.width) || 0;
                    const elementHeight = parseInt(element.style.height) || 0;

                    newX = Math.max(0, Math.min(newX, screenWidth - elementWidth));
                    newY = Math.max(0, Math.min(newY, screenHeight - elementHeight));

                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯å›¾æ ‡ï¼Œæ£€æŸ¥æ˜¯å¦ç§»åŠ¨åˆ°å…¶ä»–çŸ©å½¢ä¸­
                    if (type === 'icon') {
                        // æ£€æŸ¥å¯¹é½åˆ°å…¶ä»–å…ƒç´ 
                        const aligned = checkAlignment(newX, newY, elementWidth, elementHeight, type, rectIndex);
                        newX = aligned.x;
                        newY = aligned.y;

                        // è®¡ç®—å›¾æ ‡ä¸­å¿ƒç‚¹
                        const iconCenterX = newX + elementWidth / 2;
                        const iconCenterY = newY + elementHeight / 2;

                        // æŸ¥æ‰¾å›¾æ ‡ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let hoveredRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (iconCenterX >= rect.x && iconCenterX <= rect.x + rect.width &&
                                iconCenterY >= rect.y && iconCenterY <= rect.y + rect.height) {
                                hoveredRectIndex = i;
                                break;
                            }
                        }

                        // å¦‚æœä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢å¹¶é«˜äº®
                        if (hoveredRectIndex === -1 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(iconCenterX - rectCenterX, 2) +
                                    Math.pow(iconCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    hoveredRectIndex = i;
                                }
                            }
                        }

                        // æ›´æ–°çŸ©å½¢é«˜äº®çŠ¶æ€
                        updateRectangleHighlight(hoveredRectIndex);

                        // æ›´æ–°å›¾æ ‡åœ¨çŸ©å½¢ä¸­çš„ç›¸å¯¹ä½ç½®
                        if (rectIndex >= 0 && currentLayout.rectangles[rectIndex]) {
                            const parentRect = currentLayout.rectangles[rectIndex];
                            const icon = parentRect.icons[index];

                            if (icon) {
                                // è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºå›¾æ ‡å·¦ä¸Šè§’ï¼‰
                                icon.display_x = newX;
                                icon.display_y = newY;
                                icon.rel_x = (newX - parentRect.x) / parentRect.width;
                                icon.rel_y = (newY - parentRect.y) / parentRect.height;
                            }
                        }
                    } else if (type === 'rect') {
                        // æ£€æŸ¥çŸ©å½¢å¯¹é½
                        const aligned = checkAlignment(newX, newY, elementWidth, elementHeight, type, index);

                        // ç¢°æ’æ£€æµ‹ï¼šå¦‚æœæ–°ä½ç½®ä¼šå¯¼è‡´é‡å ï¼Œåˆ™ä¸å…è®¸ç§»åŠ¨
                        const tempRect = {
                            x: aligned.x,
                            y: aligned.y,
                            width: elementWidth,
                            height: elementHeight
                        };

                        if (!checkRectCollision(tempRect, index)) {
                            newX = aligned.x;
                            newY = aligned.y;

                            // æ›´æ–°çŸ©å½¢æ•°æ®
                            if (currentLayout.rectangles[index]) {
                                currentLayout.rectangles[index].x = newX;
                                currentLayout.rectangles[index].y = newY;
                                currentLayout.rectangles[index].original_x = newX;
                                currentLayout.rectangles[index].original_y = newY;

                                // åŒæ—¶æ›´æ–°çŸ©å½¢å†…æ‰€æœ‰å›¾æ ‡çš„ä½ç½®
                                const rect = currentLayout.rectangles[index];
                                if (rect.icons && Array.isArray(rect.icons)) {
                                    const deltaX = newX - initialLeft;
                                    const deltaY = newY - initialTop;

                                    rect.icons.forEach((icon, iconIndex) => {
                                        if (originalIconPositions[iconIndex]) {
                                            icon.display_x = originalIconPositions[iconIndex].x + deltaX;
                                            icon.display_y = originalIconPositions[iconIndex].y + deltaY;
                                        }

                                        // æ›´æ–°å¯¹åº”çš„DOMå…ƒç´ 
                                        const iconDiv = document.querySelector(
                                            `.icon-canvas[data-rect-index="${index}"][data-icon-index="${iconIndex}"]`
                                        );
                                        if (iconDiv) {
                                            iconDiv.style.left = icon.display_x + 'px';
                                            iconDiv.style.top = icon.display_y + 'px';
                                        }
                                    });
                                }

                                // åŒæ—¶æ›´æ–°çŸ©å½¢å†…ä½å›¾çš„ä½ç½®
                                if (rect.bitmap && originalBitmapPosition) {
                                    const deltaX = newX - initialLeft;
                                    const deltaY = newY - initialTop;

                                    rect.bitmap.display_x = originalBitmapPosition.x + deltaX;
                                    rect.bitmap.display_y = originalBitmapPosition.y + deltaY;

                                    // æ›´æ–°å¯¹åº”çš„DOMå…ƒç´ ï¼ˆä½å›¾Canvasï¼‰
                                    const bitmapCanvas = document.querySelector(
                                        `.bitmap-canvas[data-rect-index="${index}"]`
                                    );
                                    if (bitmapCanvas) {
                                        bitmapCanvas.style.left = rect.bitmap.display_x + 'px';
                                        bitmapCanvas.style.top = rect.bitmap.display_y + 'px';
                                    }
                                }
                            }
                        } else {
                            // å‘ç”Ÿç¢°æ’ï¼Œä¿æŒåŸä½ï¼ˆæˆ–è€…å¯ä»¥åšæ›´ç²¾ç»†çš„è´´è¾¹å¤„ç†ï¼Œè¿™é‡Œç®€å•å¤„ç†ä¸ºä¸ç§»åŠ¨ï¼‰
                            newX = parseInt(element.style.left);
                            newY = parseInt(element.style.top);
                        }
                    }

                    element.style.left = newX + 'px';
                    element.style.top = newY + 'px';

                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯æ–‡æœ¬ï¼Œæ›´æ–°ç›¸å¯¹ä½ç½®
                    if (type === 'text' && rectIndex >= 0 && currentLayout.rectangles[rectIndex]) {
                        const parentRect = currentLayout.rectangles[rectIndex];
                        if (parentRect.texts && parentRect.texts[index]) {
                            const text = parentRect.texts[index];

                            // è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºæ–‡æœ¬å¯¹é½ç‚¹ï¼‰
                            text.rel_x = Math.max(0, Math.min(1, (newX - parentRect.x) / parentRect.width));
                            text.rel_y = Math.max(0, Math.min(1, (newY - parentRect.y) / parentRect.height));
                        }
                    }

                    // å¦‚æœæ‹–åŠ¨çš„æ˜¯ä½å›¾ï¼Œæ›´æ–°ç›¸å¯¹ä½ç½®
                    if (type === 'bitmap' && rectIndex >= 0 && currentLayout.rectangles[rectIndex]) {
                        const parentRect = currentLayout.rectangles[rectIndex];
                        if (parentRect.bitmap) {
                            const bitmap = parentRect.bitmap;
                            const bitmapWidth = parseInt(element.style.width);
                            const bitmapHeight = parseInt(element.style.height);

                            // è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºä½å›¾ä¸­å¿ƒï¼‰
                            const centerX = newX + bitmapWidth / 2;
                            const centerY = newY + bitmapHeight / 2;
                            bitmap.rel_x = Math.max(0, Math.min(1, (centerX - parentRect.x) / parentRect.width));
                            bitmap.rel_y = Math.max(0, Math.min(1, (centerY - parentRect.y) / parentRect.height));
                        }
                    }

                    // æ›´æ–°é€‰ä¸­ä¿¡æ¯
                    updateSelectedRectInfo();
                };

                document.onmouseup = function (e) {
                    if (!isDragging) return;

                    // æ£€æµ‹ç‚¹å‡» (è·ç¦» < 5)
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    if (Math.sqrt(dx * dx + dy * dy) < 5) {
                        if (type === 'icon') selectIcon(rectIndex, index);
                        else if (type === 'rect') selectRectangle(index);
                        else if (type === 'text') selectText(rectIndex, index);
                    }

                    isDragging = false;

                    // æ¸…é™¤æ‹–åŠ¨çŠ¶æ€
                    if (type === 'icon' && draggedIconElement) {
                        // è·å–å›¾æ ‡çš„æœ€ç»ˆä½ç½®
                        let iconX = parseInt(element.style.left);
                        let iconY = parseInt(element.style.top);
                        const iconWidth = parseInt(element.style.width);
                        const iconHeight = parseInt(element.style.height);
                        let iconCenterX = iconX + iconWidth / 2;
                        let iconCenterY = iconY + iconHeight / 2;

                        // 1. æŸ¥æ‰¾å›¾æ ‡ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let targetRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (iconCenterX >= rect.x && iconCenterX <= rect.x + rect.width &&
                                iconCenterY >= rect.y && iconCenterY <= rect.y + rect.height) {
                                targetRectIndex = i;
                                break;
                            }
                        }

                        // 2. å¦‚æœå›¾æ ‡ä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢
                        if (targetRectIndex < 0 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;
                            let nearestRectIndex = -1;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];

                                // è®¡ç®—å›¾æ ‡ä¸­å¿ƒç‚¹åˆ°çŸ©å½¢ä¸­å¿ƒçš„è·ç¦»
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(iconCenterX - rectCenterX, 2) +
                                    Math.pow(iconCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    nearestRectIndex = i;
                                }
                            }

                            if (nearestRectIndex >= 0) {
                                targetRectIndex = nearestRectIndex;
                                console.log(`å›¾æ ‡ä¸åœ¨çŸ©å½¢å†…ï¼Œå¸é™„åˆ°æœ€è¿‘çš„çŸ©å½¢${targetRectIndex}`);
                            }
                        }

                        // 3. å¼ºåˆ¶é™åˆ¶å›¾æ ‡åœ¨ç›®æ ‡çŸ©å½¢èŒƒå›´å†…ï¼ˆé˜²æ­¢è·¨è¶Šè¾¹ç•Œï¼‰
                        if (targetRectIndex >= 0) {
                            const targetRect = currentLayout.rectangles[targetRectIndex];

                            // ä¸¥æ ¼é™åˆ¶åæ ‡åœ¨çŸ©å½¢å†…éƒ¨
                            const clampedX = Math.max(targetRect.x, Math.min(iconX, targetRect.x + targetRect.width - iconWidth));
                            const clampedY = Math.max(targetRect.y, Math.min(iconY, targetRect.y + targetRect.height - iconHeight));

                            // æ£€æŸ¥ä½ç½®æ˜¯å¦å‘ç”Ÿäº†ä¿®æ­£
                            if (clampedX !== iconX || clampedY !== iconY) {
                                iconX = clampedX;
                                iconY = clampedY;

                                // ç«‹å³æ›´æ–°DOMä½ç½®
                                element.style.left = iconX + 'px';
                                element.style.top = iconY + 'px';
                                console.log('å›¾æ ‡ä½ç½®å·²è‡ªåŠ¨ä¿®æ­£åˆ°çŸ©å½¢èŒƒå›´å†…');
                            }

                            // 4. æ›´æ–°æ•°æ®ç»“æ„
                            if (targetRectIndex !== rectIndex) {
                                // æƒ…å†µAï¼šç§»åŠ¨åˆ°äº†ä¸åŒçš„çŸ©å½¢
                                const sourceRect = currentLayout.rectangles[rectIndex];

                                // ä»åŸçŸ©å½¢ä¸­ç§»é™¤å›¾æ ‡
                                const iconData = sourceRect.icons.splice(index, 1)[0];
                                sourceRect.icon_count = sourceRect.icons.length;

                                // é‡æ–°è®¡ç®—å›¾æ ‡åœ¨æ–°çŸ©å½¢ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆåŸºäºå›¾æ ‡å·¦ä¸Šè§’ï¼‰
                                iconData.rel_x = (iconX - targetRect.x) / targetRect.width;
                                iconData.rel_y = (iconY - targetRect.y) / targetRect.height;
                                iconData.display_x = iconX;
                                iconData.display_y = iconY;
                                // è®°å½•ç›®æ ‡çŸ©å½¢ç´¢å¼•
                                iconData.rect_index = targetRectIndex;

                                // æ·»åŠ åˆ°æ–°çŸ©å½¢
                                targetRect.icons.push(iconData);
                                targetRect.icon_count = targetRect.icons.length;

                                // æ›´æ–°DOMå…ƒç´ çš„data-rect-indexå±æ€§
                                element.dataset.rectIndex = targetRectIndex;

                                // æ›´æ–°é€‰ä¸­çŠ¶æ€
                                selectedRectIndex = targetRectIndex;
                                selectedIconIndex = targetRect.icons.length - 1;

                                console.log(`å›¾æ ‡ä»çŸ©å½¢${rectIndex}ç§»åŠ¨åˆ°çŸ©å½¢${targetRectIndex}ï¼Œå·²è®¾ç½®rect_index=${targetRectIndex}`);
                            } else {
                                // æƒ…å†µBï¼šè¿˜åœ¨åŒä¸€ä¸ªçŸ©å½¢ï¼Œä½†ä½ç½®å¯èƒ½è¢«ä¿®æ­£äº†ï¼ˆå¸é™„è¾¹ç¼˜ï¼‰
                                // éœ€è¦æ›´æ–°å½“å‰å›¾æ ‡çš„æ•°æ®ï¼Œå› ä¸ºmousemoveåªæ›´æ–°äº†åŸå§‹çš„æ‹–æ‹½ä½ç½®
                                const iconData = currentLayout.rectangles[rectIndex].icons[index];
                                if (iconData) {
                                    iconData.display_x = iconX;
                                    iconData.display_y = iconY;
                                    iconData.rel_x = (iconX - targetRect.x) / targetRect.width;
                                    iconData.rel_y = (iconY - targetRect.y) / targetRect.height;
                                    // ä»åœ¨åŸçŸ©å½¢ï¼Œä¿ç•™æˆ–è®¾ç½®rect_index
                                    iconData.rect_index = targetRectIndex;
                                }
                            }

                            // æ›´æ–°é€‰ä¸­å›¾æ ‡ä¿¡æ¯æ˜¾ç¤º
                            updateSelectedRectInfo();
                        }

                        draggedIconElement.classList.remove('dragging');
                        draggedIconElement = null;

                        // æ¸…é™¤çŸ©å½¢é«˜äº®
                        updateRectangleHighlight(-1);
                    } else if (type === 'text') {
                        // æ–‡æœ¬æ‹–æ‹½å®Œæˆå¤„ç† - æ”¯æŒè·¨çŸ©å½¢ç§»åŠ¨
                        const textWidth = parseInt(element.style.width) || 100;
                        const textHeight = parseInt(element.style.height) || 20;
                        let textX = parseInt(element.style.left);
                        let textY = parseInt(element.style.top);
                        let textCenterX = textX + textWidth / 2;
                        let textCenterY = textY + textHeight / 2;

                        // æŸ¥æ‰¾æ–‡æœ¬ä¸­å¿ƒç‚¹æ‰€åœ¨çš„çŸ©å½¢
                        let targetRectIndex = -1;
                        for (let i = 0; i < currentLayout.rectangles.length; i++) {
                            const rect = currentLayout.rectangles[i];
                            if (textCenterX >= rect.x && textCenterX <= rect.x + rect.width &&
                                textCenterY >= rect.y && textCenterY <= rect.y + rect.height) {
                                targetRectIndex = i;
                                break;
                            }
                        }

                        // å¦‚æœæ–‡æœ¬ä¸åœ¨ä»»ä½•çŸ©å½¢å†…ï¼Œæ‰¾åˆ°æœ€è¿‘çš„çŸ©å½¢
                        if (targetRectIndex < 0 && currentLayout.rectangles.length > 0) {
                            let minDistance = Infinity;

                            for (let i = 0; i < currentLayout.rectangles.length; i++) {
                                const rect = currentLayout.rectangles[i];
                                const rectCenterX = rect.x + rect.width / 2;
                                const rectCenterY = rect.y + rect.height / 2;
                                const distance = Math.sqrt(
                                    Math.pow(textCenterX - rectCenterX, 2) +
                                    Math.pow(textCenterY - rectCenterY, 2)
                                );

                                if (distance < minDistance) {
                                    minDistance = distance;
                                    targetRectIndex = i;
                                }
                            }

                            if (targetRectIndex >= 0) {
                                console.log(`æ–‡æœ¬ä¸åœ¨çŸ©å½¢å†…ï¼Œå¸é™„åˆ°æœ€è¿‘çš„çŸ©å½¢${targetRectIndex}`);
                            }
                        }

                        // æ›´æ–°æ–‡æœ¬æ•°æ®
                        if (targetRectIndex >= 0) {
                            const targetRect = currentLayout.rectangles[targetRectIndex];

                            // é™åˆ¶åœ¨çŸ©å½¢å†…
                            textX = Math.max(targetRect.x, Math.min(textX, targetRect.x + targetRect.width - textWidth));
                            textY = Math.max(targetRect.y, Math.min(textY, targetRect.y + targetRect.height - textHeight));

                            if (targetRectIndex !== rectIndex) {
                                // ç§»åŠ¨åˆ°ä¸åŒçŸ©å½¢
                                const sourceRect = currentLayout.rectangles[rectIndex];
                                if (!sourceRect.texts) sourceRect.texts = [];
                                const textData = sourceRect.texts.splice(index, 1)[0];

                                // æ›´æ–°ç›¸å¯¹ä½ç½®
                                textData.rel_x = (textX - targetRect.x) / targetRect.width;
                                textData.rel_y = (textY - targetRect.y) / targetRect.height;
                                // è®°å½•ç›®æ ‡çŸ©å½¢ç´¢å¼•
                                textData.rect_index = targetRectIndex;

                                if (!targetRect.texts) targetRect.texts = [];
                                targetRect.texts.push(textData);
                                element.dataset.rectIndex = targetRectIndex;

                                selectedRectIndex = targetRectIndex;
                                selectedTextIndex = targetRect.texts.length - 1;

                                console.log(`æ–‡æœ¬ä»çŸ©å½¢${rectIndex}ç§»åŠ¨åˆ°çŸ©å½¢${targetRectIndex}ï¼Œå·²è®¾ç½®rect_index=${targetRectIndex}`);
                            } else {
                                // è¿˜åœ¨åŒä¸€çŸ©å½¢
                                const textData = currentLayout.rectangles[rectIndex].texts[index];
                                if (textData) {
                                    textData.rel_x = (textX - targetRect.x) / targetRect.width;
                                    textData.rel_y = (textY - targetRect.y) / targetRect.height;
                                    // ä»åœ¨åŸçŸ©å½¢ï¼Œä¿ç•™æˆ–è®¾ç½®rect_index
                                    textData.rect_index = targetRectIndex;
                                }
                            }

                            // æ›´æ–°DOMä½ç½®
                            element.style.left = textX + 'px';
                            element.style.top = textY + 'px';

                            updateSelectedRectInfo();
                        }

                        element.classList.remove('dragging');
                        updateRectangleHighlight(-1);
                    }

                    // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
                    clearAlignmentGuides();

                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            };
        }

        // æ£€æŸ¥å¯¹é½
        function checkAlignment(x, y, width, height, type, index) {
            const threshold = 5; // å¯¹é½é˜ˆå€¼
            let showVerticalGuide = false;
            let showHorizontalGuide = false;
            let guideX = 0;
            let guideY = 0;

            // æ£€æŸ¥å¯¹é½åˆ°å…¶ä»–çŸ©å½¢
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (type === 'rect' && rectIndex === index) return; // è·³è¿‡è‡ªå·±

                // å¯¹é½åˆ°çŸ©å½¢çš„å·¦è¾¹ç¼˜
                if (Math.abs(x - rect.x) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x;
                    x = rect.x; // å¯¹é½åˆ°è¯¥ä½ç½®
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„å³è¾¹ç¼˜
                else if (Math.abs(x + width - (rect.x + rect.width)) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x + rect.width - width;
                    x = rect.x + rect.width - width;
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„ä¸Šè¾¹ç¼˜
                if (Math.abs(y - rect.y) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y;
                    y = rect.y;
                }
                // å¯¹é½åˆ°çŸ©å½¢çš„ä¸‹è¾¹ç¼˜
                else if (Math.abs(y + height - (rect.y + rect.height)) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y + rect.height - height;
                    y = rect.y + rect.height - height;
                }
                // å¯¹é½åˆ°çŸ©å½¢ä¸­å¿ƒçº¿ï¼ˆæ°´å¹³ï¼‰
                else if (Math.abs(y + height / 2 - (rect.y + rect.height / 2)) < threshold) {
                    showHorizontalGuide = true;
                    guideY = rect.y + rect.height / 2 - height / 2;
                    y = rect.y + rect.height / 2 - height / 2;
                }
                // å¯¹é½åˆ°çŸ©å½¢ä¸­å¿ƒçº¿ï¼ˆå‚ç›´ï¼‰
                else if (Math.abs(x + width / 2 - (rect.x + rect.width / 2)) < threshold) {
                    showVerticalGuide = true;
                    guideX = rect.x + rect.width / 2 - width / 2;
                    x = rect.x + rect.width / 2 - width / 2;
                }
            });

            // æ˜¾ç¤ºå¯¹é½è¾…åŠ©çº¿
            if (showVerticalGuide || showHorizontalGuide) {
                showAlignmentGuides(guideX, guideY, showVerticalGuide, showHorizontalGuide);
            }

            return { x, y };
        }

        // æ˜¾ç¤ºå¯¹é½è¾…åŠ©çº¿
        function showAlignmentGuides(x, y, showVertical, showHorizontal) {
            const guidesDiv = document.getElementById('alignmentGuides');
            guidesDiv.innerHTML = '';

            if (showVertical) {
                const verticalGuide = document.createElement('div');
                verticalGuide.className = 'alignment-guide vertical';
                verticalGuide.style.left = x + 'px';
                verticalGuide.style.top = '0';
                guidesDiv.appendChild(verticalGuide);
            }

            if (showHorizontal) {
                const horizontalGuide = document.createElement('div');
                horizontalGuide.className = 'alignment-guide horizontal';
                horizontalGuide.style.left = '0';
                horizontalGuide.style.top = y + 'px';
                guidesDiv.appendChild(horizontalGuide);
            }
        }

        // æ›´æ–°çŸ©å½¢é«˜äº®çŠ¶æ€
        function updateRectangleHighlight(targetIndex) {
            // ç§»é™¤ä¹‹å‰çš„é«˜äº®
            if (currentDropTargetIndex >= 0) {
                const prevRect = document.querySelector(`.rect[data-index="${currentDropTargetIndex}"]`);
                if (prevRect) {
                    prevRect.classList.remove('drop-target');
                }
            }

            // æ·»åŠ æ–°çš„é«˜äº®
            if (targetIndex >= 0) {
                const targetRect = document.querySelector(`.rect[data-index="${targetIndex}"]`);
                if (targetRect) {
                    targetRect.classList.add('drop-target');
                }
            }

            currentDropTargetIndex = targetIndex;
        }

        // æ¸…é™¤å¯¹é½è¾…åŠ©çº¿
        function clearAlignmentGuides() {
            const guidesDiv = document.getElementById('alignmentGuides');
            guidesDiv.innerHTML = '';
        }


        // é€‰ä¸­çŸ©å½¢
        function selectRectangle(index) {
            selectedRectIndex = index;
            selectedIconIndex = -1;
            selectedTextIndex = -1; // æ¸…é™¤æ–‡æœ¬é€‰æ‹©

            // æ›´æ–°æ˜¾ç¤º
            document.querySelectorAll('.rect').forEach(rect => {
                rect.classList.remove('selected');
            });

            // æ¸…é™¤æ‰€æœ‰å›¾æ ‡çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.icon-canvas').forEach(icon => {
                icon.classList.remove('selected');
            });

            // æ¸…é™¤æ‰€æœ‰æ–‡æœ¬çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.text-element').forEach(textEl => {
                textEl.classList.remove('selected');
            });

            if (currentLayout.rectangles[index]) {
                const rectDiv = document.querySelector(`.rect[data-index="${index}"]`);
                if (rectDiv) {
                    rectDiv.classList.add('selected');
                }

                // æ›´æ–°è¡¨å•å€¼
                document.getElementById('rectWidth').value = currentLayout.rectangles[index].width;
                document.getElementById('rectHeight').value = currentLayout.rectangles[index].height;
            }

            updateSelectedRectInfo();
        }

        // é€‰ä¸­å›¾æ ‡
        function selectIcon(rectIndex, iconIndex) {
            // 1. å…ˆé€‰ä¸­çŸ©å½¢ï¼ˆè¿™ä¼šé‡ç½® selectedIconIndex ä¸º -1ï¼Œå¹¶æ¸…é™¤æ‰€æœ‰å›¾æ ‡é€‰ä¸­æ ·å¼ï¼‰
            selectRectangle(rectIndex);

            // 2. é‡æ–°è®¾ç½®å›¾æ ‡é€‰ä¸­çŠ¶æ€
            selectedRectIndex = rectIndex;
            selectedIconIndex = iconIndex;

            // 3. è®¾ç½®å½“å‰å›¾æ ‡ä¸ºé€‰ä¸­çŠ¶æ€
            const iconDiv = document.querySelector(`.icon-canvas[data-rect-index="${rectIndex}"][data-icon-index="${iconIndex}"]`);
            if (iconDiv) {
                iconDiv.classList.add('selected');
            }

            // 4. æ›´æ–°è¾“å…¥æ¡†æ•°æ®
            if (currentLayout.rectangles[rectIndex] &&
                currentLayout.rectangles[rectIndex].icons[iconIndex]) {
                const icon = currentLayout.rectangles[rectIndex].icons[iconIndex];
                
                // åªæœ‰åœ¨å…ƒç´ å­˜åœ¨æ—¶æ‰è®¾ç½®å€¼
                const iconIndexElem = document.getElementById('iconIndex');
                if (iconIndexElem) {
                    iconIndexElem.value = icon.icon_index || 0;
                }
                
                const iconRelXElem = document.getElementById('iconRelX');
                if (iconRelXElem) {
                    iconRelXElem.value = (icon.rel_x !== undefined ? icon.rel_x : 0.5).toFixed(2);
                }
                
                const iconRelYElem = document.getElementById('iconRelY');
                if (iconRelYElem) {
                    iconRelYElem.value = (icon.rel_y !== undefined ? icon.rel_y : 0.5).toFixed(2);
                }
            }

            // 5. å†æ¬¡æ›´æ–°ä¿¡æ¯é¢æ¿ï¼ˆå› ä¸º selectRectangle æ›´æ–°æ—¶ selectedIconIndex è¿˜æ˜¯ -1ï¼‰
            updateSelectedRectInfo();
        }

        // æ›´æ–°é€‰ä¸­çŸ©å½¢ä¿¡æ¯
        function updateSelectedRectInfo() {
            const infoDiv = document.getElementById('selectedRectInfo');

            if (selectedRectIndex >= 0 && currentLayout.rectangles[selectedRectIndex]) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                let iconInfo = '';
                let textInfo = '';

                if (rect.icons && rect.icons.length > 0) {
                    iconInfo = '<p>å›¾æ ‡ä¿¡æ¯:</p><ul style="font-size:10px;">';
                    rect.icons.forEach((icon, index) => {
                        const relX = icon.rel_x !== undefined ? icon.rel_x.toFixed(2) : '0.50';
                        const relY = icon.rel_y !== undefined ? icon.rel_y.toFixed(2) : '0.50';
                        iconInfo += `<li>å›¾æ ‡${index}: ç´¢å¼•=${icon.icon_index}, ç›¸å¯¹(${relX}, ${relY}), å°ºå¯¸=${icon.original_width || 30}Ã—${icon.original_height || 30}</li>`;
                    });
                    iconInfo += '</ul>';
                }

                if (rect.texts && rect.texts.length > 0) {
                    const typeNames = ['å•è¯', 'éŸ³æ ‡', 'é‡Šä¹‰', 'ç¿»è¯‘'];
                    textInfo = '<p>æ–‡æœ¬ä¿¡æ¯:</p><ul style="font-size:10px;">';
                    rect.texts.forEach((text, index) => {
                        const relX = text.rel_x !== undefined ? text.rel_x.toFixed(2) : '0.50';
                        const relY = text.rel_y !== undefined ? text.rel_y.toFixed(2) : '0.50';
                        textInfo += `<li>æ–‡æœ¬${index}: ${typeNames[text.content_type] || 'æœªçŸ¥'}, "${text.content}", ç›¸å¯¹(${relX}, ${relY}), å­—ä½“${text.font_size}px</li>`;
                    });
                    textInfo += '</ul>';
                }

                let deleteBtn = '';
                if (selectedIconIndex >= 0) {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­å›¾æ ‡ (Deleteé”®)</button>`;
                } else if (selectedTextIndex >= 0) {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­æ–‡æœ¬ (Deleteé”®)</button>`;
                } else {
                    deleteBtn = `<button class="delete-btn" onclick="deleteSelected()">åˆ é™¤é€‰ä¸­çŸ©å½¢ (Deleteé”®)</button>`;
                }

                infoDiv.innerHTML = `
                    <span class="rect-id">çŸ©å½¢ ${selectedRectIndex}</span>
                    <p>ä½ç½®: (${rect.x}, ${rect.y})</p>
                    <p>å°ºå¯¸: ${rect.width}Ã—${rect.height}</p>
                    <p>å›¾æ ‡æ•°: ${rect.icon_count || 0}</p>
                    <p>æ–‡æœ¬æ•°: ${rect.texts ? rect.texts.length : 0}</p>
                    <p>çŠ¶æ€æ : ${selectedRectIndex === currentLayout.status_rect_index ? 'æ˜¯' : 'å¦'}</p>
                    ${selectedIconIndex >= 0 ? `<p>é€‰ä¸­çš„å›¾æ ‡: ${selectedIconIndex} (ç´¢å¼•: ${currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.icon_index || 'N/A'}, ç›¸å¯¹ä½ç½®: ${(currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.rel_x || 0.5).toFixed(2)}, ${(currentLayout.rectangles[selectedRectIndex].icons[selectedIconIndex]?.rel_y || 0.5).toFixed(2)})</p>` : ''}
                    ${selectedTextIndex >= 0 ? `<p>é€‰ä¸­çš„æ–‡æœ¬: ${selectedTextIndex} (å†…å®¹: "${currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.content || ''}", ç›¸å¯¹ä½ç½®: ${(currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.rel_x || 0.5).toFixed(2)}, ${(currentLayout.rectangles[selectedRectIndex].texts[selectedTextIndex]?.rel_y || 0.5).toFixed(2)})</p>` : ''}
                    ${deleteBtn}
                    ${iconInfo}
                    ${textInfo}
                `;
            } else {
                infoDiv.innerHTML = 'æœªé€‰ä¸­ä»»ä½•çŸ©å½¢';
            }
        }

        // åˆ é™¤é€‰ä¸­é¡¹
        function deleteSelected() {
            if (selectedRectIndex >= 0) {
                if (selectedIconIndex >= 0) {
                    // åˆ é™¤å›¾æ ‡
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                        rect.icons.splice(selectedIconIndex, 1);
                        rect.icon_count = rect.icons.length;

                        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                        selectedIconIndex = -1;

                        // é‡æ–°æ¸²æŸ“
                        renderLayout(currentLayout);

                        // æ›´æ–°ä¿¡æ¯é¢æ¿
                        updateSelectedRectInfo();

                        showStatus('å›¾æ ‡å·²åˆ é™¤', 'success');
                    }
                } else if (selectedTextIndex >= 0) {
                    // åˆ é™¤æ–‡æœ¬
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    if (rect && rect.texts && rect.texts[selectedTextIndex]) {
                        rect.texts.splice(selectedTextIndex, 1);

                        // æ¸…é™¤é€‰ä¸­çŠ¶æ€
                        selectedTextIndex = -1;

                        // é‡æ–°æ¸²æŸ“
                        renderLayout(currentLayout);

                        // æ›´æ–°ä¿¡æ¯é¢æ¿
                        updateSelectedRectInfo();

                        showStatus('æ–‡æœ¬å·²åˆ é™¤', 'success');
                    }
                } else {
                    // åˆ é™¤çŸ©å½¢
                    removeSelectedRect();
                }
            }
        }

        // é€‰ä¸­æ–‡æœ¬
        function selectText(rectIndex, textIndex) {
            // å…ˆé€‰ä¸­çŸ©å½¢
            selectRectangle(rectIndex);

            // è®¾ç½®æ–‡æœ¬é€‰ä¸­çŠ¶æ€
            selectedRectIndex = rectIndex;
            selectedTextIndex = textIndex;

            // æ¸…é™¤æ‰€æœ‰æ–‡æœ¬çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.text-element').forEach(textEl => {
                textEl.classList.remove('selected');
            });

            // è®¾ç½®å½“å‰æ–‡æœ¬ä¸ºé€‰ä¸­çŠ¶æ€
            const textDiv = document.querySelector(`.text-element[data-rect-index="${rectIndex}"][data-text-index="${textIndex}"]`);
            if (textDiv) {
                textDiv.classList.add('selected');
            }

            // æ›´æ–°æ–‡æœ¬è¾“å…¥æ¡†æ•°æ®
            if (currentLayout.rectangles[rectIndex] &&
                currentLayout.rectangles[rectIndex].texts &&
                currentLayout.rectangles[rectIndex].texts[textIndex]) {
                const text = currentLayout.rectangles[rectIndex].texts[textIndex];
                document.getElementById('textType').value = text.content_type || 3;
                document.getElementById('textContent').value = text.content || '';
                document.getElementById('textRelX').value = (text.rel_x !== undefined ? text.rel_x : 0.5).toFixed(2);
                document.getElementById('textRelY').value = (text.rel_y !== undefined ? text.rel_y : 0.5).toFixed(2);
                document.getElementById('textFontSize').value = text.font_size || 16;
                document.getElementById('textHAlign').value = text.h_align || 1;
                document.getElementById('textVAlign').value = text.v_align || 1;
            }

            // æ›´æ–°ä¿¡æ¯é¢æ¿
            updateSelectedRectInfo();
        }

        // ç»‘å®šé”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸æ‰§è¡Œåˆ é™¤
                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                    return;
                }

                deleteSelected();
                e.preventDefault();
            }
        });
        //æ›´æ–°å±å¹•å°ºå¯¸
        async function updateScreenSize() {
            const width = parseInt(document.getElementById('screenWidth').value);
            const height = parseInt(document.getElementById('screenHeight').value);

            if (width >= 100 && width <= 800 && height >= 100 && height <= 600) {
                try {
                    // æ˜¾ç¤ºæ­£åœ¨æ›´æ–°çš„çŠ¶æ€
                    showLoading('æ­£åœ¨æ›´æ–°è®¾å¤‡å±å¹•å°ºå¯¸...');
                    showStatus('æ­£åœ¨æ›´æ–°è®¾å¤‡å±å¹•å°ºå¯¸...', 'success');

                    // å‘é€è®¾ç½®å±å¹•å®½åº¦çš„å‘½ä»¤ï¼ˆä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼‰
                    const widthCommandPath = `/command?commandText=$set/screenXSize=${width}&PAGE=0`;
                    console.log('å‘é€å®½åº¦å‘½ä»¤:', widthCommandPath);

                    const widthResponse = await fetchWithFallback(widthCommandPath, widthCommandPath);
                    if (!widthResponse.ok) {
                        throw new Error(`è®¾ç½®å±å¹•å®½åº¦å¤±è´¥: HTTP ${widthResponse.status}`);
                    }
                    const widthResult = await widthResponse.text();
                    console.log('å®½åº¦å‘½ä»¤å“åº”:', widthResult);

                    // ç­‰å¾…ä¸€ä¸‹å†å‘é€é«˜åº¦å‘½ä»¤
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // å‘é€è®¾ç½®å±å¹•é«˜åº¦çš„å‘½ä»¤
                    const heightCommandPath = `/command?commandText=$set/screenYSize=${height}&PAGE=0`;
                    console.log('å‘é€é«˜åº¦å‘½ä»¤:', heightCommandPath);

                    const heightResponse = await fetchWithFallback(heightCommandPath, heightCommandPath);
                    if (!heightResponse.ok) {
                        throw new Error(`è®¾ç½®å±å¹•é«˜åº¦å¤±è´¥: HTTP ${heightResponse.status}`);
                    }
                    const heightResult = await heightResponse.text();
                    console.log('é«˜åº¦å‘½ä»¤å“åº”:', heightResult);

                    // ç­‰å¾…ä¸€ä¸‹è®©å•ç‰‡æœºå®Œæˆè®¾ç½®
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    // æ›´æ–°æœ¬åœ°å¸ƒå±€æ•°æ®
                    currentLayout.screen.width = width;
                    currentLayout.screen.height = height;
                    currentLayout.screen.original_width = width;
                    currentLayout.screen.original_height = height;

                    // æ›´æ–°å±å¹•å®¹å™¨å°ºå¯¸
                    const screenContainer = document.getElementById('screenContainer');
                    screenContainer.style.width = width + 'px';
                    screenContainer.style.height = height + 'px';

                    // æ›´æ–°çŸ©å½¢è¾“å…¥æ¡†çš„æœ€å¤§å€¼
                    document.getElementById('rectWidth').max = width;
                    document.getElementById('rectHeight').max = height;

                    // æ›´æ–°æ˜¾ç¤ºçš„å±å¹•å°ºå¯¸ä¿¡æ¯
                    // document.getElementById('screenSize').textContent = `${width}Ã—${height}`;
                    // document.getElementById('designSize').textContent = `${width}Ã—${height}`;

                    // é‡æ–°ç»˜åˆ¶ç½‘æ ¼çº¿
                    drawGridLines();

                    // é‡æ–°ä»è®¾å¤‡è·å–å¸ƒå±€æ•°æ®
                    console.log('æ­£åœ¨è·å–æœ€æ–°å¸ƒå±€æ•°æ®...');
                    showStatus('æ­£åœ¨è·å–è®¾å¤‡æœ€æ–°å¸ƒå±€...', 'success');

                    try {
                        // è·å–æœ€æ–°å¸ƒå±€
                        const layoutData = await getCurrentLayoutFromDevice();

                        if (layoutData) {
                            console.log('æˆåŠŸè·å–æœ€æ–°å¸ƒå±€æ•°æ®');

                            // æ›´æ–°æœ¬åœ°currentLayoutï¼ˆgetCurrentLayoutFromDeviceå†…éƒ¨ä¼šè°ƒç”¨renderLayoutï¼‰
                            // ç¡®ä¿currentLayoutçš„å±å¹•å°ºå¯¸æ˜¯æœ€æ–°çš„
                            currentLayout.screen.width = width;
                            currentLayout.screen.height = height;
                            currentLayout.screen.original_width = width;
                            currentLayout.screen.original_height = height;

                            showStatus(`å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œå¸ƒå±€å·²é‡æ–°åŠ è½½`, 'success');
                        } else {
                            throw new Error('è·å–å¸ƒå±€æ•°æ®è¿”å›null');
                        }

                    } catch (layoutError) {
                        console.log('è·å–æœ€æ–°å¸ƒå±€å¤±è´¥:', layoutError);

                        // å¦‚æœè·å–å¸ƒå±€å¤±è´¥ï¼Œé‡æ–°æ¸²æŸ“å½“å‰å¸ƒå±€
                        renderLayout(currentLayout);
                        showStatus(`å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œä½†è·å–æœ€æ–°å¸ƒå±€å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®`, 'warning');
                    }

                } catch (error) {
                    console.error('æ›´æ–°å±å¹•å°ºå¯¸å¤±è´¥:', error);

                    // å³ä½¿è®¾å¤‡è®¾ç½®å¤±è´¥ï¼Œä¹Ÿæ›´æ–°æœ¬åœ°ç•Œé¢
                    currentLayout.screen.width = width;
                    currentLayout.screen.height = height;
                    currentLayout.screen.original_width = width;
                    currentLayout.screen.original_height = height;

                    const screenContainer = document.getElementById('screenContainer');
                    screenContainer.style.width = width + 'px';
                    screenContainer.style.height = height + 'px';

                    document.getElementById('screenSize').textContent = `${width}Ã—${height}`;
                    document.getElementById('designSize').textContent = `${width}Ã—${height}`;

                    document.getElementById('rectWidth').max = width;
                    document.getElementById('rectHeight').max = height;

                    drawGridLines();
                    renderLayout(currentLayout);

                    showStatus(`æœ¬åœ°å±å¹•å°ºå¯¸å·²æ›´æ–°ä¸º ${width}Ã—${height}ï¼Œä½†è®¾å¤‡è®¾ç½®å¤±è´¥: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            } else {
                showStatus('è¯·è¾“å…¥æœ‰æ•ˆçš„å±å¹•å°ºå¯¸ (100-800 Ã— 100-600)', 'error');
            }
        }

        // æ·»åŠ æ–°çŸ©å½¢
        function addRectangle() {
            const width = parseInt(document.getElementById('rectWidth').value);
            const height = parseInt(document.getElementById('rectHeight').value);

            if (width < 10 || height < 10) {
                showStatus('çŸ©å½¢å°ºå¯¸å¤ªå°', 'error');
                return;
            }

            // æ‰¾ä¸€ä¸ªåˆé€‚çš„ä½ç½®æ”¾ç½®æ–°çŸ©å½¢
            let x = 10, y = 10;
            let placed = false;

            // ç®€å•çš„é¿è®©ç®—æ³•
            while (!placed) {
                let collision = false;
                for (const rect of currentLayout.rectangles) {
                    if (x < rect.x + rect.width &&
                        x + width > rect.x &&
                        y < rect.y + rect.height &&
                        y + height > rect.y) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    placed = true;
                } else {
                    x += 20;
                    if (x + width > currentLayout.screen.width) {
                        x = 10;
                        y += 20;
                    }
                    if (y + height > currentLayout.screen.height) {
                        // å¦‚æœæ”¾ä¸ä¸‹ï¼Œæ”¾åœ¨ç¬¬ä¸€ä¸ªçŸ©å½¢çš„æ—è¾¹
                        x = currentLayout.rectangles[0]?.x + currentLayout.rectangles[0]?.width + 10 || 10;
                        y = currentLayout.rectangles[0]?.y || 10;
                        placed = true;
                    }
                }
            }

            const newRect = {
                x: x,
                y: y,
                width: width,
                height: height,
                original_x: x,
                original_y: y,
                original_width: width,
                original_height: height,
                icon_count: 0,
                icons: [],
                is_status_bar: false
            };

            currentLayout.rectangles.push(newRect);
            selectedRectIndex = currentLayout.rectangles.length - 1;
            selectedIconIndex = -1;

            renderLayout(currentLayout);
            showStatus('çŸ©å½¢æ·»åŠ æˆåŠŸ', 'success');
        }

        // åˆ é™¤é€‰ä¸­çŸ©å½¢
        function removeSelectedRect() {
            if (selectedRectIndex >= 0 && selectedRectIndex < currentLayout.rectangles.length) {
                currentLayout.rectangles.splice(selectedRectIndex, 1);
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                renderLayout(currentLayout);
                showStatus('çŸ©å½¢åˆ é™¤æˆåŠŸ', 'success');
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
            }
        }

        // æ¸…ç©ºæ‰€æœ‰çŸ©å½¢
        function clearAllRectangles() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰çŸ©å½¢å—ï¼Ÿ')) {
                currentLayout.rectangles = [];
                selectedRectIndex = -1;
                selectedIconIndex = -1;
                renderLayout(currentLayout);
                showStatus('æ‰€æœ‰çŸ©å½¢å·²æ¸…ç©º', 'success');
            }
        }

        // æ·»åŠ å›¾æ ‡åˆ°é€‰ä¸­çŸ©å½¢
        function addIconToSelectedRect() {
            if (selectedRectIndex < 0 || selectedRectIndex >= currentLayout.rectangles.length) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
                return;
            }

            // ä»å…¨å±€å˜é‡æˆ–æ–‡ä»¶è¾“å…¥ä¸­è·å–å›¾æ ‡ç´¢å¼•
            let iconIndex = window.selectedIconIndex;
            
            // å¦‚æœæ²¡æœ‰ä»æ–‡ä»¶é€‰æ‹©å™¨è·å–ç´¢å¼•ï¼Œå°è¯•ä»ä¸‹æ‹‰èœå•ï¼ˆä¸ºäº†å…¼å®¹ï¼‰
            if (iconIndex === undefined || iconIndex === null) {
                const iconIndexElement = document.getElementById('iconIndex');
                if (iconIndexElement && iconIndexElement.value) {
                    iconIndex = parseInt(iconIndexElement.value);
                } else {
                    showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾æ ‡æ–‡ä»¶ (.bin æ ¼å¼)', 'error');
                    return;
                }
            }

            if (iconIndex < 0 || iconIndex > 12) {
                showStatus(`å›¾æ ‡ç´¢å¼•æ— æ•ˆ (${iconIndex})ã€‚æœ‰æ•ˆèŒƒå›´ï¼š0-12`, 'error');
                window.selectedIconIndex = undefined;
                document.getElementById('iconFileInput').value = '';
                document.getElementById('iconFileName').value = '';
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];

            // ä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆ0.0-1.0ï¼‰
            const relX = parseFloat(document.getElementById('iconRelX').value) || 0.5;
            const relY = parseFloat(document.getElementById('iconRelY').value) || 0.5;

            // é™åˆ¶èŒƒå›´åœ¨0.0-1.0ä¹‹é—´
            const clampedRelX = Math.max(0.0, Math.min(1.0, relX));
            const clampedRelY = Math.max(0.0, Math.min(1.0, relY));

            // æ ¹æ®å›¾æ ‡ç´¢å¼•è·å–åŸå§‹å°ºå¯¸ï¼ˆä¸C++ä»£ç ä¸­g_available_iconsåŒ¹é…ï¼‰
            const iconSizes = [
                [62, 64],   // 0 - ICON_1 (house)
                [64, 64],   // 1 - ICON_2 (measure) 
                [86, 64],   // 2 - ICON_3 (settings)
                [71, 56],   // 3 - ICON_4 (broom)
                [76, 56],   // 4 - ICON_5 (mop)
                [94, 64],   // 5 - ICON_6 (cleaning tool)
                [120, 8],   // 6 - separate (divider)
                [32, 32],   // 7 - WIFI_CONNECT
                [32, 32],   // 8 - WIFI_DISCONNECT
                [36, 24],   // 9 - BATTERY_1
                [16, 16],   // 10 - HORN
                [15, 16],   // 11 - NAIL
                [32, 32]    // 12 - LOCK
            ];

            const [originalWidth, originalHeight] = iconSizes[iconIndex] || [30, 30];

            const icon = {
                icon_index: iconIndex,
                rel_x: clampedRelX,
                rel_y: clampedRelY,
                original_width: originalWidth,
                original_height: originalHeight,
                display_width: originalWidth,  // åˆå§‹æ˜¾ç¤ºå°ºå¯¸ = åŸå§‹å°ºå¯¸
                display_height: originalHeight  // åˆå§‹æ˜¾ç¤ºå°ºå¯¸ = åŸå§‹å°ºå¯¸
            };

            if (!rect.icons) rect.icons = [];
            rect.icons.push(icon);
            rect.icon_count = rect.icons.length;

            renderLayout(currentLayout);

            // é€‰ä¸­æ–°æ·»åŠ çš„å›¾æ ‡
            selectIcon(selectedRectIndex, rect.icons.length - 1);
            
            // æ¸…é™¤æ–‡ä»¶é€‰æ‹©ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡é€‰æ‹©
            window.selectedIconIndex = undefined;
            document.getElementById('iconFileInput').value = '';
            document.getElementById('iconFileName').value = '';

            showStatus(`å›¾æ ‡æ·»åŠ æˆåŠŸ (ç´¢å¼•: ${iconIndex}, rel_x=${clampedRelX.toFixed(2)}, rel_y=${clampedRelY.toFixed(2)})`, 'success');
        }

        // åˆ é™¤é€‰ä¸­å›¾æ ‡
        function removeSelectedIcon() {
            if (selectedRectIndex >= 0 && selectedIconIndex >= 0) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                    rect.icons.splice(selectedIconIndex, 1);
                    rect.icon_count = rect.icons.length;
                    selectedIconIndex = -1;
                    renderLayout(currentLayout);
                    showStatus('å›¾æ ‡åˆ é™¤æˆåŠŸ', 'success');
                }
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾æ ‡', 'error');
            }
        }

        // æ›´æ–°é€‰ä¸­å›¾æ ‡çš„ç›¸å¯¹ä½ç½®
        function updateSelectedIconPosition() {
            if (selectedRectIndex >= 0 && selectedIconIndex >= 0) {
                const rect = currentLayout.rectangles[selectedRectIndex];
                if (rect && rect.icons && rect.icons[selectedIconIndex]) {
                    const icon = rect.icons[selectedIconIndex];
                    const newRelX = parseFloat(document.getElementById('iconRelX').value) || 0.5;
                    const newRelY = parseFloat(document.getElementById('iconRelY').value) || 0.5;

                    // é™åˆ¶èŒƒå›´åœ¨0.0-1.0ä¹‹é—´
                    icon.rel_x = Math.max(0.0, Math.min(1.0, newRelX));
                    icon.rel_y = Math.max(0.0, Math.min(1.0, newRelY));

                    renderLayout(currentLayout);
                    showStatus(`å›¾æ ‡ä½ç½®å·²æ›´æ–° (rel_x=${icon.rel_x.toFixed(2)}, rel_y=${icon.rel_y.toFixed(2)})`, 'success');
                }
            } else {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå›¾æ ‡', 'error');
            }
        }

        // è‡ªåŠ¨æ’åˆ—å›¾æ ‡
        function autoArrangeIcons() {
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (rect.icons && rect.icons.length > 0) {
                    const cols = Math.ceil(Math.sqrt(rect.icons.length));
                    const rows = Math.ceil(rect.icons.length / cols);

                    rect.icons.forEach((icon, iconIndex) => {
                        const row = Math.floor(iconIndex / cols);
                        const col = iconIndex % cols;

                        const cellWidth = rect.width / cols;
                        const cellHeight = rect.height / rows;

                        const iconWidth = icon.display_width || icon.original_width || 30;
                        const iconHeight = icon.display_height || icon.original_height || 30;

                        icon.rel_x = (col + 0.5) / cols;
                        icon.rel_y = (row + 0.5) / rows;
                        icon.display_x = rect.x + col * cellWidth + cellWidth / 2 - iconWidth / 2;
                        icon.display_y = rect.y + row * cellHeight + cellHeight / 2 - iconHeight / 2;
                    });
                }
            });

            renderLayout(currentLayout);
            showStatus('å›¾æ ‡è‡ªåŠ¨æ’åˆ—å®Œæˆ', 'success');
        }

        // ===== æ–‡æœ¬ç®¡ç†åŠŸèƒ½ =====

        // æ·»åŠ æ–‡æœ¬åˆ°é€‰ä¸­çŸ©å½¢
        function addTextToSelectedRect() {
            if (selectedRectIndex < 0 || selectedRectIndex >= currentLayout.rectangles.length) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            const textType = parseInt(document.getElementById('textType').value);
            const textContent = document.getElementById('textContent').value.trim();

            if (!textContent) {
                showStatus('è¯·è¾“å…¥æ–‡æœ¬å†…å®¹', 'error');
                return;
            }

            // ä½¿ç”¨è¾“å…¥æ¡†ä¸­çš„ç›¸å¯¹ä½ç½®ï¼ˆ0.0-1.0ï¼‰
            const relX = parseFloat(document.getElementById('textRelX').value) || 0.5;
            const relY = parseFloat(document.getElementById('textRelY').value) || 0.5;
            const fontSize = parseInt(document.getElementById('textFontSize').value) || 16;
            const hAlign = parseInt(document.getElementById('textHAlign').value) || 1;
            const vAlign = parseInt(document.getElementById('textVAlign').value) || 1;

            // é™åˆ¶èŒƒå›´
            const clampedRelX = Math.max(0.0, Math.min(1.0, relX));
            const clampedRelY = Math.max(0.0, Math.min(1.0, relY));

            const text = {
                content_type: textType,
                content: textContent,
                rel_x: clampedRelX,
                rel_y: clampedRelY,
                font_size: fontSize,
                h_align: hAlign,
                v_align: vAlign
            };

            // åˆå§‹åŒ–textsæ•°ç»„ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!rect.texts) {
                rect.texts = [];
            }
            rect.texts.push(text);

            // è®¾ç½®ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼
            rect.custom_text_mode = true;

            renderLayout(currentLayout);
            showStatus(`æ–‡æœ¬å·²æ·»åŠ åˆ°çŸ©å½¢ ${selectedRectIndex}`, 'success');
        }

        // æ›´æ–°é€‰ä¸­æ–‡æœ¬ä½ç½®
        function updateSelectedTextPosition() {
            if (selectedRectIndex < 0 || selectedTextIndex < 0) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡æœ¬å…ƒç´ ', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            if (!rect.texts || selectedTextIndex >= rect.texts.length) {
                showStatus('é€‰ä¸­çš„æ–‡æœ¬ä¸å­˜åœ¨', 'error');
                return;
            }

            const text = rect.texts[selectedTextIndex];

            // ä»è¾“å…¥æ¡†è·å–æ–°å€¼
            text.rel_x = Math.max(0.0, Math.min(1.0, parseFloat(document.getElementById('textRelX').value) || 0.5));
            text.rel_y = Math.max(0.0, Math.min(1.0, parseFloat(document.getElementById('textRelY').value) || 0.5));
            text.font_size = parseInt(document.getElementById('textFontSize').value) || 16;
            text.h_align = parseInt(document.getElementById('textHAlign').value) || 1;
            text.v_align = parseInt(document.getElementById('textVAlign').value) || 1;

            // æ›´æ–°å†…å®¹ï¼ˆå¦‚æœå·²ä¿®æ”¹ï¼‰
            const newContent = document.getElementById('textContent').value.trim();
            if (newContent) {
                text.content = newContent;
            }

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬ä½ç½®å·²æ›´æ–°', 'success');
        }

        // åˆ é™¤é€‰ä¸­æ–‡æœ¬
        function removeSelectedText() {
            if (selectedRectIndex < 0 || selectedTextIndex < 0) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡æœ¬å…ƒç´ ', 'error');
                return;
            }

            const rect = currentLayout.rectangles[selectedRectIndex];
            if (!rect.texts || selectedTextIndex >= rect.texts.length) {
                showStatus('é€‰ä¸­çš„æ–‡æœ¬ä¸å­˜åœ¨', 'error');
                return;
            }

            // æ ‡è®°çŸ©å½¢ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼ï¼Œé˜²æ­¢ä»é»˜è®¤é…ç½®æ¢å¤æ–‡æœ¬
            rect.custom_text_mode = true;
            console.log(`çŸ©å½¢ ${selectedRectIndex} è®¾ç½®ä¸ºè‡ªå®šä¹‰æ–‡æœ¬æ¨¡å¼ï¼Œé˜²æ­¢æ–‡æœ¬æ¢å¤`);

            rect.texts.splice(selectedTextIndex, 1);
            selectedTextIndex = -1;

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬å·²åˆ é™¤', 'success');
        }

        // è‡ªåŠ¨æ’åˆ—æ–‡æœ¬
        function autoArrangeTexts() {
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                if (rect.texts && rect.texts.length > 0) {
                    // æ ¹æ®æ–‡æœ¬ç±»å‹åˆ†ç»„æ’åˆ—
                    const typePositions = {
                        0: { x: 0.5, y: 0.2 },   // WORD - é¡¶éƒ¨ä¸­å¿ƒ
                        1: { x: 0.3, y: 0.4 },   // PHONETIC - å·¦ä¾§
                        2: { x: 0.5, y: 0.6 },   // DEFINITION - ä¸­éƒ¨
                        3: { x: 0.5, y: 0.8 }    // TRANSLATION - åº•éƒ¨
                    };

                    rect.texts.forEach((text, textIndex) => {
                        const typePos = typePositions[text.content_type] || { x: 0.5, y: 0.5 };

                        // å¦‚æœæœ‰å¤šä¸ªç›¸åŒç±»å‹çš„æ–‡æœ¬ï¼Œç¨å¾®é”™å¼€ä½ç½®
                        const sameTypeCount = rect.texts.filter(t => t.content_type === text.content_type).length;
                        const sameTypeIndex = rect.texts.filter((t, i) => i <= textIndex && t.content_type === text.content_type).length - 1;

                        const offset = sameTypeCount > 1 ? (sameTypeIndex - (sameTypeCount - 1) / 2) * 0.1 : 0;

                        text.rel_x = Math.max(0.0, Math.min(1.0, typePos.x + offset));
                        text.rel_y = Math.max(0.0, Math.min(1.0, typePos.y));
                    });
                }
            });

            renderLayout(currentLayout);
            showStatus('æ–‡æœ¬è‡ªåŠ¨æ’åˆ—å®Œæˆ', 'success');
        }

        // ===== é€‰æ‹©çŠ¶æ€å˜é‡ =====
        let selectedTextIndex = -1;

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = 'status-message status-' + type;
            statusDiv.style.display = 'block';

            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 3000);
        }

        // è·å–å½“å‰å¸ƒå±€
        function getCurrentLayout() {
            console.log('å¼€å§‹ç”Ÿæˆå¸ƒå±€æ•°æ®...');

            // ç¡®ä¿æ‰€æœ‰å›¾æ ‡æ•°æ®éƒ½æ˜¯æœ€æ–°çš„
            currentLayout.rectangles.forEach((rect, rectIndex) => {
                console.log(`å¤„ç†çŸ©å½¢ ${rectIndex}: ä½ç½®(${rect.x},${rect.y}), å°ºå¯¸(${rect.width}x${rect.height})`);

                if (rect.icons && Array.isArray(rect.icons)) {
                    rect.icons.forEach((icon, iconIndex) => {
                        // ä»DOMå…ƒç´ è·å–æœ€æ–°ä½ç½®å’Œå°ºå¯¸
                        const iconDiv = document.querySelector(
                            `.icon-canvas[data-rect-index="${rectIndex}"][data-icon-index="${iconIndex}"]`
                        );
                        if (iconDiv) {
                            // è·å–DOMä¸­çš„å®é™…ä½ç½®å’Œå°ºå¯¸
                            const domX = parseInt(iconDiv.style.left) || 0;
                            const domY = parseInt(iconDiv.style.top) || 0;
                            const domWidth = parseInt(iconDiv.style.width) || 30;
                            const domHeight = parseInt(iconDiv.style.height) || 30;

                            console.log(`  çŸ©å½¢ ${rectIndex} å›¾æ ‡ ${iconIndex}:`);
                            console.log(`    DOMä½ç½®: (${domX},${domY}), å°ºå¯¸: ${domWidth}x${domHeight}`);

                            // å­˜å‚¨æ˜¾ç¤ºä½ç½®å’Œå°ºå¯¸
                            icon.display_x = Number(domX);
                            icon.display_y = Number(domY);
                            icon.display_width = Number(domWidth);
                            icon.display_height = Number(domHeight);

                            // é‡æ–°è®¡ç®—ç›¸å¯¹ä½ç½®ï¼ˆä½¿ç”¨å›¾æ ‡å·¦ä¸Šè§’ï¼‰
                            if (rect.width > 0 && rect.height > 0) {
                                // ä½¿ç”¨å›¾æ ‡å·¦ä¸Šè§’è®¡ç®—ç›¸å¯¹ä½ç½®
                                let rel_x = (domX - rect.x) / rect.width;
                                let rel_y = (domY - rect.y) / rect.height;

                                // ç¡®ä¿åœ¨0-1èŒƒå›´å†…
                                rel_x = Math.max(0, Math.min(1, rel_x));
                                rel_y = Math.max(0, Math.min(1, rel_y));

                                // ä¿ç•™ä¸¤ä½å°æ•°ï¼Œå››èˆäº”å…¥
                                rel_x = Math.round(rel_x * 100) / 100;
                                rel_y = Math.round(rel_y * 100) / 100;

                                // ä¿å­˜åˆ°å›¾æ ‡æ•°æ®ä¸­
                                icon.rel_x = rel_x;
                                icon.rel_y = rel_y;

                                console.log(`    ç›¸å¯¹ä½ç½®: (${rel_x},${rel_y}) ä¿ç•™ä¸¤ä½å°æ•°`);
                            }

                            // æ¸…ç†ä¸å¿…è¦çš„å±æ€§
                            delete icon.original_x;
                            delete icon.original_y;
                            delete icon.original_width;
                            delete icon.original_height;
                        } else {
                            console.warn(`æ‰¾ä¸åˆ°çŸ©å½¢ ${rectIndex} çš„å›¾æ ‡ ${iconIndex} çš„DOMå…ƒç´ `);
                        }
                    });
                }

                // æ¸…ç†çŸ©å½¢çš„ä¸å¿…è¦å±æ€§
                delete rect.original_x;
                delete rect.original_y;
                delete rect.original_width;
                delete rect.original_height;
            });

            // ç®€åŒ–æ•°æ®ç»“æ„ï¼Œåªå‘é€æœåŠ¡å™¨éœ€è¦çš„å­—æ®µ
            const simplifiedLayout = {
                screen_width: currentLayout.screen.width,
                screen_height: currentLayout.screen.height,
                rectangles: currentLayout.rectangles.map((rect, rectIdx) => ({
                    x: Number(rect.x),
                    y: Number(rect.y),
                    width: Number(rect.width),
                    height: Number(rect.height),
                    icon_count: Number(rect.icons?.length || 0),
                    text_count: Number(rect.texts?.length || 0),
                    icons: rect.icons?.map(icon => ({
                        icon_index: Number(icon.icon_index),
                        // è¿™é‡Œç›´æ¥ä½¿ç”¨å·²ç»ä¿ç•™ä¸€ä½å°æ•°çš„rel_xå’Œrel_y
                        rel_x: Number(icon.rel_x),
                        rel_y: Number(icon.rel_y),
                        display_x: Number(icon.display_x),
                        display_y: Number(icon.display_y),
                        display_width: Number(icon.display_width),
                        display_height: Number(icon.display_height),
                        // æ·»åŠ rect_indexå­—æ®µï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä½¿ç”¨å½“å‰çŸ©å½¢ç´¢å¼•
                        rect_index: Number(icon.rect_index !== undefined ? icon.rect_index : rectIdx)
                    })) || [],
                    texts: rect.texts?.map(text => ({
                        content_type: Number(text.content_type || 0),
                        content: text.content || '',
                        rel_x: Number(text.rel_x || 0.5),
                        rel_y: Number(text.rel_y || 0.5),
                        font_size: Number(text.font_size || 16),
                        h_align: Number(text.h_align || 1),
                        v_align: Number(text.v_align || 1),
                        // æ·»åŠ rect_indexå­—æ®µï¼Œå¦‚æœæœªè®¾ç½®åˆ™ä½¿ç”¨å½“å‰çŸ©å½¢ç´¢å¼•
                        rect_index: Number(text.rect_index !== undefined ? text.rect_index : rectIdx)
                    })) || [],
                    // æ·»åŠ custom_text_modeå­—æ®µï¼Œç”¨äºé˜²æ­¢æ–‡æœ¬æ¢å¤
                    // å¦‚æœæœ‰è‡ªå®šä¹‰æ–‡æœ¬ï¼Œæˆ–è€…æ˜¯åŸæœ¬æœ‰é»˜è®¤æ–‡æœ¬çš„çŸ©å½¢(2,4,5,8)ä¸”æ–‡æœ¬è¢«æ¸…ç©ºï¼Œåˆ™è®¾ä¸ºè‡ªå®šä¹‰æ¨¡å¼
                    custom_text_mode: Boolean(rect.custom_text_mode ||
                        (rect.texts && rect.texts.length > 0) ||
                        (rect.texts && rect.texts.length === 0 && [2, 4, 5, 8].includes(rectIdx)))
                })),
                status_rect_index: Number(currentLayout.status_rect_index || 0)
            };

            console.log('ç®€åŒ–çš„å¸ƒå±€æ•°æ®:', JSON.stringify(simplifiedLayout));

            // éªŒè¯ä¿ç•™ä¸€ä½å°æ•°çš„æ•ˆæœ
            simplifiedLayout.rectangles.forEach((rect, i) => {
                if (rect.icons && rect.icons.length > 0) {
                    console.log(`çŸ©å½¢ ${i} å›¾æ ‡ç›¸å¯¹ä½ç½®:`);
                    rect.icons.forEach((icon, j) => {
                        console.log(`  å›¾æ ‡ ${j}: rel_x=${icon.rel_x}, rel_y=${icon.rel_y}`);
                    });
                }
            });

            return simplifiedLayout;
        }
        // éªŒè¯å¸ƒå±€æ•°æ®
        function validateLayoutData(layoutData) {
            const errors = [];

            if (!layoutData) {
                errors.push('å¸ƒå±€æ•°æ®ä¸ºç©º');
                return errors;
            }

            // éªŒè¯å±å¹•å°ºå¯¸
            if (!layoutData.screen_width || !layoutData.screen_height) {
                errors.push('å±å¹•å°ºå¯¸æ•°æ®ä¸å®Œæ•´');
            }

            if (layoutData.screen_width <= 0 || layoutData.screen_height <= 0) {
                errors.push('å±å¹•å°ºå¯¸å¿…é¡»å¤§äº0');
            }

            // éªŒè¯çŸ©å½¢æ•°æ®
            if (!Array.isArray(layoutData.rectangles)) {
                errors.push('rectangles å¿…é¡»æ˜¯ä¸€ä¸ªæ•°ç»„');
                return errors;
            }

            layoutData.rectangles.forEach((rect, index) => {
                if (!rect || typeof rect !== 'object') {
                    errors.push(`çŸ©å½¢ ${index} æ•°æ®æ ¼å¼é”™è¯¯`);
                    return;
                }

                // éªŒè¯å¿…éœ€å­—æ®µ
                const requiredFields = ['x', 'y', 'width', 'height'];
                requiredFields.forEach(field => {
                    if (rect[field] === undefined || rect[field] === null) {
                        errors.push(`çŸ©å½¢ ${index} ç¼ºå°‘ ${field} å­—æ®µ`);
                    } else if (typeof rect[field] !== 'number' || isNaN(rect[field])) {
                        errors.push(`çŸ©å½¢ ${index} çš„ ${field} å¿…é¡»æ˜¯æ•°å­—`);
                    } else if (rect[field] < 0) {
                        errors.push(`çŸ©å½¢ ${index} çš„ ${field} ä¸èƒ½ä¸ºè´Ÿæ•°`);
                    }
                });

                // éªŒè¯å›¾æ ‡æ•°æ®
                if (rect.icons && Array.isArray(rect.icons)) {
                    rect.icons.forEach((icon, iconIndex) => {
                        if (!icon || typeof icon !== 'object') {
                            errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} æ•°æ®æ ¼å¼é”™è¯¯`);
                            return;
                        }

                        // éªŒè¯å›¾æ ‡å¿…éœ€å­—æ®µ
                        if (icon.icon_index === undefined || icon.icon_index === null) {
                            errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} ç¼ºå°‘ icon_index å­—æ®µ`);
                        }

                        // éªŒè¯åæ ‡å’Œå°ºå¯¸
                        const iconFields = ['rel_x', 'rel_y', 'display_x', 'display_y', 'display_width', 'display_height'];
                        iconFields.forEach(field => {
                            if (icon[field] !== undefined && (typeof icon[field] !== 'number' || isNaN(icon[field]))) {
                                errors.push(`çŸ©å½¢ ${index} çš„å›¾æ ‡ ${iconIndex} çš„ ${field} å¿…é¡»æ˜¯æ•°å­—`);
                            }
                        });
                    });
                }
            });

            return errors;
        }
        // ä¿®æ”¹ applyToDevice å‡½æ•°ï¼Œæ·»åŠ éªŒè¯
        async function applyToDevice() {
            try {
                const endpoints = getApiEndpoints();
                const screenName = currentScreenMode === 'vocab' ? 'å•è¯ç•Œé¢' : 'ä¸»ç•Œé¢';
                showLoading('æ­£åœ¨åº”ç”¨' + screenName + 'å¸ƒå±€åˆ°è®¾å¤‡...');
                const layoutData = getCurrentLayout();

                console.log('æ­£åœ¨å‘é€' + screenName + 'å¸ƒå±€æ•°æ®åˆ°è®¾å¤‡:', layoutData);

                // éªŒè¯æ•°æ®
                const validationErrors = validateLayoutData(layoutData);
                if (validationErrors.length > 0) {
                    console.error('æ•°æ®éªŒè¯å¤±è´¥:', validationErrors);
                    showStatus('æ•°æ®éªŒè¯å¤±è´¥: ' + validationErrors.join(', '), 'error');
                    return;
                }

                const response = await fetchWithFallback(endpoints.set, endpoints.set, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(layoutData)
                });

                console.log('å“åº”çŠ¶æ€:', response.status, response.statusText);

                if (response.ok) {
                    const result = await response.json();
                    console.log('æœåŠ¡å™¨å“åº”:', result);
                    showStatus('å¸ƒå±€å·²æˆåŠŸåº”ç”¨åˆ°è®¾å¤‡', 'success');
                } else {
                    // å°è¯•è·å–é”™è¯¯è¯¦æƒ…
                    let errorDetail = '';
                    try {
                        const errorData = await response.text();
                        console.error('é”™è¯¯å“åº”å†…å®¹:', errorData);

                        // å°è¯•è§£æJSONé”™è¯¯
                        try {
                            const errorJson = JSON.parse(errorData);
                            errorDetail = ': ' + JSON.stringify(errorJson);
                        } catch {
                            errorDetail = ': ' + errorData.substring(0, 100);
                        }
                    } catch (e) {
                        errorDetail = 'ï¼Œæ— æ³•è·å–é”™è¯¯è¯¦æƒ…';
                    }
                    showStatus(`åº”ç”¨å¸ƒå±€å¤±è´¥ (HTTP ${response.status}${errorDetail})`, 'error');
                }
            } catch (error) {
                console.error('Error applying layout:', error);
                showStatus('è¿æ¥è®¾å¤‡å¤±è´¥: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }
        // æµ‹è¯•æ•°æ®æ ¼å¼
        function testLayoutData() {
            const layoutData = getCurrentLayout();

            // éªŒè¯æ•°æ®
            const validationErrors = validateLayoutData(layoutData);

            if (validationErrors.length > 0) {
                console.error('æ•°æ®éªŒè¯å¤±è´¥:', validationErrors);
                alert('æ•°æ®éªŒè¯å¤±è´¥:\n' + validationErrors.join('\n'));
            } else {
                console.log('æ•°æ®éªŒè¯é€šè¿‡:', layoutData);

                // æ˜¾ç¤ºæ•°æ®ç»Ÿè®¡
                const rectCount = layoutData.rectangles.length;
                let iconCount = 0;
                layoutData.rectangles.forEach(rect => {
                    if (rect.icons && Array.isArray(rect.icons)) {
                        iconCount += rect.icons.length;
                    }
                });

                alert(`æ•°æ®éªŒè¯é€šè¿‡ï¼\nçŸ©å½¢æ•°: ${rectCount}\nå›¾æ ‡æ•°: ${iconCount}\nå±å¹•å°ºå¯¸: ${layoutData.screen_width}Ã—${layoutData.screen_height}`);
            }
        }
        // ä¿å­˜å¸ƒå±€åˆ°æ–‡ä»¶
        function saveLayoutToFile() {
            const layoutData = getCurrentLayout();
            const dataStr = JSON.stringify(layoutData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });

            const downloadAnchor = document.createElement('a');
            downloadAnchor.setAttribute('href', URL.createObjectURL(dataBlob));
            downloadAnchor.setAttribute('download', 'ink_screen_layout.json');
            document.body.appendChild(downloadAnchor);
            downloadAnchor.click();
            document.body.removeChild(downloadAnchor);

            showStatus('å¸ƒå±€å·²ä¿å­˜åˆ°æ–‡ä»¶', 'success');
        }

        // ä»æ–‡ä»¶åŠ è½½å¸ƒå±€
        function loadLayoutFromFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';

            input.onchange = function (e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const layout = JSON.parse(e.target.result);
                        currentLayout = layout;
                        renderLayout(currentLayout);
                        showStatus('å¸ƒå±€ä»æ–‡ä»¶åŠ è½½æˆåŠŸ', 'success');
                    } catch (error) {
                        showStatus('æ–‡ä»¶æ ¼å¼é”™è¯¯', 'error');
                    }
                };
                reader.readAsText(file);
            };

            input.click();
        }

        // é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€
        function resetToDefault() {
            if (confirm('ç¡®å®šè¦é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€å—ï¼Ÿ')) {
                setDefaultLayout();
                renderLayout(currentLayout);
                showStatus('å·²é‡ç½®ä¸ºé»˜è®¤å¸ƒå±€', 'success');
            }
        }

        // åˆ‡æ¢ç½‘æ ¼æ˜¾ç¤º
        function toggleGrid() {
            const gridLines = document.getElementById('gridLines');
            const show = document.getElementById('showGrid').checked;
            if (gridLines) {
                gridLines.style.display = show ? 'block' : 'none';
            }
        }

        // æ˜¾ç¤ºåŠ è½½é®ç½©
        function showLoading(text = 'å¤„ç†ä¸­...') {
            const overlay = document.getElementById('loadingOverlay');
            const textEl = document.getElementById('loadingText');
            if (overlay && textEl) {
                textEl.textContent = text;
                overlay.style.display = 'flex';
            }
        }

        // éšè—åŠ è½½é®ç½©
        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
        }

        // é”®ç›˜ç§»åŠ¨é€‰ä¸­é¡¹
        document.addEventListener('keydown', function (e) {
            // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†ä¸­ï¼Œä¸æ‰§è¡Œç§»åŠ¨
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            const step = e.shiftKey ? 10 : 1; // æŒ‰ä½ShiftåŠ é€Ÿç§»åŠ¨

            if (selectedRectIndex >= 0) {
                if (selectedIconIndex >= 0) {
                    // ç§»åŠ¨å›¾æ ‡
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    const icon = rect.icons[selectedIconIndex];
                    const iconDiv = document.querySelector(`.icon-canvas[data-rect-index="${selectedRectIndex}"][data-icon-index="${selectedIconIndex}"]`);

                    if (icon && iconDiv) {
                        let newX = parseInt(iconDiv.style.left);
                        let newY = parseInt(iconDiv.style.top);
                        let moved = false;

                        switch (e.key) {
                            case 'ArrowLeft': newX -= step; moved = true; break;
                            case 'ArrowRight': newX += step; moved = true; break;
                            case 'ArrowUp': newY -= step; moved = true; break;
                            case 'ArrowDown': newY += step; moved = true; break;
                        }

                        if (moved) {
                            e.preventDefault();
                            // é™åˆ¶åœ¨çŸ©å½¢èŒƒå›´å†…
                            const iconWidth = parseInt(iconDiv.style.width);
                            const iconHeight = parseInt(iconDiv.style.height);
                            newX = Math.max(rect.x, Math.min(newX, rect.x + rect.width - iconWidth));
                            newY = Math.max(rect.y, Math.min(newY, rect.y + rect.height - iconHeight));

                            iconDiv.style.left = newX + 'px';
                            iconDiv.style.top = newY + 'px';

                            // æ›´æ–°æ•°æ®
                            icon.display_x = newX;
                            icon.display_y = newY;
                            icon.rel_x = (newX - rect.x) / rect.width;
                            icon.rel_y = (newY - rect.y) / rect.height;

                            updateSelectedRectInfo();
                        }
                    }
                } else {
                    // ç§»åŠ¨çŸ©å½¢
                    const rect = currentLayout.rectangles[selectedRectIndex];
                    const rectDiv = document.querySelector(`.rect[data-index="${selectedRectIndex}"]`);

                    if (rect && rectDiv) {
                        let newX = rect.x;
                        let newY = rect.y;
                        let moved = false;

                        switch (e.key) {
                            case 'ArrowLeft': newX -= step; moved = true; break;
                            case 'ArrowRight': newX += step; moved = true; break;
                            case 'ArrowUp': newY -= step; moved = true; break;
                            case 'ArrowDown': newY += step; moved = true; break;
                        }

                        if (moved) {
                            e.preventDefault();
                            // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                            newX = Math.max(0, Math.min(newX, currentLayout.screen.width - rect.width));
                            newY = Math.max(0, Math.min(newY, currentLayout.screen.height - rect.height));

                            // æ£€æŸ¥ç¢°æ’
                            const tempRect = { ...rect, x: newX, y: newY };
                            if (!checkRectCollision(tempRect, selectedRectIndex)) {
                                rect.x = newX;
                                rect.y = newY;
                                rect.original_x = newX;
                                rect.original_y = newY;

                                rectDiv.style.left = newX + 'px';
                                rectDiv.style.top = newY + 'px';

                                // ç§»åŠ¨çŸ©å½¢å†…çš„å›¾æ ‡
                                if (rect.icons) {
                                    rect.icons.forEach((icon, idx) => {
                                        const iconDiv = document.querySelector(`.icon-canvas[data-rect-index="${selectedRectIndex}"][data-icon-index="${idx}"]`);
                                        if (iconDiv) {
                                            // é‡æ–°è®¡ç®—å›¾æ ‡ç»å¯¹ä½ç½®
                                            const iconX = rect.x + icon.rel_x * rect.width;
                                            const iconY = rect.y + icon.rel_y * rect.height;
                                            icon.display_x = iconX;
                                            icon.display_y = iconY;
                                            iconDiv.style.left = iconX + 'px';
                                            iconDiv.style.top = iconY + 'px';
                                        }
                                    });
                                }

                                updateSelectedRectInfo();
                            }
                        }
                    }
                }
            }
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', init);

        // ç‚¹å‡»å±å¹•ç©ºç™½å¤„å–æ¶ˆé€‰ä¸­
        document.getElementById('screenContainer').onclick = function (e) {
            if (e.target === this || e.target.className === 'grid-lines' || e.target.id === 'alignmentGuides') {
                selectedRectIndex = -1;
                selectedIconIndex = -1;

                // æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
                document.querySelectorAll('.rect').forEach(rect => {
                    rect.classList.remove('selected');
                });
                document.querySelectorAll('.icon-canvas').forEach(icon => {
                    icon.classList.remove('selected');
                });

                updateSelectedRectInfo();
            }
        };

        // ==================== ç„¦ç‚¹çŸ©å½¢é…ç½®åŠŸèƒ½ ====================

        let focusableRects = [];  // å­˜å‚¨å¯ç„¦ç‚¹çŸ©å½¢çš„ç´¢å¼•æ•°ç»„

        /**
         * æ›´æ–°ç„¦ç‚¹é…ç½®å¤é€‰æ¡†åˆ—è¡¨
         */
        function updateFocusConfigCheckboxes() {
            const container = document.getElementById('focusableRectsCheckboxes');
            if (!container) return;

            container.innerHTML = '';

            const rectCount = currentLayout.rectangles.length;
            if (rectCount === 0) {
                container.innerHTML = '\u003cp style="color: #999; text-align: center;"\u003eå½“å‰æ²¡æœ‰çŸ©å½¢\u003c/p\u003e';
                return;
            }

            for (let i = 0; i < rectCount; i++) {
                const rect = currentLayout.rectangles[i];
                const isChecked = focusableRects.includes(i);

                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; align-items: center;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `focusRect${i}`;
                checkbox.value = i;
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
                checkbox.onchange = function () {
                    updateFocusableRectsArray();
                };

                const label = document.createElement('label');
                label.htmlFor = `focusRect${i}`;
                label.style.cssText = 'cursor: pointer; flex: 1; font-size: 14px;';
                label.innerHTML = `\u003cstrong\u003eçŸ©å½¢ ${i}\u003c/strong\u003e - (${rect.x}, ${rect.y}) ${rect.width}Ã—${rect.height}`;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                container.appendChild(checkboxDiv);
            }
        }

        /**
         * æ›´æ–°å¯ç„¦ç‚¹çŸ©å½¢æ•°ç»„
         */
        function updateFocusableRectsArray() {
            focusableRects = [];
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]:checked');
            checkboxes.forEach(cb => {
                focusableRects.push(parseInt(cb.value));
            });

            console.log('å¯ç„¦ç‚¹çŸ©å½¢å·²æ›´æ–°:', focusableRects);
            updateFocusConfigInfo();
            updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
        }

        /**
         * å…¨é€‰ç„¦ç‚¹çŸ©å½¢
         */
        function selectAllFocusableRects() {
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateFocusableRectsArray();
        }

        /**
         * å…¨ä¸é€‰ç„¦ç‚¹çŸ©å½¢
         */
        function deselectAllFocusableRects() {
            const checkboxes = document.querySelectorAll('#focusableRectsCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            updateFocusableRectsArray();
        }

        /**
         * æ›´æ–°ç„¦ç‚¹é…ç½®ä¿¡æ¯æ˜¾ç¤º
         */
        function updateFocusConfigInfo() {
            const infoDiv = document.getElementById('focusConfigInfo');
            const statusDiv = document.getElementById('focusConfigStatus');

            if (!infoDiv || !statusDiv) return;

            if (focusableRects.length === 0) {
                statusDiv.style.display = 'none';
                return;
            }

            statusDiv.style.display = 'block';
            infoDiv.innerHTML = `å…± ${focusableRects.length} ä¸ªå¯ç„¦ç‚¹çŸ©å½¢: [${focusableRects.join(', ')}]`;
        }

        /**
         * ä¿å­˜ç„¦ç‚¹é…ç½®åˆ°è®¾å¤‡
         */
        async function saveFocusConfig() {
            if (focusableRects.length === 0) {
                alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯ç„¦ç‚¹çŸ©å½¢ï¼');
                return;
            }

            const config = {
                count: focusableRects.length,
                focusable_indices: focusableRects,
                screen_type: currentScreenMode  // æ·»åŠ ç•Œé¢ç±»å‹ (main æˆ– vocab)
            };

            try {
                showLoading('æ­£åœ¨ä¿å­˜' + (currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢') + 'ç„¦ç‚¹é…ç½®...');

                const response = await fetchWithFallback('/setfocusconfig', '/setfocusconfig', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                hideLoading();

                if (response.ok) {
                    const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                    showStatus(screenName + 'ç„¦ç‚¹é…ç½®å·²ä¿å­˜åˆ°è®¾å¤‡ï¼', 'success');
                    console.log(screenName + 'ç„¦ç‚¹é…ç½®å·²ä¿å­˜:', config);
                } else {
                    showStatus('ä¿å­˜ç„¦ç‚¹é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('ä¿å­˜ç„¦ç‚¹é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('ä¿å­˜ç„¦ç‚¹é…ç½®é”™è¯¯:', error);
            }
        }

        /**
         * ä»è®¾å¤‡åŠ è½½ç„¦ç‚¹é…ç½®
         */
        async function loadFocusConfig() {
            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨åŠ è½½' + screenName + 'ç„¦ç‚¹é…ç½®...');

                const focusPath = '/getfocusconfig?screen_type=' + currentScreenMode;
                const response = await fetchWithFallback(focusPath, focusPath);
                hideLoading();

                if (response.ok) {
                    const config = await response.json();

                    if (config && config.focusable_indices && Array.isArray(config.focusable_indices)) {
                        focusableRects = config.focusable_indices;
                        updateFocusConfigCheckboxes();
                        updateFocusConfigInfo();
                        updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
                        showStatus(screenName + `ç„¦ç‚¹é…ç½®å·²åŠ è½½ï¼š${config.count} ä¸ªå¯ç„¦ç‚¹çŸ©å½¢`, 'success');
                        console.log(screenName + 'ç„¦ç‚¹é…ç½®å·²åŠ è½½:', config);
                    } else {
                        showStatus('è®¾å¤‡ä¸Šæ²¡æœ‰' + screenName + 'ç„¦ç‚¹é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®', 'error');
                        // é»˜è®¤æ‰€æœ‰çŸ©å½¢éƒ½å¯ç„¦ç‚¹
                        focusableRects = Array.from({ length: currentLayout.rectangles.length }, (_, i) => i);
                        updateFocusConfigCheckboxes();
                        updateSubArrayParentSelect();  // æ›´æ–°å­æ•°ç»„æ¯çŸ©å½¢ä¸‹æ‹‰æ¡†
                    }
                } else {
                    showStatus('åŠ è½½' + screenName + 'ç„¦ç‚¹é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('åŠ è½½ç„¦ç‚¹é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('åŠ è½½ç„¦ç‚¹é…ç½®é”™è¯¯:', error);
            }
        }

        // ==================== å­æ•°ç»„é…ç½®åŠŸèƒ½ ====================

        let subArrayConfig = {};  // å­˜å‚¨å­æ•°ç»„é…ç½® { parent_index: [sub_indices...] }

        /**
         * æ›´æ–°æ¯æ•°ç»„çŸ©å½¢é€‰æ‹©ä¸‹æ‹‰æ¡†
         */
        function updateSubArrayParentSelect() {
            const select = document.getElementById('subArrayParentSelect');
            if (!select) return;

            // ä¿å­˜å½“å‰é€‰ä¸­å€¼
            const currentValue = select.value;

            // æ¸…ç©ºå¹¶é‡æ–°å¡«å……
            select.innerHTML = '<option value="">-- è¯·é€‰æ‹©æ¯æ•°ç»„çŸ©å½¢ --</option>';

            // ä»ç„¦ç‚¹é…ç½®ä¸­è·å–æ¯æ•°ç»„çŸ©å½¢
            focusableRects.forEach((rectIndex, arrayIndex) => {
                const rect = currentLayout.rectangles[rectIndex];
                if (rect) {
                    const option = document.createElement('option');
                    option.value = arrayIndex;
                    option.textContent = `æ¯æ•°ç»„[${arrayIndex}] - çŸ©å½¢${rectIndex} (${rect.width}Ã—${rect.height})`;
                    select.appendChild(option);
                }
            });

            // æ¢å¤é€‰ä¸­å€¼
            if (currentValue !== '') {
                select.value = currentValue;
            }
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®ç•Œé¢
         */
        function updateSubArrayConfig() {
            const select = document.getElementById('subArrayParentSelect');
            const checkboxContainer = document.getElementById('subArrayCheckboxes');

            if (!select || !checkboxContainer) return;

            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) {
                checkboxContainer.style.display = 'none';
                return;
            }

            checkboxContainer.style.display = 'block';
            checkboxContainer.innerHTML = '';

            const parentRectIndex = focusableRects[parentIndex];

            // æ˜¾ç¤ºå¯é€‰çš„å­çŸ©å½¢ï¼ˆæ‰€æœ‰æœ‰æ•ˆçŸ©å½¢ï¼Œæ’é™¤å½“å‰æ¯çŸ©å½¢ï¼‰
            const rectCount = currentLayout.rectangles.length;
            const currentSubArray = subArrayConfig[parentIndex] || [];

            for (let i = 0; i < rectCount; i++) {
                const rect = currentLayout.rectangles[i];
                if (!rect || rect.width <= 0 || rect.height <= 0) continue;
                if (i === parentRectIndex) continue;  // æ’é™¤æ¯çŸ©å½¢æœ¬èº«

                const isChecked = currentSubArray.includes(i);

                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px; display: flex; align-items: center;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `subRect_${parentIndex}_${i}`;
                checkbox.value = i;
                checkbox.checked = isChecked;
                checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; cursor: pointer;';
                checkbox.onchange = function() {
                    updateSubArrayConfigData();
                };

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.style.cssText = 'cursor: pointer; flex: 1; font-size: 14px;';
                label.innerHTML = `<strong>çŸ©å½¢ ${i}</strong> - (${rect.x}, ${rect.y}) ${rect.width}Ã—${rect.height}`;

                checkboxDiv.appendChild(checkbox);
                checkboxDiv.appendChild(label);
                checkboxContainer.appendChild(checkboxDiv);
            }

            updateSubArrayConfigInfo();
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®æ•°æ®
         */
        function updateSubArrayConfigData() {
            const select = document.getElementById('subArrayParentSelect');
            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) return;

            const checkboxes = document.querySelectorAll(`#subArrayCheckboxes input[type="checkbox"]:checked`);
            const subIndices = [];

            checkboxes.forEach(cb => {
                subIndices.push(parseInt(cb.value));
            });

            if (subIndices.length > 0) {
                subArrayConfig[parentIndex] = subIndices;
            } else {
                delete subArrayConfig[parentIndex];
            }

            updateSubArrayConfigInfo();
            console.log('å­æ•°ç»„é…ç½®å·²æ›´æ–°:', subArrayConfig);
        }

        /**
         * æ¸…ç©ºå½“å‰é€‰ä¸­çš„å­æ•°ç»„
         */
        function clearSubArray() {
            const select = document.getElementById('subArrayParentSelect');
            const parentIndex = parseInt(select.value);

            if (isNaN(parentIndex)) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ¯æ•°ç»„çŸ©å½¢ï¼');
                return;
            }

            delete subArrayConfig[parentIndex];

            // å–æ¶ˆæ‰€æœ‰å¤é€‰æ¡†
            const checkboxes = document.querySelectorAll('#subArrayCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);

            updateSubArrayConfigInfo();
            showStatus(`å·²æ¸…ç©ºæ¯æ•°ç»„[${parentIndex}]çš„å­æ•°ç»„é…ç½®`, 'success');
        }

        /**
         * æ›´æ–°å­æ•°ç»„é…ç½®ä¿¡æ¯æ˜¾ç¤º
         */
        function updateSubArrayConfigInfo() {
            const statusDiv = document.getElementById('subArrayConfigStatus');
            const infoDiv = document.getElementById('subArrayConfigInfo');

            if (!statusDiv || !infoDiv) return;

            const configCount = Object.keys(subArrayConfig).length;

            if (configCount === 0) {
                statusDiv.style.display = 'none';
                return;
            }

            statusDiv.style.display = 'block';

            let html = `<div style="font-size: 12px;">`;
            html += `<p style="margin-bottom: 8px;">å·²é…ç½® ${configCount} ä¸ªæ¯æ•°ç»„å…ƒç´ çš„å­æ•°ç»„ï¼š</p>`;

            for (const [parentIdx, subIndices] of Object.entries(subArrayConfig)) {
                const parentRectIndex = focusableRects[parseInt(parentIdx)];
                html += `<div style="margin: 5px 0; padding: 5px; background: white; border-radius: 3px;">`;
                html += `<strong>æ¯[${parentIdx}]çŸ©å½¢${parentRectIndex}</strong> â†’ å­æ•°ç»„: [${subIndices.join(', ')}] (${subIndices.length}ä¸ª)`;
                html += `</div>`;
            }

            html += `</div>`;
            infoDiv.innerHTML = html;
        }

        /**
         * ä¿å­˜å­æ•°ç»„é…ç½®åˆ°è®¾å¤‡
         */
        async function saveSubArrayConfig() {
            if (Object.keys(subArrayConfig).length === 0) {
                alert('å½“å‰æ²¡æœ‰é…ç½®ä»»ä½•å­æ•°ç»„ï¼');
                return;
            }

            // è½¬æ¢ä¸ºè®¾å¤‡éœ€è¦çš„æ ¼å¼
            const configData = {
                sub_arrays: [],
                screen_type: currentScreenMode  // æ·»åŠ ç•Œé¢ç±»å‹
            };

            for (const [parentIdx, subIndices] of Object.entries(subArrayConfig)) {
                configData.sub_arrays.push({
                    parent_index: parseInt(parentIdx),
                    sub_indices: subIndices,
                    sub_count: subIndices.length
                });
            }

            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨ä¿å­˜' + screenName + 'å­æ•°ç»„é…ç½®...');

                const response = await fetchWithFallback('/setsubarrayconfig', '/setsubarrayconfig', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configData)
                });

                hideLoading();

                if (response.ok) {
                    showStatus('å­æ•°ç»„é…ç½®å·²ä¿å­˜åˆ°è®¾å¤‡ï¼', 'success');
                    console.log('å­æ•°ç»„é…ç½®å·²ä¿å­˜:', configData);
                } else {
                    showStatus('ä¿å­˜å­æ•°ç»„é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('ä¿å­˜å­æ•°ç»„é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('ä¿å­˜å­æ•°ç»„é…ç½®é”™è¯¯:', error);
            }
        }

        /**
         * ä»è®¾å¤‡åŠ è½½å­æ•°ç»„é…ç½®
         */
        async function loadSubArrayConfig() {
            try {
                const screenName = currentScreenMode === 'main' ? 'ä¸»ç•Œé¢' : 'å•è¯ç•Œé¢';
                showLoading('æ­£åœ¨åŠ è½½' + screenName + 'å­æ•°ç»„é…ç½®...');

                const subarrayPath = '/getsubarrayconfig?screen_type=' + currentScreenMode;
                const response = await fetchWithFallback(subarrayPath, subarrayPath);
                hideLoading();

                if (response.ok) {
                    const data = await response.json();

                    if (data && data.sub_arrays && Array.isArray(data.sub_arrays)) {
                        subArrayConfig = {};

                        data.sub_arrays.forEach(item => {
                            if (item.parent_index !== undefined && item.sub_indices && Array.isArray(item.sub_indices)) {
                                subArrayConfig[item.parent_index] = item.sub_indices;
                            }
                        });

                        updateSubArrayParentSelect();
                        updateSubArrayConfig();
                        updateSubArrayConfigInfo();

                        showStatus(screenName + `å­æ•°ç»„é…ç½®å·²åŠ è½½ï¼š${data.sub_arrays.length} ä¸ªé…ç½®`, 'success');
                        console.log(screenName + 'å­æ•°ç»„é…ç½®å·²åŠ è½½:', subArrayConfig);
                    } else {
                        showStatus('è®¾å¤‡ä¸Šæ²¡æœ‰' + screenName + 'å­æ•°ç»„é…ç½®', 'error');
                        subArrayConfig = {};
                    }
                } else {
                    showStatus('åŠ è½½' + screenName + 'å­æ•°ç»„é…ç½®å¤±è´¥ï¼', 'error');
                }
            } catch (error) {
                hideLoading();
                showStatus('åŠ è½½å­æ•°ç»„é…ç½®æ—¶å‘ç”Ÿé”™è¯¯: ' + error.message, 'error');
                console.error('åŠ è½½å­æ•°ç»„é…ç½®é”™è¯¯:', error);
            }
        }

        // ============================================
        // å­—ä½“å’Œå›¾ç‰‡è½¬æ¢åŠŸèƒ½ (ä»web_layout.htmlç§»æ¤)
        // ============================================

        /**
         * å¤„ç† TTF å­—ä½“æ–‡ä»¶ä¸Šä¼ 
         */
        function handleTTFUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentTTFFile = file;  // ä¿å­˜åŸå§‹æ–‡ä»¶å¯¹è±¡
            currentFontName = file.name.replace(/\.(ttf|otf)$/i, '');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                currentTTFFont = e.target.result;
                document.getElementById('fontStatusMessage').innerHTML = 
                    `âœ… å·²åŠ è½½å­—ä½“: ${file.name}`;
                
                // è‡ªåŠ¨é¢„è§ˆ
                previewTTFFont();
            };
            reader.readAsDataURL(file);
        }

        /**
         * é¢„è§ˆ TTF å­—ä½“
         */
        function previewTTFFont() {
            if (!currentTTFFont) {
                alert('è¯·å…ˆä¸Šä¼  TTF å­—ä½“æ–‡ä»¶ï¼');
                return;
            }

            const text = document.getElementById('previewText').value;
            // ç›´æ¥ä½¿ç”¨å­—åº“å°ºå¯¸é€‰æ‹©å™¨çš„å€¼ä½œä¸ºé¢„è§ˆå­—å·
            const fontSize = parseInt(document.getElementById('binFontSize').value) || 16;
            const previewDiv = document.getElementById('fontPreviewCanvas');

            // åˆ›å»ºé¢„è§ˆ Canvas
            if (!fontCanvas) {
                fontCanvas = document.createElement('canvas');
                fontContext = fontCanvas.getContext('2d');
            }

            // è®¡ç®—éœ€è¦çš„ç”»å¸ƒå¤§å°
            const canvasWidth = 400;
            const canvasHeight = parseInt(fontSize) * 3;
            fontCanvas.width = canvasWidth;
            fontCanvas.height = canvasHeight;

            // æ¸…ç©ºå¹¶è®¾ç½®èƒŒæ™¯
            fontContext.fillStyle = '#ffffff';
            fontContext.fillRect(0, 0, canvasWidth, canvasHeight);

            // åŠ è½½å­—ä½“
            const fontFace = new FontFace(currentFontName, `url(${currentTTFFont})`);
            fontFace.load().then(function(loadedFont) {
                document.fonts.add(loadedFont);
                
                // ç»˜åˆ¶æ–‡å­—
                fontContext.font = `${fontSize}px "${currentFontName}"`;
                fontContext.fillStyle = '#000000';
                fontContext.textBaseline = 'top';
                fontContext.fillText(text, 10, parseInt(fontSize) / 2);

                // æ˜¾ç¤ºé¢„è§ˆ
                previewDiv.innerHTML = '';
                previewDiv.appendChild(fontCanvas);
                
                // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯ï¼Œè¯´æ˜é¢„è§ˆå­—å·
                const statusMsg = document.getElementById('fontStatusMessage');
                if (statusMsg) {
                    statusMsg.innerHTML = `âœ… å­—ä½“é¢„è§ˆæˆåŠŸ (é¢„è§ˆä½¿ç”¨ ${fontSize}pt)`;
                }
            }).catch(function(error) {
                alert('å­—ä½“åŠ è½½å¤±è´¥: ' + error);
                console.error('Font load error:', error);
            });
        }

        let generatedBinFilename = null;
        let generatedBinData = null;  // ä¿å­˜ç”Ÿæˆçš„ .bin æ–‡ä»¶æ•°æ®ï¼Œä¾›ä¸Šä¼ ä½¿ç”¨

        /**
         * è½¬æ¢TTFä¸º.binå­—åº“æ–‡ä»¶ (ç”¨äºæ··åˆç¼“å­˜ç³»ç»Ÿ)
         */
        async function convertTTFtoBin() {
            if (!currentTTFFile) {
                alert('è¯·å…ˆä¸Šä¼  TTF å­—ä½“æ–‡ä»¶ï¼');
                return;
            }

            const binSize = parseInt(document.getElementById('binFontSize').value);
            const charsetRange = document.getElementById('charsetRange').value;
            const fontName = currentFontName.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
            
            const statusDiv = document.getElementById('binGenerationStatus');
            const charsetLabel = charsetRange === 'english' ? 'è‹±æ–‡ASCII' : 'GB2312æ±‰å­—';
            const estimatedTime = charsetRange === 'english' ? 'æ•°ç§’' : '1-3åˆ†é’Ÿ';
            
            statusDiv.innerHTML = 
                `<div style="color: #ff9800; font-weight: bold;">â³ æ­£åœ¨ç”Ÿæˆ ${binSize}x${binSize} .binå­—åº“æ–‡ä»¶...</div>` +
                `<div style="color: #666;">å­—ç¬¦é›†: ${charsetLabel}, é¢„è®¡è€—æ—¶: ${estimatedTime}...</div>`;
            
            // éšè—ä¸‹è½½æŒ‰é’®
            document.getElementById('downloadBinBtn').style.display = 'none';
            document.getElementById('uploadBinBtn').style.display = 'none';

            try {
                // è¯»å– TTF æ–‡ä»¶ä¸º base64
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const ttfBase64 = e.target.result.split(',')[1];

                    const startTime = Date.now();

                    // è°ƒç”¨ Python åç«¯ APIï¼ˆä¼˜å…ˆ PC ç«¯ï¼Œé™çº§åˆ° Pythonï¼‰
                    const response = await fetchWithFallbackForPython('/convert_ttf_to_bin', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            ttf_base64: ttfBase64,
                            font_size: binSize,
                            font_name: fontName,
                            char_range: charsetRange
                        }),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);

                    if (result.success) {
                        generatedBinFilename = result.filename;
                        
                        statusDiv.innerHTML = 
                            `<div style="color: green; font-weight: bold; margin-bottom: 10px;">âœ… .binå­—åº“ç”ŸæˆæˆåŠŸï¼(è€—æ—¶ ${elapsedTime}ç§’)</div>` +
                            `<div style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-size: 11px;">` +
                            `<strong>ğŸ“‹ æ–‡ä»¶ä¿¡æ¯:</strong><br>` +
                            `â€¢ æ–‡ä»¶å: <span style="color: #0066cc; font-family: monospace;">${result.filename}</span><br>` +
                            `â€¢ æ–‡ä»¶å¤§å°: <strong>${result.file_size_kb} KB</strong><br>` +
                            `â€¢ å­—ç¬¦æ€»æ•°: ${result.char_count}<br>` +
                            `â€¢ å·²ç”Ÿæˆå­—ç¬¦: ${result.generated_count}<br>` +
                            `â€¢ å­—æ¨¡å°ºå¯¸: ${result.font_size}x${result.font_size}<br>` +
                            `â€¢ æ¯å­—èŠ‚æ•°: ${result.glyph_size} bytes<br>` +
                            `<br><strong>ğŸ’¾ æœ¬åœ°è·¯å¾„:</strong><br>` +
                            `<span style="color: #0066cc; font-family: monospace; font-size: 10px; word-break: break-all;">${result.saved_path}</span><br>` +
                            `<br><span style="color: #4CAF50;">âœ… æ­¤æ–‡ä»¶å¯ç›´æ¥ç”¨äº ChineseFontCache æ··åˆç¼“å­˜ç³»ç»Ÿ</span>` +
                            `</div>`;
                        
                        // æ˜¾ç¤ºä¸‹è½½å’Œä¸Šä¼ æŒ‰é’®
                        document.getElementById('downloadBinBtn').style.display = 'inline-block';
                        document.getElementById('uploadBinBtn').style.display = 'inline-block';
                    } else {
                        throw new Error(result.error || 'ç”Ÿæˆå¤±è´¥');
                    }
                };

                reader.onerror = function() {
                    statusDiv.innerHTML = `<div style="color: red;">âŒ è¯»å– TTF æ–‡ä»¶å¤±è´¥</div>`;
                };

                reader.readAsDataURL(currentTTFFile);

            } catch (error) {
                console.error('.binå­—åº“ç”Ÿæˆå¤±è´¥:', error);
                statusDiv.innerHTML = 
                    `<div style="color: red; font-weight: bold;">âŒ ç”Ÿæˆå¤±è´¥: ${error.message}</div>` +
                    `<div style="color: orange; margin-top: 5px;">è¯·ç¡®ä¿ Python æœåŠ¡å·²å¯åŠ¨: python tools/ttf_to_gfx_webservice.py</div>`;
            }
        }

        /**
         * ä¸‹è½½ç”Ÿæˆçš„.binæ–‡ä»¶ - ä¿å­˜åˆ° components/resource/fonts ç›®å½•
         */
        async function downloadBinFile() {
            if (!generatedBinFilename) {
                alert('è¯·å…ˆç”Ÿæˆ .bin æ–‡ä»¶ï¼');
                return;
            }

            try {
                const statusDiv = document.getElementById('binGenerationStatus');
                statusDiv.innerHTML += `<div style="color: #ff9800; margin-top: 10px;">â³ æ­£åœ¨ä¿å­˜åˆ°æœ¬åœ°èµ„æºç›®å½•...</div>`;
                
                // ä»æœåŠ¡å™¨è·å– .bin æ–‡ä»¶
                const response = await fetchWithFallbackForPython(`/download_bin_file?filename=${encodeURIComponent(generatedBinFilename)}`);
                
                if (!response.ok) {
                    throw new Error('è·å–æ–‡ä»¶å¤±è´¥');
                }

                const blob = await response.blob();
                
                // ä¿å­˜ blob æ•°æ®ä¾›ä¸Šä¼ ä½¿ç”¨
                generatedBinData = blob;
                
                const file = new File([blob], generatedBinFilename, { type: 'application/octet-stream' });
                
                // è°ƒç”¨ Python æœåŠ¡ä¿å­˜åˆ° components/resource/fonts ç›®å½•
                const formData = new FormData();
                formData.append('file', file);
                formData.append('filename', generatedBinFilename);
                
                const saveResponse = await fetchWithFallbackForPython('/save_font_file', {
                    method: 'POST',
                    body: formData
                });
                
                if (!saveResponse.ok) {
                    throw new Error('ä¿å­˜åˆ°æœ¬åœ°å¤±è´¥');
                }
                
                const saveResult = await saveResponse.json();
                if (!saveResult.success) {
                    throw new Error(saveResult.error || 'ä¿å­˜å¤±è´¥');
                }

                statusDiv.innerHTML += 
                    `<div style="color: green; margin-top: 10px; font-weight: bold;">âœ… æ–‡ä»¶å·²ä¿å­˜åˆ°æœ¬åœ°èµ„æºç›®å½•</div>` +
                    `<div style="color: #0066cc; font-family: monospace; font-size: 11px;">è·¯å¾„: ${saveResult.saved_path}</div>`;

            } catch (error) {
                console.error('ä¿å­˜å¤±è´¥:', error);
                const statusDiv = document.getElementById('binGenerationStatus');
                statusDiv.innerHTML += 
                    `<div style="color: red; margin-top: 10px;">âŒ ä¿å­˜å¤±è´¥: ${error.message}</div>` +
                    `<div style="color: orange; font-size: 11px;">è¯·ç¡®ä¿ Python æœåŠ¡å·²å¯åŠ¨</div>`;
            }
        }

        /**
         * ä¸Šä¼ .binæ–‡ä»¶åˆ°SDå¡ - ä½¿ç”¨ /upload æ¥å£
         */
        async function uploadBinToSD() {
            if (!generatedBinFilename) {
                alert('è¯·å…ˆç”Ÿæˆ .bin æ–‡ä»¶ï¼');
                return;
            }

            if (!confirm(`ç¡®è®¤å°† ${generatedBinFilename} ä¸Šä¼ åˆ° ESP32 SD å¡æ ¹ç›®å½•ï¼Ÿ\n\næ–‡ä»¶è¾ƒå¤§ï¼Œä¸Šä¼ å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´ã€‚`)) {
                return;
            }

            try {
                const statusDiv = document.getElementById('binGenerationStatus');
                statusDiv.innerHTML += `<div style="color: #ff9800; margin-top: 10px;">â³ æ­£åœ¨ä¸Šä¼ åˆ° SD å¡...</div>`;

                // æ–¹æ³•1ï¼šå¦‚æœå·²ç»æœ‰ blob æ•°æ®ï¼ˆä» downloadBinFile ä¸­çš„ generatedBinDataï¼‰
                let fileData = null;
                
                // å°è¯•ä»æœ¬åœ° Python æœåŠ¡ç›´æ¥è·å–æ–‡ä»¶
                try {
                    const response = await fetchWithFallbackForPython(`/download_bin_file?filename=${encodeURIComponent(generatedBinFilename)}`);
                    if (response.ok) {
                        fileData = await response.blob();
                    }
                } catch (e) {
                    console.warn('ä» Python æœåŠ¡è·å–æ–‡ä»¶å¤±è´¥ï¼Œå°è¯•ä»æœ¬åœ°é‡æ–°ç”Ÿæˆ...');
                }

                if (!fileData) {
                    throw new Error('æ— æ³•è·å– .bin æ–‡ä»¶ï¼Œè¯·å…ˆç‚¹å‡»"ä¸‹è½½.binæ–‡ä»¶"æŒ‰é’®ä¿å­˜æ–‡ä»¶');
                }

                const file = new File([fileData], generatedBinFilename, { type: 'application/octet-stream' });

                // ä¸Šä¼ åˆ° ESP32 SD å¡æ ¹ç›®å½• (ä½¿ç”¨ /upload æ¥å£)
                await uploadFileToSD(file, '/');

                statusDiv.innerHTML += 
                    `<div style="color: green; font-weight: bold; margin-top: 10px;">âœ… æ–‡ä»¶å·²æˆåŠŸä¸Šä¼ åˆ° SD å¡æ ¹ç›®å½•ï¼</div>` +
                    `<div style="color: #666; font-size: 11px;">å¯ä»¥åœ¨ ChineseFontCache ä¸­ä½¿ç”¨: cache.init("/sd/${generatedBinFilename}", true);</div>`;

            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                const statusDiv = document.getElementById('binGenerationStatus');
                statusDiv.innerHTML += 
                    `<div style="color: red; margin-top: 10px;">âŒ ä¸Šä¼ å¤±è´¥: ${error.message}</div>` +
                    `<div style="color: orange; font-size: 11px;">è¯·ç¡®ä¿ ESP32 å·²è¿æ¥ã€SD å¡å·²æ’å…¥ä¸”æœ‰è¶³å¤Ÿç©ºé—´</div>`;
            }
        }

        /**
         * å¤„ç†å›¾ç‰‡æ–‡ä»¶ä¸Šä¼ 
         */
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            currentImageFile = file;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImageData = e.target.result;
                
                const img = new Image();
                img.onload = function() {
                    // è‡ªåŠ¨è®¾ç½®å°ºå¯¸ä¸ºå›¾ç‰‡åŸå§‹å°ºå¯¸
                    document.getElementById('imageWidth').value = Math.min(img.width, 400);
                    document.getElementById('imageHeight').value = Math.min(img.height, 300);
                    
                    document.getElementById('imageStatusMessage').innerHTML = 
                        `âœ… å·²åŠ è½½å›¾ç‰‡: ${file.name} (${img.width}x${img.height})`;
                    
                    // è‡ªåŠ¨é¢„è§ˆ
                    previewImage();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * é¢„è§ˆå›¾ç‰‡å¤„ç†æ•ˆæœ
         */
        function previewImage() {
            if (!currentImageData) {
                alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            const width = parseInt(document.getElementById('imageWidth').value);
            const height = parseInt(document.getElementById('imageHeight').value);
            const mode = document.getElementById('imageMode').value;
            const threshold = parseInt(document.getElementById('imageThreshold').value);

            const img = new Image();
            img.onload = function() {
                // åˆ›å»ºæºå›¾ç‰‡ canvas
                srcImageCanvas = document.getElementById('srcImageCanvas');
                srcImageCanvas.width = width;
                srcImageCanvas.height = height;
                const srcCtx = srcImageCanvas.getContext('2d');
                srcCtx.drawImage(img, 0, 0, width, height);

                // åˆ›å»ºç›®æ ‡ canvas
                dstImageCanvas = document.getElementById('dstImageCanvas');
                dstImageCanvas.width = width;
                dstImageCanvas.height = height;
                const dstCtx = dstImageCanvas.getContext('2d');

                // è·å–æºå›¾ç‰‡æ•°æ®
                const srcImageData = srcCtx.getImageData(0, 0, width, height);
                const dstImageData = dstCtx.createImageData(width, height);

                if (mode === 'threshold') {
                    // é˜ˆå€¼äºŒå€¼åŒ–
                    processThreshold(srcImageData, dstImageData, threshold);
                } else {
                    // Floyd-Steinberg æŠ–åŠ¨ç®—æ³•
                    processDithering(srcImageData, dstImageData);
                }

                dstCtx.putImageData(dstImageData, 0, 0);
                
                document.getElementById('imageStatusMessage').innerHTML = 
                    `âœ… é¢„è§ˆå®Œæˆ (${width}x${height}, ${mode === 'threshold' ? 'é˜ˆå€¼: ' + threshold : 'æŠ–åŠ¨ç®—æ³•'})`;
            };
            img.src = currentImageData;
        }

        /**
         * é˜ˆå€¼äºŒå€¼åŒ–å¤„ç†
         */
        function processThreshold(srcData, dstData, threshold) {
            for (let i = 0; i < srcData.data.length; i += 4) {
                // è½¬æ¢ä¸ºç°åº¦å€¼
                const gray = srcData.data[i] * 0.299 + srcData.data[i + 1] * 0.587 + srcData.data[i + 2] * 0.114;
                const value = gray >= threshold ? 255 : 0;
                
                dstData.data[i] = value;
                dstData.data[i + 1] = value;
                dstData.data[i + 2] = value;
                dstData.data[i + 3] = 255;
            }
        }

        /**
         * Floyd-Steinberg æŠ–åŠ¨ç®—æ³•
         */
        function processDithering(srcData, dstData) {
            const width = srcData.width;
            const height = srcData.height;
            
            // å¤åˆ¶æºæ•°æ®åˆ°ä¸´æ—¶æ•°ç»„
            const temp = new Float32Array(width * height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    temp[y * width + x] = srcData.data[i] * 0.299 + srcData.data[i + 1] * 0.587 + srcData.data[i + 2] * 0.114;
                }
            }

            // Floyd-Steinberg æŠ–åŠ¨
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;
                    const oldPixel = temp[idx];
                    const newPixel = oldPixel < 128 ? 0 : 255;
                    temp[idx] = newPixel;
                    
                    const error = oldPixel - newPixel;
                    
                    // åˆ†é…è¯¯å·®åˆ°å‘¨å›´åƒç´ 
                    if (x + 1 < width) temp[idx + 1] += error * 7 / 16;
                    if (y + 1 < height) {
                        if (x > 0) temp[idx + width - 1] += error * 3 / 16;
                        temp[idx + width] += error * 5 / 16;
                        if (x + 1 < width) temp[idx + width + 1] += error * 1 / 16;
                    }
                    
                    // è®¾ç½®ç›®æ ‡åƒç´ 
                    const i = (y * width + x) * 4;
                    dstData.data[i] = newPixel;
                    dstData.data[i + 1] = newPixel;
                    dstData.data[i + 2] = newPixel;
                    dstData.data[i + 3] = 255;
                }
            }
        }

        let generatedImageBinFilename = null;
        let generatedImageBinData = null;

        /**
         * è½¬æ¢å›¾ç‰‡ä¸º .bin æ–‡ä»¶æ ¼å¼
         */
        async function convertImageToBin() {
            if (!currentImageFile) {
                alert('è¯·å…ˆä¸Šä¼ å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }

            if (!dstImageCanvas) {
                alert('è¯·å…ˆé¢„è§ˆå¤„ç†æ•ˆæœï¼');
                return;
            }

            const width = parseInt(document.getElementById('imageWidth').value);
            const height = parseInt(document.getElementById('imageHeight').value);
            const mode = document.getElementById('imageMode').value;
            const threshold = parseInt(document.getElementById('imageThreshold').value);
            const imageName = currentImageFile.name.replace(/\.(jpg|jpeg|png|bmp|gif)$/i, '').replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
            
            const statusDiv = document.getElementById('imageBinStatus');
            statusDiv.innerHTML = 
                `<div style="color: #ff9800; font-weight: bold;">â³ æ­£åœ¨ç”Ÿæˆ ${width}x${height} .bin æ–‡ä»¶...</div>`;
            
            // éšè—æ·»åŠ æŒ‰é’®ï¼ˆç¨åç”ŸæˆæˆåŠŸåæ˜¾ç¤ºï¼‰
            document.getElementById('addBitmapBtn').style.display = 'none';

            try {
                // è¯»å–å›¾ç‰‡æ–‡ä»¶ä¸º base64
                const reader = new FileReader();
                reader.onload = async function(e) {
                    const imageBase64 = e.target.result.split(',')[1];

                    const startTime = Date.now();

                    // è°ƒç”¨ Python åç«¯ API
                    const response = await fetchWithFallbackForPython('/convert_image_to_bin', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            image_base64: imageBase64,
                            width: width,
                            height: height,
                            mode: mode,
                            threshold: threshold,
                            image_name: imageName
                        }),
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);

                    if (result.success) {
                        generatedImageBinFilename = result.filename;
                        
                        // è·å–ç”Ÿæˆçš„ .bin æ–‡ä»¶æ•°æ®ç”¨äºåç»­ä¸Šä¼ 
                        const binResponse = await fetchWithFallbackForPython(`/download_bin_file?filename=${encodeURIComponent(result.filename)}`);
                        generatedImageBinData = await binResponse.blob();
                        
                        // ä»æ–‡ä»¶åä¸­æå–ä½å›¾å°ºå¯¸ï¼ˆæ ¼å¼: {name}_{width}x{height}.binï¼‰
                        const bitmapIndex = extractBitmapIndexFromFileName(result.filename);
                        window.generatedBitmapIndex = bitmapIndex;
                        
                        statusDiv.innerHTML = 
                            `<div style="color: green; font-weight: bold; margin-bottom: 10px;">âœ… .bin æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼(è€—æ—¶ ${elapsedTime}ç§’)</div>` +
                            `<div style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-size: 11px;">` +
                            `<strong>ğŸ“‹ æ–‡ä»¶ä¿¡æ¯:</strong><br>` +
                            `â€¢ æ–‡ä»¶å: <span style="color: #0066cc; font-family: monospace;">${result.filename}</span><br>` +
                            `â€¢ æ–‡ä»¶å¤§å°: <strong>${result.file_size_kb} KB</strong><br>` +
                            `â€¢ å›¾ç‰‡å°ºå¯¸: ${result.width}x${result.height}<br>` +
                            `â€¢ å¤„ç†æ¨¡å¼: ${mode === 'dithering' ? 'Floyd-Steinberg æŠ–åŠ¨' : 'é˜ˆå€¼äºŒå€¼åŒ–'}<br>` +
                            `<br><strong>ğŸ’¾ æœ¬åœ°è·¯å¾„:</strong><br>` +
                            `<span style="color: #0066cc; font-family: monospace; font-size: 10px; word-break: break-all;">${result.saved_path}</span><br>` +
                            `<br><span style="color: #4CAF50;">âœ… æ­¤æ–‡ä»¶å¯ç›´æ¥ç”¨äºå¢¨æ°´å±å›¾ç‰‡æ˜¾ç¤º</span>` +
                            `</div>`;
                        
                        // æ˜¾ç¤ºæ·»åŠ æŒ‰é’®
                        document.getElementById('addBitmapBtn').style.display = 'inline-block';
                    } else {
                        throw new Error(result.error || 'ç”Ÿæˆå¤±è´¥');
                    }
                };

                reader.onerror = function() {
                    statusDiv.innerHTML = `<div style="color: red;">âŒ è¯»å–å›¾ç‰‡æ–‡ä»¶å¤±è´¥</div>`;
                };

                reader.readAsDataURL(currentImageFile);

            } catch (error) {
                console.error('.bin æ–‡ä»¶ç”Ÿæˆå¤±è´¥:', error);
                statusDiv.innerHTML = 
                    `<div style="color: red; font-weight: bold;">âŒ ç”Ÿæˆå¤±è´¥: ${error.message}</div>` +
                    `<div style="color: orange; margin-top: 5px;">è¯·ç¡®ä¿ Python æœåŠ¡å·²å¯åŠ¨: python tools/ttf_to_gfx_webservice.py</div>`;
            }
        }

        /**
         * ä¸‹è½½ç”Ÿæˆçš„å›¾ç‰‡ .bin æ–‡ä»¶
         */
        async function downloadImageBin() {
            if (!generatedImageBinFilename) {
                alert('è¯·å…ˆç”Ÿæˆ .bin æ–‡ä»¶ï¼');
                return;
            }

            try {
                // ä»æœåŠ¡å™¨ä¸‹è½½æ–‡ä»¶
                const response = await fetchWithFallbackForPython(`/download_bin_file?filename=${encodeURIComponent(generatedImageBinFilename)}`);
                
                if (!response.ok) {
                    throw new Error('ä¸‹è½½å¤±è´¥');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = generatedImageBinFilename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                const statusDiv = document.getElementById('imageBinStatus');
                const currentContent = statusDiv.innerHTML;
                statusDiv.innerHTML = currentContent + 
                    `<div style="color: green; margin-top: 10px;">ğŸ’¾ æ–‡ä»¶å·²ä¸‹è½½åˆ°æµè§ˆå™¨é»˜è®¤ä¸‹è½½ç›®å½•</div>`;

            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                alert('ä¸‹è½½å¤±è´¥: ' + error.message);
            }
        }

        /**
         * ä¸Šä¼ å›¾ç‰‡ .bin æ–‡ä»¶åˆ° SD å¡
         */
        async function uploadImageBinToSD() {
            if (!generatedImageBinFilename || !generatedImageBinData) {
                alert('è¯·å…ˆç”Ÿæˆ .bin æ–‡ä»¶ï¼');
                return;
            }

            const statusDiv = document.getElementById('imageBinStatus');
            const originalContent = statusDiv.innerHTML;
            
            try {
                statusDiv.innerHTML = originalContent + 
                    `<div style="color: #ff9800; margin-top: 10px;">â³ æ­£åœ¨ä¸Šä¼ åˆ° SD å¡...</div>`;

                // åˆ›å»º File å¯¹è±¡
                const file = new File([generatedImageBinData], generatedImageBinFilename, {
                    type: 'application/octet-stream'
                });

                // ä¸Šä¼ åˆ° SD å¡æ ¹ç›®å½•
                await uploadFileToSD(file, '/');

                statusDiv.innerHTML = originalContent + 
                    `<div style="color: green; margin-top: 10px; font-weight: bold;">âœ… å·²æˆåŠŸä¸Šä¼ åˆ° SD å¡: /${generatedImageBinFilename}</div>` +
                    `<div style="color: #666; font-size: 11px;">å¯ä»¥åœ¨ ESP32 ä»£ç ä¸­ä½¿ç”¨: displayImageFromSD("/sd/${generatedImageBinFilename}", x, y, display);</div>`;

            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                statusDiv.innerHTML = originalContent + 
                    `<div style="color: red; margin-top: 10px;">âŒ ä¸Šä¼ å¤±è´¥: ${error.message}</div>` +
                    `<div style="color: orange; font-size: 11px;">è¯·æ£€æŸ¥ ESP32 è¿æ¥å’Œ SD å¡çŠ¶æ€</div>`;
            }
        }

        /**
         * ä¸Šä¼ æ–‡ä»¶åˆ° ESP32 SD å¡çš„é€šç”¨å‡½æ•°
         * @param {File} file - è¦ä¸Šä¼ çš„æ–‡ä»¶å¯¹è±¡
         * @param {string} path - SDå¡ä¸Šçš„ç›®æ ‡è·¯å¾„ï¼ˆé»˜è®¤ä¸ºæ ¹ç›®å½• '/'ï¼‰
         */
        async function uploadFileToSD(file, path = '/') {
            return new Promise((resolve, reject) => {
                // æ„å»º FormDataï¼ˆæ¨¡ä»¿ index.html çš„æ–¹å¼ï¼‰
                const formData = new FormData();
                formData.append('path', path);
                formData.append('size', file.size);
                formData.append('file', file, file.name);
                
                // åˆ›å»º XMLHttpRequest
                const xhr = new XMLHttpRequest();
                
                // è¿›åº¦ç›‘å¬
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentComplete = (e.loaded / e.total) * 100;
                        console.log(`ä¸Šä¼ è¿›åº¦: ${percentComplete.toFixed(2)}%`);
                    }
                });
                
                // å®Œæˆç›‘å¬
                xhr.onload = function() {
                    if (xhr.status === 200) {
                        console.log('ä¸Šä¼ æˆåŠŸ:', xhr.responseText);
                        resolve(xhr.responseText);
                    } else {
                        reject(new Error(`ä¸Šä¼ å¤±è´¥: HTTP ${xhr.status}`));
                    }
                };
                
                // é”™è¯¯ç›‘å¬
                xhr.onerror = function() {
                    reject(new Error('ç½‘ç»œé”™è¯¯'));
                };
                
                // ä½¿ç”¨ CONFIG å¯¹è±¡è·å– ESP32 æœåŠ¡åœ°å€
                const uploadUrl = CONFIG.esp32Url('/upload');
                console.log('ä½¿ç”¨ä¸Šä¼ åœ°å€:', uploadUrl);
                
                // å‘é€è¯·æ±‚åˆ° ESP32 çš„ /upload æ¥å£
                xhr.open('POST', uploadUrl, true);
                xhr.send(formData);
            });
        }

        /**
         * æœç´¢å­—ä½“åº“
         */
        async function searchFontLibrary() {
            try {
                const response = await fetchWithFallbackForPython('/list_fonts');
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error);
                }

                const listDiv = document.getElementById('fontLibraryList');
                
                if (result.fonts.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">æš‚æ— å­—ä½“æ–‡ä»¶</p>';
                    return;
                }

                let html = `<p style="font-size: 12px; color: #666;">æ‰¾åˆ° ${result.count} ä¸ªå­—ä½“æ–‡ä»¶:</p>`;
                html += '<div style="max-height: 250px; overflow-y: auto;">';
                
                result.fonts.forEach(font => {
                    html += `
                        <div style="background: #f9f9f9; padding: 8px; margin: 5px 0; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${font.name}</strong>
                                <br><small style="color: #666;">${font.size_kb} KB</small>
                            </div>
                            <div>
                                <button class="btn btn-success" style="padding: 5px 10px; font-size: 12px;" onclick="importFont('${font.name}')">
                                    ğŸ“¤ å¯¼å…¥
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                listDiv.innerHTML = html;
                
            } catch (error) {
                console.error('æŸ¥è¯¢å­—ä½“åº“å¤±è´¥:', error);
                document.getElementById('fontLibraryList').innerHTML = 
                    `<p style="color: red;">âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}</p>` +
                    `<p style="color: orange;">è¯·ç¡®ä¿ Python æœåŠ¡å·²å¯åŠ¨</p>`;
            }
        }

        /**
         * å¯¼å…¥å­—ä½“åˆ° SD å¡æ ¹ç›®å½•
         */
        async function importFont(fontName) {
            if (!confirm(`ç¡®è®¤ä¸Šä¼ å­—ä½“åˆ° SD å¡æ ¹ç›®å½•: ${fontName}?`)) {
                return;
            }
            
            try {
                // ä» components/resource/fonts è¯»å–æ–‡ä»¶
                const response = await fetchWithFallbackForPython(`/get_font_file?filename=${encodeURIComponent(fontName)}`);
                if (!response.ok) {
                    throw new Error('è·å–å­—ä½“æ–‡ä»¶å¤±è´¥');
                }
                
                const blob = await response.blob();
                const file = new File([blob], fontName, { type: 'application/octet-stream' });
                
                // ä¸Šä¼ åˆ° ESP32 SD å¡æ ¹ç›®å½•
                await uploadFileToSD(file, '/');
                
                alert(`âœ… å­—ä½“ ${fontName} å·²æˆåŠŸä¸Šä¼ åˆ° SD å¡æ ¹ç›®å½•ï¼`);
                
            } catch (error) {
                console.error('ä¸Šä¼ å­—ä½“å¤±è´¥:', error);
                alert(`âŒ ä¸Šä¼ å¤±è´¥: ${error.message}\n\nè¯·ç¡®ä¿:\n1. Python æœåŠ¡å·²å¯åŠ¨\n2. ESP32 å·²è¿æ¥\n3. SD å¡å·²æ’å…¥`);
            }
        }

        /**
         * æœç´¢å›¾ç‰‡åº“
         */
        async function searchBitmapLibrary() {
            try {
                const response = await fetchWithFallbackForPython('/list_bitmaps');
                const result = await response.json();
                
                if (!result.success) {
                    throw new Error(result.error);
                }

                const listDiv = document.getElementById('bitmapLibraryList');
                
                if (result.bitmaps.length === 0) {
                    listDiv.innerHTML = '<p style="color: #666;">æš‚æ— ä½å›¾æ–‡ä»¶</p>';
                    return;
                }

                let html = `<p style="font-size: 12px; color: #666;">æ‰¾åˆ° ${result.count} ä¸ªä½å›¾æ–‡ä»¶:</p>`;
                html += '<div style="max-height: 350px; overflow-y: auto;">';
                
                result.bitmaps.forEach(bitmap => {
                    const sizeInfo = bitmap.width && bitmap.height ? 
                        `${bitmap.width}x${bitmap.height}` : 'æœªçŸ¥å°ºå¯¸';
                    
                    html += `
                        <div style="background: #f9f9f9; padding: 8px; margin: 5px 0; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${bitmap.name}</strong>
                                    <br><small style="color: #666;">${sizeInfo} Â· ${bitmap.size_kb} KB</small>
                                </div>
                                <div>
                                    <button class="btn btn-success" style="padding: 5px 10px; font-size: 12px;" onclick="importBitmap('${bitmap.name}')">
                                        ğŸ“¤ å¯¼å…¥
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                listDiv.innerHTML = html;
                
            } catch (error) {
                console.error('æŸ¥è¯¢å›¾ç‰‡åº“å¤±è´¥:', error);
                document.getElementById('bitmapLibraryList').innerHTML = 
                    `<p style="color: red;">âŒ æŸ¥è¯¢å¤±è´¥: ${error.message}</p>` +
                    `<p style="color: orange;">è¯·ç¡®ä¿ Python æœåŠ¡å·²å¯åŠ¨</p>`;
            }
        }

        /**
         * å¯¼å…¥ä½å›¾åˆ° SD å¡æ ¹ç›®å½•
         */
        async function importBitmap(bitmapName) {
            if (!confirm(`ç¡®è®¤ä¸Šä¼ ä½å›¾åˆ° SD å¡æ ¹ç›®å½•: ${bitmapName}?`)) {
                return;
            }
            
            try {
                // ä» components/resource/bitmap è¯»å–æ–‡ä»¶
                const response = await fetchWithFallbackForPython(`/get_bitmap_file?filename=${encodeURIComponent(bitmapName)}`);
                if (!response.ok) {
                    throw new Error('è·å–ä½å›¾æ–‡ä»¶å¤±è´¥');
                }
                
                const blob = await response.blob();
                const file = new File([blob], bitmapName, { type: 'application/octet-stream' });
                
                // ä¸Šä¼ åˆ° ESP32 SD å¡æ ¹ç›®å½•
                await uploadFileToSD(file, '/');
                
                alert(`âœ… ä½å›¾ ${bitmapName} å·²æˆåŠŸä¸Šä¼ åˆ° SD å¡æ ¹ç›®å½•ï¼`);
                
            } catch (error) {
                console.error('ä¸Šä¼ ä½å›¾å¤±è´¥:', error);
                alert(`âŒ ä¸Šä¼ å¤±è´¥: ${error.message}\n\nè¯·ç¡®ä¿:\n1. Python æœåŠ¡å·²å¯åŠ¨\n2. ESP32 å·²è¿æ¥\n3. SD å¡å·²æ’å…¥`);
            }
        }

        // ==================== SD å¡æ–‡ä»¶ç®¡ç†åŠŸèƒ½ ====================
        
        let sdFilesData = []; // å­˜å‚¨æ–‡ä»¶åˆ—è¡¨æ•°æ®
        
        /**
         * åˆ·æ–° SD å¡æ–‡ä»¶åˆ—è¡¨
         */
        async function refreshSDFiles() {
            try {
                const response = await fetchWithFallback('/files?path=/', '/files?path=/');
                if (!response.ok) {
                    throw new Error('è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥');
                }
                
                const data = await response.json();
                console.log('SDå¡æ–‡ä»¶æ•°æ®:', data);
                
                // ä¿å­˜æ–‡ä»¶æ•°æ®ï¼ˆåªä¿å­˜æ–‡ä»¶ï¼Œä¸åŒ…å«ç›®å½•ï¼‰
                sdFilesData = data.files.filter(file => file.size !== '-1');
                
                // æ˜¾ç¤º SD å¡ä¿¡æ¯
                displaySDCardInfo(data);
                
                // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
                displaySDFilesList(sdFilesData);
                
            } catch (error) {
                console.error('åˆ·æ–°æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                document.getElementById('sdFilesList').innerHTML = 
                    `<div style="padding: 20px; text-align: center; color: red;">
                        âŒ åŠ è½½å¤±è´¥: ${error.message}<br>
                        <small>è¯·ç¡®ä¿ ESP32 å·²è¿æ¥ä¸” SD å¡å·²æ’å…¥</small>
                    </div>`;
            }
        }
        
        /**
         * æ˜¾ç¤º SD å¡ä¿¡æ¯
         */
        function displaySDCardInfo(data) {
            const infoDiv = document.getElementById('sdCardInfo');
            infoDiv.innerHTML = `
                <strong>ğŸ“Š SD å¡çŠ¶æ€:</strong> ${data.status}<br>
                <strong>ğŸ’¾ æ€»å®¹é‡:</strong> ${data.total}<br>
                <strong>ğŸ“ å·²ä½¿ç”¨:</strong> ${data.used} (${data.occupation}%)
            `;
        }
        
        /**
         * æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
         */
        function displaySDFilesList(files) {
            const listDiv = document.getElementById('sdFilesList');
            
            if (files.length === 0) {
                listDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += `
                <thead>
                    <tr style="background: #f5f5f5;">
                        <th style="padding: 8px; border: 1px solid #ddd; width: 40px;">é€‰æ‹©</th>
                        <th style="padding: 8px; border: 1px solid #ddd; text-align: left;">æ–‡ä»¶å</th>
                        <th style="padding: 8px; border: 1px solid #ddd; width: 100px;">å¤§å°</th>
                        <th style="padding: 8px; border: 1px solid #ddd; width: 80px;">æ“ä½œ</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            files.forEach((file, index) => {
                html += `
                    <tr style="border-bottom: 1px solid #eee;">
                        <td style="padding: 8px; text-align: center;">
                            <input type="checkbox" class="file-checkbox" data-index="${index}" data-filename="${file.name}">
                        </td>
                        <td style="padding: 8px;">
                            <span style="font-family: monospace;">${file.name}</span>
                        </td>
                        <td style="padding: 8px; text-align: right;">
                            ${file.size}
                        </td>
                        <td style="padding: 8px; text-align: center;">
                            <button class="btn btn-danger" style="padding: 3px 8px; font-size: 11px;" 
                                    onclick="deleteSingleFile('${file.name}')">
                                åˆ é™¤
                            </button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            listDiv.innerHTML = html;
        }
        
        /**
         * å…¨é€‰/å–æ¶ˆå…¨é€‰
         */
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const fileCheckboxes = document.querySelectorAll('.file-checkbox');
            
            fileCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
        }
        
        /**
         * åˆ é™¤å•ä¸ªæ–‡ä»¶
         */
        async function deleteSingleFile(filename) {
            if (!confirm(`ç¡®è®¤åˆ é™¤æ–‡ä»¶: ${filename}?`)) {
                return;
            }
            
            try {
                const deleteCmd = `/command?commandText=$SD/Delete=${encodeURIComponent(filename)}`;
                const response = await fetchWithFallback(deleteCmd, deleteCmd);
                if (!response.ok) {
                    throw new Error('åˆ é™¤è¯·æ±‚å¤±è´¥');
                }
                
                const result = await response.text();
                console.log('åˆ é™¤ç»“æœ:', result);
                
                alert(`âœ… æ–‡ä»¶ ${filename} åˆ é™¤æˆåŠŸï¼`);
                
                // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                await refreshSDFiles();
                
            } catch (error) {
                console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
                alert(`âŒ åˆ é™¤å¤±è´¥: ${error.message}`);
            }
        }
        
        /**
         * æ‰¹é‡åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶
         */
        async function deleteSelectedFiles() {
            const checkedBoxes = document.querySelectorAll('.file-checkbox:checked');
            
            if (checkedBoxes.length === 0) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶ï¼');
                return;
            }
            
            if (!confirm(`ç¡®è®¤åˆ é™¤é€‰ä¸­çš„ ${checkedBoxes.length} ä¸ªæ–‡ä»¶?`)) {
                return;
            }
            
            // è·å–é€‰ä¸­æ–‡ä»¶çš„ç´¢å¼•
            const indices = Array.from(checkedBoxes).map(checkbox => checkbox.dataset.index);
            const indexStr = indices.join(',');
            
            try {
                const batchCmd = `/command?commandText=$SD/BatchDelete=${indexStr}`;
                const response = await fetchWithFallback(batchCmd, batchCmd);
                if (!response.ok) {
                    throw new Error('æ‰¹é‡åˆ é™¤è¯·æ±‚å¤±è´¥');
                }
                
                const result = await response.text();
                console.log('æ‰¹é‡åˆ é™¤ç»“æœ:', result);
                
                alert(`âœ… æ‰¹é‡åˆ é™¤å®Œæˆï¼`);
                
                // å–æ¶ˆå…¨é€‰
                document.getElementById('selectAllCheckbox').checked = false;
                
                // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                await refreshSDFiles();
                
            } catch (error) {
                console.error('æ‰¹é‡åˆ é™¤å¤±è´¥:', error);
                alert(`âŒ æ‰¹é‡åˆ é™¤å¤±è´¥: ${error.message}`);
            }
        }
        
        /**
         * åˆ é™¤æ‰€æœ‰æ–‡ä»¶
         */
        async function deleteAllFiles() {
            if (sdFilesData.length === 0) {
                alert('å½“å‰æ²¡æœ‰æ–‡ä»¶å¯ä»¥åˆ é™¤ï¼');
                return;
            }
            
            if (!confirm(`âš ï¸ è­¦å‘Šï¼\n\nç¡®è®¤åˆ é™¤ SD å¡ä¸­çš„æ‰€æœ‰ ${sdFilesData.length} ä¸ªæ–‡ä»¶?\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
                return;
            }
            
            // äºŒæ¬¡ç¡®è®¤
            if (!confirm('è¯·å†æ¬¡ç¡®è®¤ï¼šçœŸçš„è¦åˆ é™¤æ‰€æœ‰æ–‡ä»¶å—ï¼Ÿ')) {
                return;
            }
            
            try {
                const allDelCmd = '/command?commandText=$SD/AllDelete';
                const response = await fetchWithFallback(allDelCmd, allDelCmd);
                if (!response.ok) {
                    throw new Error('å…¨éƒ¨åˆ é™¤è¯·æ±‚å¤±è´¥');
                }
                
                const result = await response.text();
                console.log('å…¨éƒ¨åˆ é™¤ç»“æœ:', result);
                
                alert(`âœ… æ‰€æœ‰æ–‡ä»¶å·²åˆ é™¤ï¼`);
                
                // å–æ¶ˆå…¨é€‰
                document.getElementById('selectAllCheckbox').checked = false;
                
                // åˆ·æ–°æ–‡ä»¶åˆ—è¡¨
                await refreshSDFiles();
                
            } catch (error) {
                console.error('å…¨éƒ¨åˆ é™¤å¤±è´¥:', error);
                alert(`âŒ å…¨éƒ¨åˆ é™¤å¤±è´¥: ${error.message}`);
            }
        }

        /**
         * æ›´æ–°å­—ç¬¦é›†ä¿¡æ¯æ˜¾ç¤º
         */
        function updateCharsetInfo() {
            const charsetRange = document.getElementById('charsetRange').value;
            const charsetInfo = document.getElementById('charsetInfo');
            
            if (charsetRange === 'english') {
                charsetInfo.innerHTML = 'è‹±æ–‡ASCIIå­—ç¬¦ï¼ŒåŒ…å«ç©ºæ ¼ã€å­—æ¯ã€æ•°å­—å’Œå¸¸ç”¨ç¬¦å·ã€‚ç”Ÿæˆé€Ÿåº¦å¿«ï¼Œæ–‡ä»¶å°ã€‚';
            } else {
                charsetInfo.innerHTML = 'ä¸­æ–‡GB2312æ±‰å­—ï¼Œçº¦20000ä¸ªå¸¸ç”¨æ±‰å­—ã€‚ç”Ÿæˆé€Ÿåº¦è¾ƒæ…¢ï¼Œæ–‡ä»¶è¾ƒå¤§ã€‚';
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–å­—ç¬¦é›†ä¿¡æ¯
        document.addEventListener('DOMContentLoaded', function() {
            updateCharsetInfo();
        });

        /**
         * ä»å›¾ç‰‡æ–‡ä»¶åä¸­æå–ä½å›¾ç´¢å¼•
         * æ–‡ä»¶åæ ¼å¼: {name}_{width}x{height}.bin ä¾‹å¦‚: image1_416x240.bin
         */
        function extractBitmapIndexFromFileName(fileName) {
            // ç§»é™¤ .bin æ‰©å±•å
            const nameWithoutExt = fileName.replace(/\.bin$/i, '');
            
            // æŸ¥æ‰¾æœ€åä¸€ä¸ªæ•°å­—åºåˆ—ä½œä¸ºç´¢å¼•
            // æ ¼å¼: {name}_{width}x{height}
            // æˆ‘ä»¬å°è¯•ä»å®½åº¦æ•°å­—ä¸­æå–
            const match = nameWithoutExt.match(/(\d+)x(\d+)$/);
            if (match) {
                const width = parseInt(match[1], 10);
                const height = parseInt(match[2], 10);
                // è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…å«å®½åº¦å’Œé«˜åº¦ä»¥ä¾›åç»­ä½¿ç”¨
                window.generatedBitmapWidth = width;
                window.generatedBitmapHeight = height;
                return 0;  // ä½å›¾ç´¢å¼•é»˜è®¤ä¸º 0ï¼ˆå¦‚æ— ç‰¹æ®Šéœ€æ±‚ï¼‰
            }
            
            return -1;  // æ— æ•ˆçš„æ ¼å¼
        }

        /**
         * æ·»åŠ ç”Ÿæˆçš„ä½å›¾åˆ°é€‰ä¸­çš„çŸ©å½¢ - åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°å’ŒSDå¡
         */
        function addBitmapToSelectedRect() {
            if (selectedRectIndex < 0 || selectedRectIndex >= currentLayout.rectangles.length) {
                showStatus('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªçŸ©å½¢', 'error');
                return;
            }

            // å¦‚æœè¿˜æ²¡æœ‰é€‰æ‹©æ–‡ä»¶ï¼Œæ‰“å¼€æ–‡ä»¶é€‰æ‹©å™¨
            if (!generatedImageBinFilename || !generatedImageBinData) {
                // å…ˆæ£€æŸ¥æ˜¯å¦å·²ç”Ÿæˆäº† .bin æ–‡ä»¶
                const statusDiv = document.getElementById('imageBinStatus');
                if (!statusDiv || !statusDiv.innerHTML.includes('âœ…')) {
                    showStatus('è¯·å…ˆè½¬æ¢å›¾ç‰‡ç”Ÿæˆ .bin æ–‡ä»¶ï¼Œç„¶åç‚¹å‡»"æ·»åŠ å›¾ç‰‡åˆ°é€‰ä¸­çŸ©å½¢"æŒ‰é’®', 'info');
                    return;
                }
                
                // å¦‚æœå·²ç”Ÿæˆä½†æœªåŠ è½½åˆ°å†…å­˜ï¼Œåˆ™è§¦å‘æ–‡ä»¶é€‰æ‹©
                document.getElementById('bitmapFileInput').click();
                return;
            }

            const bitmapWidth = window.generatedBitmapWidth || 416;
            const bitmapHeight = window.generatedBitmapHeight || 240;
            const bitmapFilename = generatedImageBinFilename;
            const bitmapData = generatedImageBinData;

            // è·å–çŸ©å½¢å¯¹è±¡
            const rect = currentLayout.rectangles[selectedRectIndex];

            // åˆ›å»ºä½å›¾å¯¹è±¡
            const bitmap = {
                filename: bitmapFilename,
                width: bitmapWidth,
                height: bitmapHeight,
                display_width: Math.min(bitmapWidth, rect.width * 0.8),  // é»˜è®¤æ˜¾ç¤ºå®½åº¦
                display_height: Math.min(bitmapHeight, rect.height * 0.8),  // é»˜è®¤æ˜¾ç¤ºé«˜åº¦
                rel_x: 0.5,  // ç›¸å¯¹ä½ç½® (ä¸­å¿ƒ)
                rel_y: 0.5,  // ç›¸å¯¹ä½ç½® (ä¸­å¿ƒ)
                bitmapData: bitmapData  // ä¿å­˜ä½å›¾äºŒè¿›åˆ¶æ•°æ®
            };

            // æ·»åŠ ä½å›¾åˆ°çŸ©å½¢
            if (!rect.bitmap) {
                rect.bitmap = bitmap;
            } else {
                // å¦‚æœå·²æœ‰ä½å›¾ï¼Œåˆ™æ›¿æ¢
                rect.bitmap = bitmap;
            }

            // è°ƒè¯•ï¼šæ£€æŸ¥ä½å›¾æ•°æ®æ˜¯å¦æ­£ç¡®ä¿å­˜
            console.log(`âœ“ ä½å›¾å·²æ·»åŠ åˆ°çŸ©å½¢ ${selectedRectIndex}`);
            console.log(`  - æ–‡ä»¶å: ${bitmap.filename}`);
            console.log(`  - å°ºå¯¸: ${bitmap.width}x${bitmap.height}`);
            console.log(`  - æ˜¾ç¤ºå°ºå¯¸: ${bitmap.display_width}x${bitmap.display_height}`);
            console.log(`  - ä½ç½®: (${bitmap.rel_x}, ${bitmap.rel_y})`);
            console.log(`  - æ•°æ®ç±»å‹: ${bitmap.bitmapData.constructor.name}`);
            console.log(`  - æ•°æ®å¤§å°: ${bitmap.bitmapData.size || bitmap.bitmapData.length || 'unknown'}`);
            console.log(`  - çŸ©å½¢å¯¹è±¡å†…çš„ä½å›¾: `, rect.bitmap);

            // é‡æ–°æ¸²æŸ“å¸ƒå±€
            renderLayout(currentLayout);

            // æ˜¾ç¤ºå¤„ç†çŠ¶æ€
            const statusDiv = document.getElementById('imageBinStatus');
            statusDiv.innerHTML += `<div style="color: #ff9800; margin-top: 10px; font-weight: bold;">â³ ä½å›¾å·²æ·»åŠ åˆ°çŸ©å½¢ï¼Œæ­£åœ¨ä¿å­˜åˆ°æœ¬åœ°å’Œ SD å¡...</div>`;

            // åŒæ—¶ä¿å­˜åˆ°æœ¬åœ°å’Œ SD å¡
            Promise.all([
                saveBitmapToLocal(bitmapFilename, bitmapData),
                autoUploadBitmapToSD(bitmapFilename, bitmapData)
            ]).then(() => {
                statusDiv.innerHTML += 
                    `<div style="color: green; font-weight: bold; margin-top: 10px;">âœ… ä½å›¾å·²ä¿å­˜åˆ°æœ¬åœ°å’Œ SD å¡ï¼</div>` +
                    `<div style="color: #666; font-size: 11px;">æœ¬åœ°: components/resource/bitmap/${bitmapFilename}</div>` +
                    `<div style="color: #666; font-size: 11px;">SDå¡: /${bitmapFilename}</div>`;
                
                // æ¸…é™¤æ–‡ä»¶é€‰æ‹©ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡
                generatedImageBinFilename = null;
                generatedImageBinData = null;
                window.generatedBitmapWidth = null;
                window.generatedBitmapHeight = null;
                document.getElementById('bitmapFileInput').value = '';
                document.getElementById('addBitmapBtn').style.display = 'none';
            }).catch((error) => {
                console.error('ä¿å­˜ä½å›¾æ—¶å‡ºé”™:', error);
                statusDiv.innerHTML += 
                    `<div style="color: orange; margin-top: 10px;">âš ï¸ ä½å›¾å·²æ·»åŠ åˆ°å¸ƒå±€ï¼Œä½†ä¿å­˜è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: ${error.message}</div>`;
            });
        }

        /**
         * ä¿å­˜ä½å›¾åˆ°æœ¬åœ°èµ„æºç›®å½•
         */
        async function saveBitmapToLocal(filename, data) {
            try {
                const file = new File([data], filename, { type: 'application/octet-stream' });
                
                // è°ƒç”¨ Python æœåŠ¡ä¿å­˜åˆ° components/resource/bitmap ç›®å½•
                const formData = new FormData();
                formData.append('file', file);
                formData.append('filename', filename);
                
                const response = await fetchWithFallbackForPython('/save_bitmap_file', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('ä¿å­˜åˆ°æœ¬åœ°å¤±è´¥');
                }
                
                const result = await response.json();
                if (!result.success) {
                    throw new Error(result.error || 'ä¿å­˜å¤±è´¥');
                }
                
                console.log('ä½å›¾å·²ä¿å­˜åˆ°æœ¬åœ°:', result.saved_path);
                return result;
                
            } catch (error) {
                console.error('ä¿å­˜ä½å›¾åˆ°æœ¬åœ°å¤±è´¥:', error);
                throw error;
            }
        }

        /**
         * è‡ªåŠ¨ä¸Šä¼ ä½å›¾æ–‡ä»¶åˆ° SD å¡ - ä½¿ç”¨ /upload æ¥å£
         */
        async function autoUploadBitmapToSD(filename, data) {
            try {
                const file = new File([data], filename, { type: 'application/octet-stream' });
                
                // ä½¿ç”¨ uploadFileToSD å‡½æ•°ï¼Œé€šè¿‡ /upload æ¥å£ä¸Šä¼ åˆ° SD å¡æ ¹ç›®å½•
                await uploadFileToSD(file, '/');
                
                console.log('ä½å›¾å·²è‡ªåŠ¨ä¸Šä¼ åˆ° SD å¡:', filename);

            } catch (error) {
                console.error('è‡ªåŠ¨ä¸Šä¼ ä½å›¾æ–‡ä»¶å¤±è´¥:', error);
                throw error;
            }
        }

    </script>
</body>

</html>