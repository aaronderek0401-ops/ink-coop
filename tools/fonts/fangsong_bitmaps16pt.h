// Font Bitmaps: fangsong_bitmaps 16pt
// Generated by generate_bitmap_arrays.py
// Characters: 测试文字
// 每个字符一个独立的位图数组

#ifndef _FANGSONG_BITMAPS_16PT_H_
#define _FANGSONG_BITMAPS_16PT_H_

#include <Arduino.h>

// '测' (U+6D4B) - 16x16
const uint8_t BITMAP_6D4B[] PROGMEM = {
    0x00, 0x04, 0x21, 0xC4, 0x16, 0x44, 0x04, 0x54, 0x05, 0x54, 0x45, 0x54, 0x25, 0x54, 0x15, 0x54, 
    0x15, 0x54, 0x25, 0x54, 0x22, 0x84, 0xC2, 0x44, 0x44, 0x54, 0x08, 0x0C, 0x10, 0x04, 0x00, 0x00
};

// '试' (U+8BD5) - 16x16
const uint8_t BITMAP_8BD5[] PROGMEM = {
    0x00, 0x40, 0x20, 0x50, 0x10, 0x48, 0x10, 0x40, 0x00, 0x78, 0x07, 0xC0, 0x70, 0x40, 0x10, 0xC0, 
    0x17, 0x40, 0x11, 0x20, 0x11, 0x20, 0x15, 0x54, 0x19, 0x94, 0x16, 0x0C, 0x00, 0x04, 0x00, 0x00
};

// '文' (U+6587) - 16x16
const uint8_t BITMAP_6587[] PROGMEM = {
    0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x38, 0x3F, 0xC0, 0x00, 0x40, 0x04, 0x40, 0x02, 0x80, 
    0x02, 0x80, 0x01, 0x00, 0x01, 0x00, 0x02, 0x80, 0x0C, 0x40, 0x30, 0x30, 0xC0, 0x0E, 0x00, 0x00
};

// '字' (U+5B57) - 16x16
const uint8_t BITMAP_5B57[] PROGMEM = {
    0x02, 0x00, 0x01, 0x00, 0x01, 0xFC, 0x3E, 0x08, 0x21, 0xE0, 0x0E, 0x40, 0x00, 0x80, 0x01, 0x00, 
    0x00, 0xFC, 0x7F, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x02, 0x80, 0x01, 0x00, 0x00, 0x00
};

// 绘制函数模板（支持任意 GxEPD2 显示器类型）
template<typename T>
inline void drawFangsongBitmaps(T& display, int16_t x, int16_t y, uint16_t scale = 1) {
    // '测'
    for (uint16_t s_y = 0; s_y < 16 * scale; s_y++) {
        for (uint16_t s_x = 0; s_x < 16 * scale; s_x++) {
            uint16_t src_x = s_x / scale;
            uint16_t src_y = s_y / scale;
            uint16_t byte_index = src_y * ((16 + 7) / 8) + src_x / 8;
            uint8_t bit_mask = 0x80 >> (src_x % 8);
            if (pgm_read_byte(&BITMAP_6D4B[byte_index]) & bit_mask) {
                display.drawPixel(x + 0 * scale + s_x, y + s_y, GxEPD_BLACK);
            }
        }
    }

    // '试'
    for (uint16_t s_y = 0; s_y < 16 * scale; s_y++) {
        for (uint16_t s_x = 0; s_x < 16 * scale; s_x++) {
            uint16_t src_x = s_x / scale;
            uint16_t src_y = s_y / scale;
            uint16_t byte_index = src_y * ((16 + 7) / 8) + src_x / 8;
            uint8_t bit_mask = 0x80 >> (src_x % 8);
            if (pgm_read_byte(&BITMAP_8BD5[byte_index]) & bit_mask) {
                display.drawPixel(x + 17 * scale + s_x, y + s_y, GxEPD_BLACK);
            }
        }
    }

    // '文'
    for (uint16_t s_y = 0; s_y < 16 * scale; s_y++) {
        for (uint16_t s_x = 0; s_x < 16 * scale; s_x++) {
            uint16_t src_x = s_x / scale;
            uint16_t src_y = s_y / scale;
            uint16_t byte_index = src_y * ((16 + 7) / 8) + src_x / 8;
            uint8_t bit_mask = 0x80 >> (src_x % 8);
            if (pgm_read_byte(&BITMAP_6587[byte_index]) & bit_mask) {
                display.drawPixel(x + 34 * scale + s_x, y + s_y, GxEPD_BLACK);
            }
        }
    }

    // '字'
    for (uint16_t s_y = 0; s_y < 16 * scale; s_y++) {
        for (uint16_t s_x = 0; s_x < 16 * scale; s_x++) {
            uint16_t src_x = s_x / scale;
            uint16_t src_y = s_y / scale;
            uint16_t byte_index = src_y * ((16 + 7) / 8) + src_x / 8;
            uint8_t bit_mask = 0x80 >> (src_x % 8);
            if (pgm_read_byte(&BITMAP_5B57[byte_index]) & bit_mask) {
                display.drawPixel(x + 51 * scale + s_x, y + s_y, GxEPD_BLACK);
            }
        }
    }

}

#endif // _FANGSONG_BITMAPS_16PT_H_
